import { i as __toESM, r as __require, t as __commonJSMin } from "./chunk.js";
import { createRequire } from "node:module";
import assert from "node:assert";
const { prototype: ObjectPrototype, hasOwn: ObjectHasOwn, keys: ObjectKeys, values: ObjectValues, freeze: ObjectFreeze, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, create: ObjectCreate, assign: ObjectAssign, getPrototypeOf: ObjectGetPrototypeOf, setPrototypeOf: ObjectSetPrototypeOf, entries: ObjectEntries } = Object, { prototype: ArrayPrototype, isArray: ArrayIsArray, from: ArrayFrom } = Array, { min: MathMin, max: MathMax, floor: MathFloor } = Math, { parse: JSONParse, stringify: JSONStringify } = JSON, { ownKeys: ReflectOwnKeys } = Reflect, { iterator: SymbolIterator } = Symbol, BUFFER_SIZE = 2147483616, BUFFER_ALIGN = 4294967296, DATA_POINTER_POS_32 = 536870902, { freeze } = Object, $EMPTY = freeze([]), DECORATORS__KEY__TYPE_ANNOTATION__VALUE = freeze([
	"decorators",
	"key",
	"typeAnnotation",
	"value"
]), LEFT__RIGHT = freeze(["left", "right"]), ARGUMENT = freeze(["argument"]), BODY = freeze(["body"]), LABEL = freeze(["label"]), CALLEE__TYPE_ARGUMENTS__ARGUMENTS = freeze([
	"callee",
	"typeArguments",
	"arguments"
]), EXPRESSION = freeze(["expression"]), DECORATORS__ID__TYPE_PARAMETERS__SUPER_CLASS__SUPER_TYPE_ARGUMENTS__IMPLEMENTS__BODY = freeze([
	"decorators",
	"id",
	"typeParameters",
	"superClass",
	"superTypeArguments",
	"implements",
	"body"
]), TEST__CONSEQUENT__ALTERNATE = freeze([
	"test",
	"consequent",
	"alternate"
]), LEFT__RIGHT__BODY = freeze([
	"left",
	"right",
	"body"
]), ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY = freeze([
	"id",
	"typeParameters",
	"params",
	"returnType",
	"body"
]), KEY__VALUE = freeze(["key", "value"]), LOCAL = freeze(["local"]), OBJECT__PROPERTY = freeze(["object", "property"]), DECORATORS__KEY__TYPE_ANNOTATION = freeze([
	"decorators",
	"key",
	"typeAnnotation"
]), EXPRESSION__TYPE_ANNOTATION = freeze(["expression", "typeAnnotation"]), TYPE_PARAMETERS__PARAMS__RETURN_TYPE = freeze([
	"typeParameters",
	"params",
	"returnType"
]), EXPRESSION__TYPE_ARGUMENTS = freeze(["expression", "typeArguments"]), MEMBERS = freeze(["members"]), ID__BODY = freeze(["id", "body"]), TYPES = freeze(["types"]), TYPE_ANNOTATION = freeze(["typeAnnotation"]), PARAMS = freeze(["params"]);
var keys_default = freeze({
	DebuggerStatement: $EMPTY,
	EmptyStatement: $EMPTY,
	Literal: $EMPTY,
	PrivateIdentifier: $EMPTY,
	Super: $EMPTY,
	TemplateElement: $EMPTY,
	ThisExpression: $EMPTY,
	JSXClosingFragment: $EMPTY,
	JSXEmptyExpression: $EMPTY,
	JSXIdentifier: $EMPTY,
	JSXOpeningFragment: $EMPTY,
	JSXText: $EMPTY,
	TSAnyKeyword: $EMPTY,
	TSBigIntKeyword: $EMPTY,
	TSBooleanKeyword: $EMPTY,
	TSIntrinsicKeyword: $EMPTY,
	TSJSDocUnknownType: $EMPTY,
	TSNeverKeyword: $EMPTY,
	TSNullKeyword: $EMPTY,
	TSNumberKeyword: $EMPTY,
	TSObjectKeyword: $EMPTY,
	TSStringKeyword: $EMPTY,
	TSSymbolKeyword: $EMPTY,
	TSThisType: $EMPTY,
	TSUndefinedKeyword: $EMPTY,
	TSUnknownKeyword: $EMPTY,
	TSVoidKeyword: $EMPTY,
	AccessorProperty: DECORATORS__KEY__TYPE_ANNOTATION__VALUE,
	ArrayExpression: freeze(["elements"]),
	ArrayPattern: freeze([
		"decorators",
		"elements",
		"typeAnnotation"
	]),
	ArrowFunctionExpression: freeze([
		"typeParameters",
		"params",
		"returnType",
		"body"
	]),
	AssignmentExpression: LEFT__RIGHT,
	AssignmentPattern: freeze([
		"decorators",
		"left",
		"right",
		"typeAnnotation"
	]),
	AwaitExpression: ARGUMENT,
	BinaryExpression: LEFT__RIGHT,
	BlockStatement: BODY,
	BreakStatement: LABEL,
	CallExpression: CALLEE__TYPE_ARGUMENTS__ARGUMENTS,
	CatchClause: freeze(["param", "body"]),
	ChainExpression: EXPRESSION,
	ClassBody: BODY,
	ClassDeclaration: DECORATORS__ID__TYPE_PARAMETERS__SUPER_CLASS__SUPER_TYPE_ARGUMENTS__IMPLEMENTS__BODY,
	ClassExpression: DECORATORS__ID__TYPE_PARAMETERS__SUPER_CLASS__SUPER_TYPE_ARGUMENTS__IMPLEMENTS__BODY,
	ConditionalExpression: TEST__CONSEQUENT__ALTERNATE,
	ContinueStatement: LABEL,
	Decorator: EXPRESSION,
	DoWhileStatement: freeze(["body", "test"]),
	ExportAllDeclaration: freeze([
		"exported",
		"source",
		"attributes"
	]),
	ExportDefaultDeclaration: freeze(["declaration"]),
	ExportNamedDeclaration: freeze([
		"declaration",
		"specifiers",
		"source",
		"attributes"
	]),
	ExportSpecifier: freeze(["local", "exported"]),
	ExpressionStatement: EXPRESSION,
	ForInStatement: LEFT__RIGHT__BODY,
	ForOfStatement: LEFT__RIGHT__BODY,
	ForStatement: freeze([
		"init",
		"test",
		"update",
		"body"
	]),
	FunctionDeclaration: ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY,
	FunctionExpression: ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY,
	Identifier: freeze(["decorators", "typeAnnotation"]),
	IfStatement: TEST__CONSEQUENT__ALTERNATE,
	ImportAttribute: KEY__VALUE,
	ImportDeclaration: freeze([
		"specifiers",
		"source",
		"attributes"
	]),
	ImportDefaultSpecifier: LOCAL,
	ImportExpression: freeze(["source", "options"]),
	ImportNamespaceSpecifier: LOCAL,
	ImportSpecifier: freeze(["imported", "local"]),
	LabeledStatement: freeze(["label", "body"]),
	LogicalExpression: LEFT__RIGHT,
	MemberExpression: OBJECT__PROPERTY,
	MetaProperty: freeze(["meta", "property"]),
	MethodDefinition: freeze([
		"decorators",
		"key",
		"value"
	]),
	NewExpression: CALLEE__TYPE_ARGUMENTS__ARGUMENTS,
	ObjectExpression: freeze(["properties"]),
	ObjectPattern: freeze([
		"decorators",
		"properties",
		"typeAnnotation"
	]),
	ParenthesizedExpression: EXPRESSION,
	Program: BODY,
	Property: KEY__VALUE,
	PropertyDefinition: DECORATORS__KEY__TYPE_ANNOTATION__VALUE,
	RestElement: freeze([
		"decorators",
		"argument",
		"typeAnnotation"
	]),
	ReturnStatement: ARGUMENT,
	SequenceExpression: freeze(["expressions"]),
	SpreadElement: ARGUMENT,
	StaticBlock: BODY,
	SwitchCase: freeze(["test", "consequent"]),
	SwitchStatement: freeze(["discriminant", "cases"]),
	TaggedTemplateExpression: freeze([
		"tag",
		"typeArguments",
		"quasi"
	]),
	TemplateLiteral: freeze(["quasis", "expressions"]),
	ThrowStatement: ARGUMENT,
	TryStatement: freeze([
		"block",
		"handler",
		"finalizer"
	]),
	UnaryExpression: ARGUMENT,
	UpdateExpression: ARGUMENT,
	V8IntrinsicExpression: freeze(["name", "arguments"]),
	VariableDeclaration: freeze(["declarations"]),
	VariableDeclarator: freeze(["id", "init"]),
	WhileStatement: freeze(["test", "body"]),
	WithStatement: freeze(["object", "body"]),
	YieldExpression: ARGUMENT,
	JSXAttribute: freeze(["name", "value"]),
	JSXClosingElement: freeze(["name"]),
	JSXElement: freeze([
		"openingElement",
		"children",
		"closingElement"
	]),
	JSXExpressionContainer: EXPRESSION,
	JSXFragment: freeze([
		"openingFragment",
		"children",
		"closingFragment"
	]),
	JSXMemberExpression: OBJECT__PROPERTY,
	JSXNamespacedName: freeze(["namespace", "name"]),
	JSXOpeningElement: freeze([
		"name",
		"typeArguments",
		"attributes"
	]),
	JSXSpreadAttribute: ARGUMENT,
	JSXSpreadChild: EXPRESSION,
	TSAbstractAccessorProperty: DECORATORS__KEY__TYPE_ANNOTATION,
	TSAbstractMethodDefinition: KEY__VALUE,
	TSAbstractPropertyDefinition: DECORATORS__KEY__TYPE_ANNOTATION,
	TSArrayType: freeze(["elementType"]),
	TSAsExpression: EXPRESSION__TYPE_ANNOTATION,
	TSCallSignatureDeclaration: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
	TSClassImplements: EXPRESSION__TYPE_ARGUMENTS,
	TSConditionalType: freeze([
		"checkType",
		"extendsType",
		"trueType",
		"falseType"
	]),
	TSConstructSignatureDeclaration: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
	TSConstructorType: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
	TSDeclareFunction: ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY,
	TSEmptyBodyFunctionExpression: freeze([
		"id",
		"typeParameters",
		"params",
		"returnType"
	]),
	TSEnumBody: MEMBERS,
	TSEnumDeclaration: ID__BODY,
	TSEnumMember: freeze(["id", "initializer"]),
	TSExportAssignment: EXPRESSION,
	TSExternalModuleReference: EXPRESSION,
	TSFunctionType: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
	TSImportEqualsDeclaration: freeze(["id", "moduleReference"]),
	TSImportType: freeze([
		"source",
		"options",
		"qualifier",
		"typeArguments"
	]),
	TSIndexSignature: freeze(["parameters", "typeAnnotation"]),
	TSIndexedAccessType: freeze(["objectType", "indexType"]),
	TSInferType: freeze(["typeParameter"]),
	TSInstantiationExpression: EXPRESSION__TYPE_ARGUMENTS,
	TSInterfaceBody: BODY,
	TSInterfaceDeclaration: freeze([
		"id",
		"typeParameters",
		"extends",
		"body"
	]),
	TSInterfaceHeritage: EXPRESSION__TYPE_ARGUMENTS,
	TSIntersectionType: TYPES,
	TSJSDocNonNullableType: TYPE_ANNOTATION,
	TSJSDocNullableType: TYPE_ANNOTATION,
	TSLiteralType: freeze(["literal"]),
	TSMappedType: freeze([
		"key",
		"constraint",
		"nameType",
		"typeAnnotation"
	]),
	TSMethodSignature: freeze([
		"key",
		"typeParameters",
		"params",
		"returnType"
	]),
	TSModuleBlock: BODY,
	TSModuleDeclaration: ID__BODY,
	TSNamedTupleMember: freeze(["label", "elementType"]),
	TSNamespaceExportDeclaration: freeze(["id"]),
	TSNonNullExpression: EXPRESSION,
	TSOptionalType: TYPE_ANNOTATION,
	TSParameterProperty: freeze(["decorators", "parameter"]),
	TSParenthesizedType: TYPE_ANNOTATION,
	TSPropertySignature: freeze(["key", "typeAnnotation"]),
	TSQualifiedName: LEFT__RIGHT,
	TSRestType: TYPE_ANNOTATION,
	TSSatisfiesExpression: EXPRESSION__TYPE_ANNOTATION,
	TSTemplateLiteralType: freeze(["quasis", "types"]),
	TSTupleType: freeze(["elementTypes"]),
	TSTypeAliasDeclaration: freeze([
		"id",
		"typeParameters",
		"typeAnnotation"
	]),
	TSTypeAnnotation: TYPE_ANNOTATION,
	TSTypeAssertion: freeze(["typeAnnotation", "expression"]),
	TSTypeLiteral: MEMBERS,
	TSTypeOperator: TYPE_ANNOTATION,
	TSTypeParameter: freeze([
		"name",
		"constraint",
		"default"
	]),
	TSTypeParameterDeclaration: PARAMS,
	TSTypeParameterInstantiation: PARAMS,
	TSTypePredicate: freeze(["parameterName", "typeAnnotation"]),
	TSTypeQuery: freeze(["exprName", "typeArguments"]),
	TSTypeReference: freeze(["typeName", "typeArguments"]),
	TSUnionType: TYPES
});
const LINE_BREAK_PATTERN = /\r\n|[\r\n\u2028\u2029]/gu, lines = [], lineStartIndices = [0];
function initLines() {
	sourceText === null && initSourceText();
	let lastOffset = 0, offset, match;
	for (; (match = LINE_BREAK_PATTERN.exec(sourceText)) !== null;) offset = match.index, lines.push(sourceText.slice(lastOffset, offset)), lineStartIndices.push(lastOffset = offset + match[0].length);
	lines.push(sourceText.slice(lastOffset));
}
function resetLines() {
	lines.length = 0, lineStartIndices.length = 1;
}
function getLineColumnFromOffset(offset) {
	if (typeof offset != "number" || offset < 0 || (offset | 0) !== offset) throw TypeError("Expected `offset` to be a non-negative integer.");
	if (lines.length === 0 && initLines(), offset > sourceText.length) throw RangeError(`Index out of range (requested index ${offset}, but source text has length ${sourceText.length}).`);
	return getLineColumnFromOffsetUnchecked(offset);
}
function getLineColumnFromOffsetUnchecked(offset) {
	let low = 0, high = lineStartIndices.length, mid;
	do
		mid = (low + high) / 2 | 0, offset < lineStartIndices[mid] ? high = mid : low = mid + 1;
	while (low < high);
	return {
		line: low,
		column: offset - lineStartIndices[low - 1]
	};
}
function getOffsetFromLineColumn$1(loc) {
	if (typeof loc == "object" && loc) {
		let { line, column } = loc;
		if (typeof line == "number" && typeof column == "number" && (line | 0) === line && (column | 0) === column) {
			lines.length === 0 && initLines();
			let linesCount = lineStartIndices.length;
			if (line <= 0 || line > linesCount) throw RangeError(`Line number out of range (line ${line} requested). Line numbers should be 1-based, and less than or equal to number of lines in file (${linesCount}).`);
			if (column < 0) throw RangeError(`Invalid column number (column ${column} requested).`);
			let lineOffset = lineStartIndices[line - 1], offset = lineOffset + column, nextLineOffset;
			if (line === linesCount) {
				if (nextLineOffset = sourceText.length, offset <= nextLineOffset) return offset;
			} else if (nextLineOffset = lineStartIndices[line], offset < nextLineOffset) return offset;
			throw RangeError(`Column number out of range (column ${column} requested, but the length of line ${line} is ${nextLineOffset - lineOffset}).`);
		}
	}
	throw TypeError("Expected `loc` to be an object with integer `line` and `column` properties");
}
function getRange(nodeOrToken) {
	return nodeOrToken.range;
}
function getLoc$1(nodeOrToken) {
	return ObjectHasOwn(nodeOrToken, "loc") ? nodeOrToken.loc : getNodeLoc(nodeOrToken);
}
function getNodeLoc(nodeOrToken) {
	lines.length === 0 && initLines();
	let loc = {
		start: getLineColumnFromOffsetUnchecked(nodeOrToken.start),
		end: getLineColumnFromOffsetUnchecked(nodeOrToken.end)
	};
	return ObjectDefineProperty(nodeOrToken, "loc", {
		value: loc,
		writable: !0
	}), loc;
}
function getNodeByRangeIndex(offset) {
	return ast === null && initAst(), offset < ast.start || offset >= ast.end ? null : (index = offset, traverse(ast));
}
let index = 0;
function traverse(node) {
	let keys = keys_default[node.type];
	for (let keyIndex = 0, keysLen = keys.length; keyIndex < keysLen; keyIndex++) {
		let child = node[keys[keyIndex]];
		if (ArrayIsArray(child)) for (let arrIndex = 0, arrLen = child.length; arrIndex < arrLen; arrIndex++) {
			let entry = child[arrIndex];
			if (entry !== null) {
				if (entry.start > index) break;
				if (entry.end > index) return traverse(entry);
			}
		}
		else if (child !== null) {
			if (child.start > index) break;
			if (child.end > index) return traverse(child);
		}
	}
	return node;
}
let tsModule = null, tsSyntaxKind = null;
const TokenProto = ObjectCreate(ObjectPrototype, { loc: {
	get() {
		return getNodeLoc(this);
	},
	enumerable: !0
} });
function parseTokens() {
	tsModule === null && (tsModule = createRequire(import.meta.url)("./typescript.cjs"), tsSyntaxKind = tsModule.SyntaxKind);
	let scriptKind = fileIsTs() ? fileIsJsx() ? tsModule.ScriptKind.TSX : tsModule.ScriptKind.TS : fileIsJsx() ? tsModule.ScriptKind.JSX : tsModule.ScriptKind.JS;
	return convertTokens(tsModule.createSourceFile(filePath, sourceText, {
		jsDocParsingMode: tsModule.JSDocParsingMode.ParseNone,
		languageVersion: tsModule.ScriptTarget.Latest,
		setExternalModuleIndicator: void 0
	}, !0, scriptKind));
}
function convertTokens(tsAst) {
	let tokens = [];
	return walk(tsAst), tokens;
	function walk(node) {
		let { kind } = node;
		kind === tsSyntaxKind.SingleLineCommentTrivia || kind === tsSyntaxKind.MultiLineCommentTrivia || kind === tsSyntaxKind.JSDoc || (kind >= tsSyntaxKind.FirstToken && kind <= tsSyntaxKind.LastToken && kind !== tsSyntaxKind.EndOfFileToken ? convertToken(node, tsAst, tokens) : node.getChildren(tsAst).forEach(walk));
	}
}
function convertToken(token, tsAst, tokens) {
	let { kind } = token, start = kind === tsSyntaxKind.JsxText ? token.getFullStart() : token.getStart(tsAst), end = token.getEnd();
	if (start === end) return;
	let value = sourceText.slice(start, end);
	if (kind === tsSyntaxKind.RegularExpressionLiteral) tokens.push({
		__proto__: TokenProto,
		type: "RegularExpression",
		value,
		regex: {
			flags: value.slice(value.lastIndexOf("/") + 1),
			pattern: value.slice(1, value.lastIndexOf("/"))
		},
		start,
		end,
		range: [start, end]
	});
	else {
		let tokenType = getTokenType(token);
		tokenType === "PrivateIdentifier" && (value = value.slice(1)), tokens.push({
			__proto__: TokenProto,
			type: tokenType,
			value,
			start,
			end,
			range: [start, end]
		});
	}
}
function getTokenType(token) {
	let { kind } = token;
	if (kind === tsSyntaxKind.NullKeyword) return "Null";
	if (kind >= tsSyntaxKind.FirstKeyword && kind <= tsSyntaxKind.LastFutureReservedWord) return kind === tsSyntaxKind.FalseKeyword || kind === tsSyntaxKind.TrueKeyword ? "Boolean" : "Keyword";
	if (kind >= tsSyntaxKind.FirstPunctuation && kind <= tsSyntaxKind.LastPunctuation) return "Punctuator";
	if (kind >= tsSyntaxKind.NoSubstitutionTemplateLiteral && kind <= tsSyntaxKind.TemplateTail) return "Template";
	switch (kind) {
		case tsSyntaxKind.NumericLiteral:
		case tsSyntaxKind.BigIntLiteral: return "Numeric";
		case tsSyntaxKind.PrivateIdentifier: return "PrivateIdentifier";
		case tsSyntaxKind.JsxText: return "JSXText";
		case tsSyntaxKind.StringLiteral: {
			let parentKind = token.parent.kind;
			return parentKind === tsSyntaxKind.JsxAttribute || parentKind === tsSyntaxKind.JsxElement ? "JSXText" : "String";
		}
		case tsSyntaxKind.Identifier: {
			let { parent } = token, parentKind = parent.kind;
			if (isJSXTokenKind(parentKind) || parentKind === tsSyntaxKind.PropertyAccessExpression && hasJSXAncestor(parent.parent)) return "JSXIdentifier";
			let name = token.escapedText;
			if (name === "let" || name === "static" || name === "yield") return "Keyword";
		}
	}
	return "Identifier";
}
function hasJSXAncestor(node) {
	for (; node !== void 0;) {
		if (isJSXTokenKind(node.kind)) return !0;
		node = node.parent;
	}
	return !1;
}
function isJSXTokenKind(kind) {
	return kind >= tsSyntaxKind.JsxElement && kind <= tsSyntaxKind.JsxAttribute;
}
const INCLUDE_COMMENTS_SKIP_OPTIONS = {
	includeComments: !0,
	skip: 0
};
let tokens = null, comments = null, tokensAndComments = null;
function initTokens() {
	tokens = parseTokens();
}
function initTokensAndComments() {
	comments === null && (ast === null && initAst(), comments = ast.comments);
	let commentsLength = comments.length;
	if (commentsLength === 0) {
		tokensAndComments = tokens;
		return;
	}
	let tokensLength = tokens.length;
	if (tokensLength === 0) {
		tokensAndComments = comments;
		return;
	}
	tokensAndComments = [];
	let tokenIndex = 0, commentIndex = 0, token = tokens[0], comment = comments[0], tokenStart = token.start, commentStart = comment.start;
	for (; commentStart < tokenStart;) {
		if (tokensAndComments.push(comment), ++commentIndex === commentsLength) {
			tokensAndComments.push(...tokens.slice(tokenIndex));
			return;
		}
		comment = comments[commentIndex], commentStart = comment.start;
	}
	for (;;) {
		do {
			if (tokensAndComments.push(token), ++tokenIndex === tokensLength) {
				tokensAndComments.push(...comments.slice(commentIndex));
				return;
			}
			token = tokens[tokenIndex], tokenStart = token.start;
		} while (tokenStart < commentStart);
		do {
			if (tokensAndComments.push(comment), ++commentIndex === commentsLength) {
				tokensAndComments.push(...tokens.slice(tokenIndex));
				return;
			}
			comment = comments[commentIndex], commentStart = comment.start;
		} while (commentStart < tokenStart);
	}
}
function resetTokens() {
	tokens = null, comments = null, tokensAndComments = null;
}
function getTokens(node, countOptions, afterCount) {
	tokens === null && initTokens();
	let count = typeof countOptions == "object" && countOptions ? countOptions.count : null, beforeCount = typeof countOptions == "number" ? countOptions : 0;
	afterCount = (typeof countOptions == "number" || countOptions === void 0) && typeof afterCount == "number" ? afterCount : 0;
	let filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let { range } = node, rangeStart = range[0], rangeEnd = range[1], tokensLength = tokenList.length, sliceStart = tokensLength;
	for (let lo = 0; lo < sliceStart;) {
		let mid = lo + sliceStart >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : sliceStart = mid;
	}
	let sliceEnd = tokensLength;
	for (let lo = sliceStart; lo < sliceEnd;) {
		let mid = lo + sliceEnd >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : sliceEnd = mid;
	}
	if (sliceStart = MathMax(0, sliceStart - beforeCount), sliceEnd = MathMin(sliceEnd + afterCount, tokensLength), typeof filter != "function") return tokenList.slice(sliceStart, MathMin(sliceStart + (count ?? sliceEnd), sliceEnd));
	let allTokens = [];
	if (typeof count != "number") {
		for (let i = sliceStart; i < sliceEnd; i++) {
			let token = tokenList[i];
			filter(token) && allTokens.push(token);
		}
		return allTokens;
	}
	for (let i = sliceStart; i < sliceEnd && count > 0; i++) {
		let token = tokenList[i];
		filter(token) && (allTokens.push(token), count--);
	}
	return allTokens;
}
function getFirstToken(node, skipOptions) {
	tokens === null && initTokens();
	let skip = typeof skipOptions == "number" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.skip : null, filter = typeof skipOptions == "function" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.filter : null, includeComments = typeof skipOptions == "object" && !!skipOptions && "includeComments" in skipOptions && skipOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let { range } = node, rangeStart = range[0], rangeEnd = range[1], tokensLength = tokenList.length, startIndex = tokensLength;
	for (let lo = 0; lo < startIndex;) {
		let mid = lo + startIndex >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : startIndex = mid;
	}
	if (typeof filter != "function") {
		let skipTo = startIndex + (skip ?? 0);
		if (skipTo >= tokensLength) return null;
		let token = tokenList[skipTo];
		return token.start >= rangeEnd ? null : token;
	}
	if (typeof skip != "number") for (let i = startIndex; i < tokensLength; i++) {
		let token = tokenList[i];
		if (token.start >= rangeEnd) return null;
		if (filter(token)) return token;
	}
	else for (let i = startIndex; i < tokensLength; i++) {
		let token = tokenList[i];
		if (token.start >= rangeEnd) return null;
		if (filter(token)) {
			if (skip <= 0) return token;
			skip--;
		}
	}
	return null;
}
function getFirstTokens(node, countOptions) {
	tokens === null && initTokens();
	let count = typeof countOptions == "number" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.count : null, filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let { range } = node, rangeStart = range[0], rangeEnd = range[1], tokensLength = tokenList.length, sliceStart = tokensLength;
	for (let lo = 0; lo < sliceStart;) {
		let mid = lo + sliceStart >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : sliceStart = mid;
	}
	let sliceEnd = tokensLength;
	for (let lo = sliceStart; lo < sliceEnd;) {
		let mid = lo + sliceEnd >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : sliceEnd = mid;
	}
	if (typeof filter != "function") return typeof count == "number" ? tokenList.slice(sliceStart, MathMin(sliceStart + count, sliceEnd)) : tokenList.slice(sliceStart, sliceEnd);
	let firstTokens = [];
	if (typeof count != "number") for (let i = sliceStart; i < sliceEnd; i++) {
		let token = tokenList[i];
		filter(token) && firstTokens.push(token);
	}
	else for (let i = sliceStart; i < sliceEnd && firstTokens.length < count; i++) {
		let token = tokenList[i];
		filter(token) && firstTokens.push(token);
	}
	return firstTokens;
}
function getLastToken(node, skipOptions) {
	tokens === null && initTokens();
	let skip = typeof skipOptions == "number" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.skip : null, filter = typeof skipOptions == "function" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.filter : null, includeComments = typeof skipOptions == "object" && !!skipOptions && "includeComments" in skipOptions && skipOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let { range } = node, rangeStart = range[0], rangeEnd = range[1], tokensLength = tokenList.length, lastTokenIndex = 0;
	for (let hi = tokensLength; lastTokenIndex < hi;) {
		let mid = lastTokenIndex + hi >> 1;
		tokenList[mid].start < rangeEnd ? lastTokenIndex = mid + 1 : hi = mid;
	}
	if (lastTokenIndex--, typeof filter != "function") {
		let skipTo = lastTokenIndex - (skip ?? 0);
		if (skipTo < 0) return null;
		let token = tokenList[skipTo];
		return token.start < rangeStart ? null : token;
	}
	if (typeof skip != "number") for (let i = lastTokenIndex; i >= 0; i--) {
		let token = tokenList[i];
		if (token.start < rangeStart) return null;
		if (filter(token)) return token;
	}
	else for (let i = lastTokenIndex; i >= 0; i--) {
		let token = tokenList[i];
		if (token.start < rangeStart) return null;
		if (filter(token)) {
			if (skip <= 0) return token;
			skip--;
		}
	}
	return null;
}
function getLastTokens(node, countOptions) {
	tokens === null && initTokens();
	let count = typeof countOptions == "number" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.count : null, filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let { range } = node, rangeStart = range[0], rangeEnd = range[1], tokensLength = tokenList.length, sliceStart = tokensLength;
	for (let lo = 0; lo < sliceStart;) {
		let mid = lo + sliceStart >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : sliceStart = mid;
	}
	let sliceEnd = tokensLength;
	for (let lo = sliceStart; lo < sliceEnd;) {
		let mid = lo + sliceEnd >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : sliceEnd = mid;
	}
	if (typeof filter != "function") return typeof count == "number" ? tokenList.slice(MathMax(sliceStart, sliceEnd - count), sliceEnd) : tokenList.slice(sliceStart, sliceEnd);
	let lastTokens = [];
	if (typeof count != "number") for (let i = sliceStart; i < sliceEnd; i++) {
		let token = tokenList[i];
		filter(token) && lastTokens.push(token);
	}
	else for (let i = sliceEnd - 1; i >= sliceStart && lastTokens.length < count; i--) {
		let token = tokenList[i];
		filter(token) && lastTokens.unshift(token);
	}
	return lastTokens;
}
function getTokenBefore(nodeOrToken, skipOptions) {
	tokens === null && initTokens();
	let skip = typeof skipOptions == "number" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.skip : null, filter = typeof skipOptions == "function" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.filter : null, includeComments = typeof skipOptions == "object" && !!skipOptions && "includeComments" in skipOptions && skipOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let nodeStart = nodeOrToken.range[0], beforeIndex = 0, hi = tokenList.length;
	for (; beforeIndex < hi;) {
		let mid = beforeIndex + hi >> 1;
		tokenList[mid].start < nodeStart ? beforeIndex = mid + 1 : hi = mid;
	}
	if (beforeIndex--, typeof filter != "function") {
		let skipTo = beforeIndex - (skip ?? 0);
		return skipTo < 0 ? null : tokenList[skipTo];
	}
	if (typeof skip != "number") for (; beforeIndex >= 0;) {
		let token = tokenList[beforeIndex];
		if (filter(token)) return token;
		beforeIndex--;
	}
	else for (; beforeIndex >= 0;) {
		let token = tokenList[beforeIndex];
		if (filter(token)) {
			if (skip <= 0) return token;
			skip--;
		}
		beforeIndex--;
	}
	return null;
}
function getTokenOrCommentBefore(nodeOrToken, skip) {
	return INCLUDE_COMMENTS_SKIP_OPTIONS.skip = skip, getTokenBefore(nodeOrToken, INCLUDE_COMMENTS_SKIP_OPTIONS);
}
function getTokensBefore(nodeOrToken, countOptions) {
	tokens === null && initTokens();
	let count = typeof countOptions == "number" ? MathMax(0, countOptions) : typeof countOptions == "object" && countOptions ? countOptions.count : null, filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let targetStart = nodeOrToken.range[0], sliceEnd = 0, hi = tokenList.length;
	for (; sliceEnd < hi;) {
		let mid = sliceEnd + hi >> 1;
		tokenList[mid].start < targetStart ? sliceEnd = mid + 1 : hi = mid;
	}
	if (typeof filter != "function") return typeof count == "number" ? tokenList.slice(sliceEnd - count, sliceEnd) : tokenList.slice(0, sliceEnd);
	let tokensBefore = [];
	if (typeof count != "number") for (let i = 0; i < sliceEnd; i++) {
		let token = tokenList[i];
		filter(token) && tokensBefore.push(token);
	}
	else for (let i = sliceEnd - 1; i >= 0 && tokensBefore.length < count; i--) {
		let token = tokenList[i];
		filter(token) && tokensBefore.unshift(token);
	}
	return tokensBefore;
}
function getTokenAfter(nodeOrToken, skipOptions) {
	tokens === null && initTokens();
	let skip = typeof skipOptions == "number" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.skip : null, filter = typeof skipOptions == "function" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.filter : null, includeComments = typeof skipOptions == "object" && !!skipOptions && "includeComments" in skipOptions && skipOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let rangeEnd = nodeOrToken.range[1], tokensLength = tokenList.length, startIndex = tokensLength;
	for (let lo = 0; lo < startIndex;) {
		let mid = lo + startIndex >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : startIndex = mid;
	}
	if (typeof filter != "function") {
		let skipTo = startIndex + (skip ?? 0);
		return skipTo >= tokensLength ? null : tokenList[skipTo];
	}
	if (typeof skip != "number") for (let i = startIndex; i < tokensLength; i++) {
		let token = tokenList[i];
		if (filter(token)) return token;
	}
	else for (let i = startIndex; i < tokensLength; i++) {
		let token = tokenList[i];
		if (filter(token)) {
			if (skip <= 0) return token;
			skip--;
		}
	}
	return null;
}
function getTokenOrCommentAfter(nodeOrToken, skip) {
	return INCLUDE_COMMENTS_SKIP_OPTIONS.skip = skip, getTokenAfter(nodeOrToken, INCLUDE_COMMENTS_SKIP_OPTIONS);
}
function getTokensAfter(nodeOrToken, countOptions) {
	tokens === null && initTokens();
	let count = typeof countOptions == "number" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.count : null, filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let rangeEnd = nodeOrToken.range[1], sliceStart = tokenList.length;
	for (let lo = 0; lo < sliceStart;) {
		let mid = lo + sliceStart >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : sliceStart = mid;
	}
	if (typeof filter != "function") return typeof count == "number" ? tokenList.slice(sliceStart, sliceStart + count) : tokenList.slice(sliceStart);
	let tokenListAfter = [];
	if (typeof count != "number") for (let i = sliceStart; i < tokenList.length; i++) {
		let token = tokenList[i];
		filter(token) && tokenListAfter.push(token);
	}
	else for (let i = sliceStart; i < tokenList.length && tokenListAfter.length < count; i++) {
		let token = tokenList[i];
		filter(token) && tokenListAfter.push(token);
	}
	return tokenListAfter;
}
function getTokensBetween(left, right, countOptions) {
	tokens === null && initTokens();
	let count = typeof countOptions == "object" && countOptions ? countOptions.count : null, padding = typeof countOptions == "number" ? countOptions : 0, filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let rangeStart = left.range[1], rangeEnd = right.range[0], tokensLength = tokenList.length, sliceStart = tokensLength;
	for (let lo = 0; lo < sliceStart;) {
		let mid = lo + sliceStart >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : sliceStart = mid;
	}
	let sliceEnd = tokensLength;
	for (let lo = sliceStart; lo < sliceEnd;) {
		let mid = lo + sliceEnd >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : sliceEnd = mid;
	}
	if (sliceStart = MathMax(0, sliceStart - padding), sliceEnd += padding, typeof filter != "function") return typeof count == "number" ? tokenList.slice(sliceStart, MathMin(sliceStart + count, sliceEnd)) : tokenList.slice(sliceStart, sliceEnd);
	let tokensBetween = [];
	if (typeof count != "number") for (let i = sliceStart; i < sliceEnd; i++) {
		let token = tokenList[i];
		filter(token) && tokensBetween.push(token);
	}
	else for (let i = sliceStart; i < sliceEnd && tokensBetween.length < count; i++) {
		let token = tokenList[i];
		filter(token) && tokensBetween.push(token);
	}
	return tokensBetween;
}
function getFirstTokenBetween(left, right, skipOptions) {
	tokens === null && initTokens();
	let skip = typeof skipOptions == "number" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.skip : null, filter = typeof skipOptions == "function" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.filter : null, includeComments = typeof skipOptions == "object" && !!skipOptions && "includeComments" in skipOptions && skipOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let rangeStart = left.range[1], rangeEnd = right.range[0], tokensLength = tokenList.length, firstTokenIndex = tokensLength;
	for (let lo = 0; lo < firstTokenIndex;) {
		let mid = lo + firstTokenIndex >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : firstTokenIndex = mid;
	}
	if (typeof filter != "function") {
		let skipTo = firstTokenIndex + (skip ?? 0);
		if (skipTo >= tokensLength) return null;
		let token = tokenList[skipTo];
		return token.start >= rangeEnd ? null : token;
	}
	if (typeof skip != "number") for (let i = firstTokenIndex; i < tokensLength; i++) {
		let token = tokenList[i];
		if (token.start >= rangeEnd) return null;
		if (filter(token)) return token;
	}
	else for (let i = firstTokenIndex; i < tokensLength; i++) {
		let token = tokenList[i];
		if (token.start >= rangeEnd) return null;
		if (filter(token)) {
			if (skip <= 0) return token;
			skip--;
		}
	}
	return null;
}
function getFirstTokensBetween(left, right, countOptions) {
	tokens === null && initTokens();
	let count = typeof countOptions == "number" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.count : null, filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let rangeStart = left.range[1], rangeEnd = right.range[0], tokensLength = tokenList.length, sliceStart = tokensLength;
	for (let lo = 0; lo < sliceStart;) {
		let mid = lo + sliceStart >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : sliceStart = mid;
	}
	let sliceEnd = tokensLength;
	for (let lo = sliceStart; lo < sliceEnd;) {
		let mid = lo + sliceEnd >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : sliceEnd = mid;
	}
	if (typeof filter != "function") return typeof count == "number" ? tokenList.slice(sliceStart, MathMin(sliceStart + count, sliceEnd)) : tokenList.slice(sliceStart, sliceEnd);
	let firstTokens = [];
	if (typeof count != "number") for (let i = sliceStart; i < sliceEnd; i++) {
		let token = tokenList[i];
		filter(token) && firstTokens.push(token);
	}
	else for (let i = sliceStart; i < sliceEnd && firstTokens.length < count; i++) {
		let token = tokenList[i];
		filter(token) && firstTokens.push(token);
	}
	return firstTokens;
}
function getLastTokenBetween(left, right, skipOptions) {
	tokens === null && initTokens();
	let skip = typeof skipOptions == "number" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.skip : null, filter = typeof skipOptions == "function" ? skipOptions : typeof skipOptions == "object" && skipOptions ? skipOptions.filter : null, includeComments = typeof skipOptions == "object" && !!skipOptions && "includeComments" in skipOptions && skipOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let rangeStart = left.range[1], rangeEnd = right.range[0], lastTokenIndex = -1;
	for (let lo = 0, hi = tokenList.length - 1; lo <= hi;) {
		let mid = lo + hi >> 1;
		tokenList[mid].start < rangeEnd ? (lastTokenIndex = mid, lo = mid + 1) : hi = mid - 1;
	}
	if (typeof filter != "function") {
		let skipTo = lastTokenIndex - (skip ?? 0);
		if (skipTo < 0) return null;
		let token = tokenList[skipTo];
		return token.start < rangeStart ? null : token;
	}
	if (typeof skip != "number") for (let i = lastTokenIndex; i >= 0; i--) {
		let token = tokenList[i];
		if (token.start < rangeStart) return null;
		if (filter(token)) return token;
	}
	else for (let i = lastTokenIndex; i >= 0; i--) {
		let token = tokenList[i];
		if (token.start < rangeStart) return null;
		if (filter(token)) {
			if (skip <= 0) return token;
			skip--;
		}
	}
	return null;
}
function getLastTokensBetween(left, right, countOptions) {
	tokens === null && initTokens();
	let count = typeof countOptions == "number" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.count : null, filter = typeof countOptions == "function" ? countOptions : typeof countOptions == "object" && countOptions ? countOptions.filter : null, includeComments = typeof countOptions == "object" && !!countOptions && "includeComments" in countOptions && countOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	let rangeStart = left.range[1], rangeEnd = right.range[0], tokensLength = tokenList.length, sliceStart = tokensLength;
	for (let lo = 0; lo < sliceStart;) {
		let mid = lo + sliceStart >> 1;
		tokenList[mid].start < rangeStart ? lo = mid + 1 : sliceStart = mid;
	}
	let sliceEnd = tokensLength;
	for (let lo = sliceStart; lo < sliceEnd;) {
		let mid = lo + sliceEnd >> 1;
		tokenList[mid].start < rangeEnd ? lo = mid + 1 : sliceEnd = mid;
	}
	if (typeof filter != "function") return typeof count == "number" ? tokenList.slice(MathMax(sliceStart, sliceEnd - count), sliceEnd) : tokenList.slice(sliceStart, sliceEnd);
	let tokensBetween = [];
	if (typeof count != "number") for (let i = sliceStart; i < sliceEnd; i++) {
		let token = tokenList[i];
		filter(token) && tokensBetween.push(token);
	}
	else for (let i = sliceEnd - 1; i >= sliceStart && tokensBetween.length < count; i--) {
		let token = tokenList[i];
		filter(token) && tokensBetween.unshift(token);
	}
	return tokensBetween;
}
function getTokenByRangeStart(index, rangeOptions) {
	tokens === null && initTokens();
	let includeComments = typeof rangeOptions == "object" && !!rangeOptions && "includeComments" in rangeOptions && rangeOptions.includeComments, tokenList;
	includeComments ? (tokensAndComments === null && initTokensAndComments(), tokenList = tokensAndComments) : tokenList = tokens;
	for (let lo = 0, hi = tokenList.length; lo < hi;) {
		let mid = lo + hi >> 1, tokenStart = tokenList[mid].start;
		if (tokenStart === index) return tokenList[mid];
		tokenStart < index ? lo = mid + 1 : hi = mid;
	}
	return null;
}
const JSX_WHITESPACE_REGEXP = /\s/u;
function isSpaceBetween(first, second) {
	tokensAndComments === null && (tokens === null && initTokens(), initTokensAndComments());
	let range1 = first.range, range2 = second.range, rangeStart = range1[0], rangeEnd = range2[0];
	rangeStart < rangeEnd ? rangeStart = range1[1] : (rangeEnd = rangeStart, rangeStart = range2[1]);
	let tokensAndCommentsLength = tokensAndComments.length, tokenBetweenIndex = tokensAndCommentsLength;
	for (let lo = 0; lo < tokenBetweenIndex;) {
		let mid = lo + tokenBetweenIndex >> 1;
		tokensAndComments[mid].start < rangeStart ? lo = mid + 1 : tokenBetweenIndex = mid;
	}
	for (let lastTokenEnd = rangeStart; tokenBetweenIndex < tokensAndCommentsLength; tokenBetweenIndex++) {
		let token = tokensAndComments[tokenBetweenIndex], tokenStart = token.start;
		if (tokenStart > rangeEnd) break;
		if (tokenStart !== lastTokenEnd) return !0;
		lastTokenEnd = token.end;
	}
	return !1;
}
function isSpaceBetweenTokens(first, second) {
	tokensAndComments === null && (tokens === null && initTokens(), initTokensAndComments());
	let range1 = first.range, range2 = second.range, rangeStart = range1[0], rangeEnd = range2[0];
	rangeStart < rangeEnd ? rangeStart = range1[1] : (rangeEnd = rangeStart, rangeStart = range2[1]);
	let tokensAndCommentsLength = tokensAndComments.length, tokenBetweenIndex = tokensAndCommentsLength;
	for (let lo = 0; lo < tokenBetweenIndex;) {
		let mid = lo + tokenBetweenIndex >> 1;
		tokensAndComments[mid].start < rangeStart ? lo = mid + 1 : tokenBetweenIndex = mid;
	}
	for (let lastTokenEnd = rangeStart; tokenBetweenIndex < tokensAndCommentsLength; tokenBetweenIndex++) {
		let token = tokensAndComments[tokenBetweenIndex], tokenStart = token.start;
		if (tokenStart > rangeEnd) break;
		if (tokenStart !== lastTokenEnd || token.type === "JSXText" && JSX_WHITESPACE_REGEXP.test(token.value)) return !0;
		lastTokenEnd = token.end;
	}
	return !1;
}
let uint8, uint32, float64, sourceText$1, sourceIsAscii, sourceStartPos$1, sourceEndPos, astId = 0, parent = null, getLoc;
const textDecoder$1 = new TextDecoder("utf-8", { ignoreBOM: !0 }), decodeStr = textDecoder$1.decode.bind(textDecoder$1), { fromCodePoint } = String, NodeProto = Object.create(Object.prototype, { loc: {
	get() {
		return getLoc(this);
	},
	enumerable: !0
} });
function deserializeProgramOnly(buffer, sourceText, sourceStartPosInput, sourceByteLen, getLoc) {
	return sourceStartPos$1 = sourceStartPosInput, sourceEndPos = sourceStartPosInput + sourceByteLen, deserializeWith(buffer, sourceText, sourceByteLen, getLoc, deserializeProgram);
}
function deserializeWith(buffer, sourceTextInput, sourceByteLen, getLocInput, deserialize) {
	return uint8 = buffer, uint32 = buffer.uint32, float64 = buffer.float64, sourceText$1 = sourceTextInput, sourceIsAscii = sourceText$1.length === sourceByteLen, getLoc = getLocInput, deserialize(uint32[536870902]);
}
function resetBuffer() {
	uint8 = uint32 = float64 = sourceText$1 = void 0, astId++;
}
function deserializeProgram(pos) {
	let localAstId = astId, end = deserializeU32(pos + 4), program = parent = {
		__proto__: NodeProto,
		type: "Program",
		body: null,
		sourceType: deserializeModuleKind(pos + 125),
		hashbang: null,
		get comments() {
			if (localAstId !== astId) throw Error("Comments are only accessible while linting the file");
			let comments = deserializeVecComment(pos + 24), { hashbang } = this;
			if (hashbang !== null) {
				let start, end;
				comments.unshift({
					__proto__: NodeProto,
					type: "Shebang",
					value: hashbang.value,
					start: start = hashbang.start,
					end: end = hashbang.end,
					range: [start, end]
				});
			}
			return Object.defineProperty(this, "comments", { value: comments }), comments;
		},
		get tokens() {
			return tokens === null && initTokens(), tokens;
		},
		start: 0,
		end,
		range: [0, end],
		parent: null
	};
	program.hashbang = deserializeOptionHashbang(pos + 48);
	let body = program.body = deserializeVecDirective(pos + 72);
	body.push(...deserializeVecStatement(pos + 96));
	{
		let start;
		if (body.length > 0) {
			let first = body[0];
			if (start = first.start, first.type === "ExportNamedDeclaration" || first.type === "ExportDefaultDeclaration") {
				let { declaration } = first;
				if (declaration !== null && declaration.type === "ClassDeclaration" && declaration.decorators.length > 0) {
					let decoratorStart = declaration.decorators[0].start;
					decoratorStart < start && (start = decoratorStart);
				}
			}
		} else start = end;
		program.start = program.range[0] = start;
	}
	return parent = null, program;
}
function deserializeExpression(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNullLiteral(pos + 8);
		case 2: return deserializeBoxNumericLiteral(pos + 8);
		case 3: return deserializeBoxBigIntLiteral(pos + 8);
		case 4: return deserializeBoxRegExpLiteral(pos + 8);
		case 5: return deserializeBoxStringLiteral(pos + 8);
		case 6: return deserializeBoxTemplateLiteral(pos + 8);
		case 7: return deserializeBoxIdentifierReference(pos + 8);
		case 8: return deserializeBoxMetaProperty(pos + 8);
		case 9: return deserializeBoxSuper(pos + 8);
		case 10: return deserializeBoxArrayExpression(pos + 8);
		case 11: return deserializeBoxArrowFunctionExpression(pos + 8);
		case 12: return deserializeBoxAssignmentExpression(pos + 8);
		case 13: return deserializeBoxAwaitExpression(pos + 8);
		case 14: return deserializeBoxBinaryExpression(pos + 8);
		case 15: return deserializeBoxCallExpression(pos + 8);
		case 16: return deserializeBoxChainExpression(pos + 8);
		case 17: return deserializeBoxClass(pos + 8);
		case 18: return deserializeBoxConditionalExpression(pos + 8);
		case 19: return deserializeBoxFunction(pos + 8);
		case 20: return deserializeBoxImportExpression(pos + 8);
		case 21: return deserializeBoxLogicalExpression(pos + 8);
		case 22: return deserializeBoxNewExpression(pos + 8);
		case 23: return deserializeBoxObjectExpression(pos + 8);
		case 24: return deserializeBoxParenthesizedExpression(pos + 8);
		case 25: return deserializeBoxSequenceExpression(pos + 8);
		case 26: return deserializeBoxTaggedTemplateExpression(pos + 8);
		case 27: return deserializeBoxThisExpression(pos + 8);
		case 28: return deserializeBoxUnaryExpression(pos + 8);
		case 29: return deserializeBoxUpdateExpression(pos + 8);
		case 30: return deserializeBoxYieldExpression(pos + 8);
		case 31: return deserializeBoxPrivateInExpression(pos + 8);
		case 32: return deserializeBoxJSXElement(pos + 8);
		case 33: return deserializeBoxJSXFragment(pos + 8);
		case 34: return deserializeBoxTSAsExpression(pos + 8);
		case 35: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 36: return deserializeBoxTSTypeAssertion(pos + 8);
		case 37: return deserializeBoxTSNonNullExpression(pos + 8);
		case 38: return deserializeBoxTSInstantiationExpression(pos + 8);
		case 39: return deserializeBoxV8IntrinsicExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for Expression`);
	}
}
function deserializeIdentifierName(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: null,
		name: deserializeStr(pos + 8),
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.optional = !1, parent = previousParent, node;
}
function deserializeIdentifierReference(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: null,
		name: deserializeStr(pos + 8),
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.optional = !1, parent = previousParent, node;
}
function deserializeBindingIdentifier(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: null,
		name: deserializeStr(pos + 8),
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.optional = !1, parent = previousParent, node;
}
function deserializeLabelIdentifier(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: null,
		name: deserializeStr(pos + 8),
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.optional = !1, parent = previousParent, node;
}
function deserializeThisExpression(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "ThisExpression",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeArrayExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ArrayExpression",
		elements: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.elements = deserializeVecArrayExpressionElement(pos + 8), parent = previousParent, node;
}
function deserializeArrayExpressionElement(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNullLiteral(pos + 8);
		case 2: return deserializeBoxNumericLiteral(pos + 8);
		case 3: return deserializeBoxBigIntLiteral(pos + 8);
		case 4: return deserializeBoxRegExpLiteral(pos + 8);
		case 5: return deserializeBoxStringLiteral(pos + 8);
		case 6: return deserializeBoxTemplateLiteral(pos + 8);
		case 7: return deserializeBoxIdentifierReference(pos + 8);
		case 8: return deserializeBoxMetaProperty(pos + 8);
		case 9: return deserializeBoxSuper(pos + 8);
		case 10: return deserializeBoxArrayExpression(pos + 8);
		case 11: return deserializeBoxArrowFunctionExpression(pos + 8);
		case 12: return deserializeBoxAssignmentExpression(pos + 8);
		case 13: return deserializeBoxAwaitExpression(pos + 8);
		case 14: return deserializeBoxBinaryExpression(pos + 8);
		case 15: return deserializeBoxCallExpression(pos + 8);
		case 16: return deserializeBoxChainExpression(pos + 8);
		case 17: return deserializeBoxClass(pos + 8);
		case 18: return deserializeBoxConditionalExpression(pos + 8);
		case 19: return deserializeBoxFunction(pos + 8);
		case 20: return deserializeBoxImportExpression(pos + 8);
		case 21: return deserializeBoxLogicalExpression(pos + 8);
		case 22: return deserializeBoxNewExpression(pos + 8);
		case 23: return deserializeBoxObjectExpression(pos + 8);
		case 24: return deserializeBoxParenthesizedExpression(pos + 8);
		case 25: return deserializeBoxSequenceExpression(pos + 8);
		case 26: return deserializeBoxTaggedTemplateExpression(pos + 8);
		case 27: return deserializeBoxThisExpression(pos + 8);
		case 28: return deserializeBoxUnaryExpression(pos + 8);
		case 29: return deserializeBoxUpdateExpression(pos + 8);
		case 30: return deserializeBoxYieldExpression(pos + 8);
		case 31: return deserializeBoxPrivateInExpression(pos + 8);
		case 32: return deserializeBoxJSXElement(pos + 8);
		case 33: return deserializeBoxJSXFragment(pos + 8);
		case 34: return deserializeBoxTSAsExpression(pos + 8);
		case 35: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 36: return deserializeBoxTSTypeAssertion(pos + 8);
		case 37: return deserializeBoxTSNonNullExpression(pos + 8);
		case 38: return deserializeBoxTSInstantiationExpression(pos + 8);
		case 39: return deserializeBoxV8IntrinsicExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		case 64: return deserializeBoxSpreadElement(pos + 8);
		case 65: return deserializeElision(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ArrayExpressionElement`);
	}
}
function deserializeElision(pos) {
	return null;
}
function deserializeObjectExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ObjectExpression",
		properties: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.properties = deserializeVecObjectPropertyKind(pos + 8), parent = previousParent, node;
}
function deserializeObjectPropertyKind(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxObjectProperty(pos + 8);
		case 1: return deserializeBoxSpreadElement(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ObjectPropertyKind`);
	}
}
function deserializeObjectProperty(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Property",
		kind: deserializePropertyKind(pos + 40),
		key: null,
		value: null,
		method: deserializeBool(pos + 41),
		shorthand: deserializeBool(pos + 42),
		computed: deserializeBool(pos + 43),
		optional: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.key = deserializePropertyKey(pos + 8), node.value = deserializeExpression(pos + 24), node.optional = !1, parent = previousParent, node;
}
function deserializePropertyKey(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNullLiteral(pos + 8);
		case 2: return deserializeBoxNumericLiteral(pos + 8);
		case 3: return deserializeBoxBigIntLiteral(pos + 8);
		case 4: return deserializeBoxRegExpLiteral(pos + 8);
		case 5: return deserializeBoxStringLiteral(pos + 8);
		case 6: return deserializeBoxTemplateLiteral(pos + 8);
		case 7: return deserializeBoxIdentifierReference(pos + 8);
		case 8: return deserializeBoxMetaProperty(pos + 8);
		case 9: return deserializeBoxSuper(pos + 8);
		case 10: return deserializeBoxArrayExpression(pos + 8);
		case 11: return deserializeBoxArrowFunctionExpression(pos + 8);
		case 12: return deserializeBoxAssignmentExpression(pos + 8);
		case 13: return deserializeBoxAwaitExpression(pos + 8);
		case 14: return deserializeBoxBinaryExpression(pos + 8);
		case 15: return deserializeBoxCallExpression(pos + 8);
		case 16: return deserializeBoxChainExpression(pos + 8);
		case 17: return deserializeBoxClass(pos + 8);
		case 18: return deserializeBoxConditionalExpression(pos + 8);
		case 19: return deserializeBoxFunction(pos + 8);
		case 20: return deserializeBoxImportExpression(pos + 8);
		case 21: return deserializeBoxLogicalExpression(pos + 8);
		case 22: return deserializeBoxNewExpression(pos + 8);
		case 23: return deserializeBoxObjectExpression(pos + 8);
		case 24: return deserializeBoxParenthesizedExpression(pos + 8);
		case 25: return deserializeBoxSequenceExpression(pos + 8);
		case 26: return deserializeBoxTaggedTemplateExpression(pos + 8);
		case 27: return deserializeBoxThisExpression(pos + 8);
		case 28: return deserializeBoxUnaryExpression(pos + 8);
		case 29: return deserializeBoxUpdateExpression(pos + 8);
		case 30: return deserializeBoxYieldExpression(pos + 8);
		case 31: return deserializeBoxPrivateInExpression(pos + 8);
		case 32: return deserializeBoxJSXElement(pos + 8);
		case 33: return deserializeBoxJSXFragment(pos + 8);
		case 34: return deserializeBoxTSAsExpression(pos + 8);
		case 35: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 36: return deserializeBoxTSTypeAssertion(pos + 8);
		case 37: return deserializeBoxTSNonNullExpression(pos + 8);
		case 38: return deserializeBoxTSInstantiationExpression(pos + 8);
		case 39: return deserializeBoxV8IntrinsicExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		case 64: return deserializeBoxIdentifierName(pos + 8);
		case 65: return deserializeBoxPrivateIdentifier(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for PropertyKey`);
	}
}
function deserializePropertyKind(pos) {
	switch (uint8[pos]) {
		case 0: return "init";
		case 1: return "get";
		case 2: return "set";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for PropertyKind`);
	}
}
function deserializeTemplateLiteral(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TemplateLiteral",
		quasis: null,
		expressions: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.quasis = deserializeVecTemplateElement(pos + 8), node.expressions = deserializeVecExpression(pos + 32), parent = previousParent, node;
}
function deserializeTaggedTemplateExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TaggedTemplateExpression",
		tag: null,
		typeArguments: null,
		quasi: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.tag = deserializeExpression(pos + 8), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), node.quasi = deserializeTemplateLiteral(pos + 32), parent = previousParent, node;
}
function deserializeTemplateElement(pos) {
	let tail = deserializeBool(pos + 40), start = deserializeU32(pos) - 1, end = deserializeU32(pos + 4) + 2 - tail, value = deserializeTemplateElementValue(pos + 8);
	return value.cooked !== null && deserializeBool(pos + 41) && (value.cooked = value.cooked.replace(/\uFFFD(.{4})/g, (_, hex) => String.fromCodePoint(parseInt(hex, 16)))), {
		__proto__: NodeProto,
		type: "TemplateElement",
		value,
		tail,
		start,
		end,
		range: [start, end],
		parent
	};
}
function deserializeTemplateElementValue(pos) {
	return {
		raw: deserializeStr(pos),
		cooked: deserializeOptionStr(pos + 16)
	};
}
function deserializeComputedMemberExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "MemberExpression",
		object: null,
		property: null,
		optional: deserializeBool(pos + 40),
		computed: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.object = deserializeExpression(pos + 8), node.property = deserializeExpression(pos + 24), node.computed = !0, parent = previousParent, node;
}
function deserializeStaticMemberExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "MemberExpression",
		object: null,
		property: null,
		optional: deserializeBool(pos + 48),
		computed: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.object = deserializeExpression(pos + 8), node.property = deserializeIdentifierName(pos + 24), node.computed = !1, parent = previousParent, node;
}
function deserializePrivateFieldExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "MemberExpression",
		object: null,
		property: null,
		optional: deserializeBool(pos + 48),
		computed: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.object = deserializeExpression(pos + 8), node.property = deserializePrivateIdentifier(pos + 24), node.computed = !1, parent = previousParent, node;
}
function deserializeCallExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "CallExpression",
		callee: null,
		typeArguments: null,
		arguments: null,
		optional: deserializeBool(pos + 56),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.callee = deserializeExpression(pos + 8), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), node.arguments = deserializeVecArgument(pos + 32), parent = previousParent, node;
}
function deserializeNewExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "NewExpression",
		callee: null,
		typeArguments: null,
		arguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.callee = deserializeExpression(pos + 8), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), node.arguments = deserializeVecArgument(pos + 32), parent = previousParent, node;
}
function deserializeMetaProperty(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "MetaProperty",
		meta: null,
		property: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.meta = deserializeIdentifierName(pos + 8), node.property = deserializeIdentifierName(pos + 32), parent = previousParent, node;
}
function deserializeSpreadElement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "SpreadElement",
		argument: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeArgument(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNullLiteral(pos + 8);
		case 2: return deserializeBoxNumericLiteral(pos + 8);
		case 3: return deserializeBoxBigIntLiteral(pos + 8);
		case 4: return deserializeBoxRegExpLiteral(pos + 8);
		case 5: return deserializeBoxStringLiteral(pos + 8);
		case 6: return deserializeBoxTemplateLiteral(pos + 8);
		case 7: return deserializeBoxIdentifierReference(pos + 8);
		case 8: return deserializeBoxMetaProperty(pos + 8);
		case 9: return deserializeBoxSuper(pos + 8);
		case 10: return deserializeBoxArrayExpression(pos + 8);
		case 11: return deserializeBoxArrowFunctionExpression(pos + 8);
		case 12: return deserializeBoxAssignmentExpression(pos + 8);
		case 13: return deserializeBoxAwaitExpression(pos + 8);
		case 14: return deserializeBoxBinaryExpression(pos + 8);
		case 15: return deserializeBoxCallExpression(pos + 8);
		case 16: return deserializeBoxChainExpression(pos + 8);
		case 17: return deserializeBoxClass(pos + 8);
		case 18: return deserializeBoxConditionalExpression(pos + 8);
		case 19: return deserializeBoxFunction(pos + 8);
		case 20: return deserializeBoxImportExpression(pos + 8);
		case 21: return deserializeBoxLogicalExpression(pos + 8);
		case 22: return deserializeBoxNewExpression(pos + 8);
		case 23: return deserializeBoxObjectExpression(pos + 8);
		case 24: return deserializeBoxParenthesizedExpression(pos + 8);
		case 25: return deserializeBoxSequenceExpression(pos + 8);
		case 26: return deserializeBoxTaggedTemplateExpression(pos + 8);
		case 27: return deserializeBoxThisExpression(pos + 8);
		case 28: return deserializeBoxUnaryExpression(pos + 8);
		case 29: return deserializeBoxUpdateExpression(pos + 8);
		case 30: return deserializeBoxYieldExpression(pos + 8);
		case 31: return deserializeBoxPrivateInExpression(pos + 8);
		case 32: return deserializeBoxJSXElement(pos + 8);
		case 33: return deserializeBoxJSXFragment(pos + 8);
		case 34: return deserializeBoxTSAsExpression(pos + 8);
		case 35: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 36: return deserializeBoxTSTypeAssertion(pos + 8);
		case 37: return deserializeBoxTSNonNullExpression(pos + 8);
		case 38: return deserializeBoxTSInstantiationExpression(pos + 8);
		case 39: return deserializeBoxV8IntrinsicExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		case 64: return deserializeBoxSpreadElement(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for Argument`);
	}
}
function deserializeUpdateExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "UpdateExpression",
		operator: deserializeUpdateOperator(pos + 24),
		prefix: deserializeBool(pos + 25),
		argument: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeSimpleAssignmentTarget(pos + 8), parent = previousParent, node;
}
function deserializeUnaryExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "UnaryExpression",
		operator: deserializeUnaryOperator(pos + 24),
		argument: null,
		prefix: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeExpression(pos + 8), node.prefix = !0, parent = previousParent, node;
}
function deserializeBinaryExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "BinaryExpression",
		left: null,
		operator: deserializeBinaryOperator(pos + 40),
		right: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializeExpression(pos + 8), node.right = deserializeExpression(pos + 24), parent = previousParent, node;
}
function deserializePrivateInExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "BinaryExpression",
		left: null,
		operator: null,
		right: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializePrivateIdentifier(pos + 8), node.operator = "in", node.right = deserializeExpression(pos + 32), parent = previousParent, node;
}
function deserializeLogicalExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "LogicalExpression",
		left: null,
		operator: deserializeLogicalOperator(pos + 40),
		right: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializeExpression(pos + 8), node.right = deserializeExpression(pos + 24), parent = previousParent, node;
}
function deserializeConditionalExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ConditionalExpression",
		test: null,
		consequent: null,
		alternate: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.test = deserializeExpression(pos + 8), node.consequent = deserializeExpression(pos + 24), node.alternate = deserializeExpression(pos + 40), parent = previousParent, node;
}
function deserializeAssignmentExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "AssignmentExpression",
		operator: deserializeAssignmentOperator(pos + 40),
		left: null,
		right: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializeAssignmentTarget(pos + 8), node.right = deserializeExpression(pos + 24), parent = previousParent, node;
}
function deserializeAssignmentTarget(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierReference(pos + 8);
		case 1: return deserializeBoxTSAsExpression(pos + 8);
		case 2: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 3: return deserializeBoxTSNonNullExpression(pos + 8);
		case 4: return deserializeBoxTSTypeAssertion(pos + 8);
		case 8: return deserializeBoxArrayAssignmentTarget(pos + 8);
		case 9: return deserializeBoxObjectAssignmentTarget(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for AssignmentTarget`);
	}
}
function deserializeSimpleAssignmentTarget(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierReference(pos + 8);
		case 1: return deserializeBoxTSAsExpression(pos + 8);
		case 2: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 3: return deserializeBoxTSNonNullExpression(pos + 8);
		case 4: return deserializeBoxTSTypeAssertion(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for SimpleAssignmentTarget`);
	}
}
function deserializeArrayAssignmentTarget(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ArrayPattern",
		decorators: null,
		elements: null,
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, elements = deserializeVecOptionAssignmentTargetMaybeDefault(pos + 8), rest = deserializeOptionBoxAssignmentTargetRest(pos + 32);
	return rest !== null && elements.push(rest), node.decorators = [], node.elements = elements, node.optional = !1, parent = previousParent, node;
}
function deserializeObjectAssignmentTarget(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ObjectPattern",
		decorators: null,
		properties: null,
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, properties = deserializeVecAssignmentTargetProperty(pos + 8), rest = deserializeOptionBoxAssignmentTargetRest(pos + 32);
	return rest !== null && properties.push(rest), node.decorators = [], node.properties = properties, node.optional = !1, parent = previousParent, node;
}
function deserializeAssignmentTargetRest(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "RestElement",
		decorators: null,
		argument: null,
		optional: null,
		typeAnnotation: null,
		value: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.argument = deserializeAssignmentTarget(pos + 8), node.optional = !1, parent = previousParent, node;
}
function deserializeAssignmentTargetMaybeDefault(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierReference(pos + 8);
		case 1: return deserializeBoxTSAsExpression(pos + 8);
		case 2: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 3: return deserializeBoxTSNonNullExpression(pos + 8);
		case 4: return deserializeBoxTSTypeAssertion(pos + 8);
		case 8: return deserializeBoxArrayAssignmentTarget(pos + 8);
		case 9: return deserializeBoxObjectAssignmentTarget(pos + 8);
		case 16: return deserializeBoxAssignmentTargetWithDefault(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for AssignmentTargetMaybeDefault`);
	}
}
function deserializeAssignmentTargetWithDefault(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "AssignmentPattern",
		decorators: null,
		left: null,
		right: null,
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.left = deserializeAssignmentTarget(pos + 8), node.right = deserializeExpression(pos + 24), node.optional = !1, parent = previousParent, node;
}
function deserializeAssignmentTargetProperty(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxAssignmentTargetPropertyIdentifier(pos + 8);
		case 1: return deserializeBoxAssignmentTargetPropertyProperty(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for AssignmentTargetProperty`);
	}
}
function deserializeAssignmentTargetPropertyIdentifier(pos) {
	let start = deserializeU32(pos), end = deserializeU32(pos + 4), previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Property",
		kind: null,
		key: null,
		value: null,
		method: null,
		shorthand: null,
		computed: null,
		optional: null,
		start,
		end,
		range: [start, end],
		parent
	}, key = deserializeIdentifierReference(pos + 8), keyStart, keyEnd, value = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: [],
		name: key.name,
		optional: !1,
		typeAnnotation: null,
		start: keyStart = key.start,
		end: keyEnd = key.end,
		range: [keyStart, keyEnd],
		parent
	}, init = deserializeOptionExpression(pos + 40);
	if (init !== null) {
		let left = value;
		value = {
			__proto__: NodeProto,
			type: "AssignmentPattern",
			decorators: [],
			left,
			right: init,
			optional: !1,
			typeAnnotation: null,
			start,
			end,
			range: [start, end],
			parent
		}, left.parent = value, init.parent = value;
	}
	return node.kind = "init", node.key = key, node.value = value, node.method = !1, node.shorthand = !0, node.computed = !1, node.optional = !1, parent = previousParent, node;
}
function deserializeAssignmentTargetPropertyProperty(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Property",
		kind: null,
		key: null,
		value: null,
		method: null,
		shorthand: null,
		computed: deserializeBool(pos + 40),
		optional: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.kind = "init", node.key = deserializePropertyKey(pos + 8), node.value = deserializeAssignmentTargetMaybeDefault(pos + 24), node.method = !1, node.shorthand = !1, node.optional = !1, parent = previousParent, node;
}
function deserializeSequenceExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "SequenceExpression",
		expressions: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expressions = deserializeVecExpression(pos + 8), parent = previousParent, node;
}
function deserializeSuper(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "Super",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeAwaitExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "AwaitExpression",
		argument: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeChainExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ChainExpression",
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeChainElement(pos + 8), parent = previousParent, node;
}
function deserializeChainElement(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxCallExpression(pos + 8);
		case 1: return deserializeBoxTSNonNullExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ChainElement`);
	}
}
function deserializeParenthesizedExpression(pos) {
	let node;
	return node = deserializeExpression(pos + 8), node;
}
function deserializeStatement(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBlockStatement(pos + 8);
		case 1: return deserializeBoxBreakStatement(pos + 8);
		case 2: return deserializeBoxContinueStatement(pos + 8);
		case 3: return deserializeBoxDebuggerStatement(pos + 8);
		case 4: return deserializeBoxDoWhileStatement(pos + 8);
		case 5: return deserializeBoxEmptyStatement(pos + 8);
		case 6: return deserializeBoxExpressionStatement(pos + 8);
		case 7: return deserializeBoxForInStatement(pos + 8);
		case 8: return deserializeBoxForOfStatement(pos + 8);
		case 9: return deserializeBoxForStatement(pos + 8);
		case 10: return deserializeBoxIfStatement(pos + 8);
		case 11: return deserializeBoxLabeledStatement(pos + 8);
		case 12: return deserializeBoxReturnStatement(pos + 8);
		case 13: return deserializeBoxSwitchStatement(pos + 8);
		case 14: return deserializeBoxThrowStatement(pos + 8);
		case 15: return deserializeBoxTryStatement(pos + 8);
		case 16: return deserializeBoxWhileStatement(pos + 8);
		case 17: return deserializeBoxWithStatement(pos + 8);
		case 32: return deserializeBoxVariableDeclaration(pos + 8);
		case 33: return deserializeBoxFunction(pos + 8);
		case 34: return deserializeBoxClass(pos + 8);
		case 35: return deserializeBoxTSTypeAliasDeclaration(pos + 8);
		case 36: return deserializeBoxTSInterfaceDeclaration(pos + 8);
		case 37: return deserializeBoxTSEnumDeclaration(pos + 8);
		case 38: return deserializeBoxTSModuleDeclaration(pos + 8);
		case 39: return deserializeBoxTSGlobalDeclaration(pos + 8);
		case 40: return deserializeBoxTSImportEqualsDeclaration(pos + 8);
		case 64: return deserializeBoxImportDeclaration(pos + 8);
		case 65: return deserializeBoxExportAllDeclaration(pos + 8);
		case 66: return deserializeBoxExportDefaultDeclaration(pos + 8);
		case 67: return deserializeBoxExportNamedDeclaration(pos + 8);
		case 68: return deserializeBoxTSExportAssignment(pos + 8);
		case 69: return deserializeBoxTSNamespaceExportDeclaration(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for Statement`);
	}
}
function deserializeDirective(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ExpressionStatement",
		expression: null,
		directive: deserializeStr(pos + 56),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeStringLiteral(pos + 8), parent = previousParent, node;
}
function deserializeHashbang(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "Hashbang",
		value: deserializeStr(pos + 8),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeBlockStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "BlockStatement",
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.body = deserializeVecStatement(pos + 8), parent = previousParent, node;
}
function deserializeDeclaration(pos) {
	switch (uint8[pos]) {
		case 32: return deserializeBoxVariableDeclaration(pos + 8);
		case 33: return deserializeBoxFunction(pos + 8);
		case 34: return deserializeBoxClass(pos + 8);
		case 35: return deserializeBoxTSTypeAliasDeclaration(pos + 8);
		case 36: return deserializeBoxTSInterfaceDeclaration(pos + 8);
		case 37: return deserializeBoxTSEnumDeclaration(pos + 8);
		case 38: return deserializeBoxTSModuleDeclaration(pos + 8);
		case 39: return deserializeBoxTSGlobalDeclaration(pos + 8);
		case 40: return deserializeBoxTSImportEqualsDeclaration(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for Declaration`);
	}
}
function deserializeVariableDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "VariableDeclaration",
		kind: deserializeVariableDeclarationKind(pos + 32),
		declarations: null,
		declare: deserializeBool(pos + 33),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.declarations = deserializeVecVariableDeclarator(pos + 8), parent = previousParent, node;
}
function deserializeVariableDeclarationKind(pos) {
	switch (uint8[pos]) {
		case 0: return "var";
		case 1: return "let";
		case 2: return "const";
		case 3: return "using";
		case 4: return "await using";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for VariableDeclarationKind`);
	}
}
function deserializeVariableDeclarator(pos) {
	let previousParent = parent, variableDeclarator = parent = {
		__proto__: NodeProto,
		type: "VariableDeclarator",
		id: null,
		init: null,
		definite: !1,
		start: deserializeU32(pos),
		end: deserializeU32(pos + 4),
		range: [deserializeU32(pos), deserializeU32(pos + 4)],
		parent: previousParent
	};
	variableDeclarator.id = deserializeBindingPattern(pos + 8);
	{
		parent = variableDeclarator.id;
		let typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 24);
		variableDeclarator.id.typeAnnotation = typeAnnotation, typeAnnotation !== null && (variableDeclarator.id.end = typeAnnotation.end, variableDeclarator.id.range[1] = typeAnnotation.end), parent = variableDeclarator, variableDeclarator.definite = deserializeBool(pos + 49);
	}
	return variableDeclarator.init = deserializeOptionExpression(pos + 32), parent = previousParent, variableDeclarator;
}
function deserializeEmptyStatement(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "EmptyStatement",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeExpressionStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ExpressionStatement",
		expression: null,
		directive: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeIfStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "IfStatement",
		test: null,
		consequent: null,
		alternate: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.test = deserializeExpression(pos + 8), node.consequent = deserializeStatement(pos + 24), node.alternate = deserializeOptionStatement(pos + 40), parent = previousParent, node;
}
function deserializeDoWhileStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "DoWhileStatement",
		body: null,
		test: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.body = deserializeStatement(pos + 8), node.test = deserializeExpression(pos + 24), parent = previousParent, node;
}
function deserializeWhileStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "WhileStatement",
		test: null,
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.test = deserializeExpression(pos + 8), node.body = deserializeStatement(pos + 24), parent = previousParent, node;
}
function deserializeForStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ForStatement",
		init: null,
		test: null,
		update: null,
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.init = deserializeOptionForStatementInit(pos + 8), node.test = deserializeOptionExpression(pos + 24), node.update = deserializeOptionExpression(pos + 40), node.body = deserializeStatement(pos + 56), parent = previousParent, node;
}
function deserializeForStatementInit(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNullLiteral(pos + 8);
		case 2: return deserializeBoxNumericLiteral(pos + 8);
		case 3: return deserializeBoxBigIntLiteral(pos + 8);
		case 4: return deserializeBoxRegExpLiteral(pos + 8);
		case 5: return deserializeBoxStringLiteral(pos + 8);
		case 6: return deserializeBoxTemplateLiteral(pos + 8);
		case 7: return deserializeBoxIdentifierReference(pos + 8);
		case 8: return deserializeBoxMetaProperty(pos + 8);
		case 9: return deserializeBoxSuper(pos + 8);
		case 10: return deserializeBoxArrayExpression(pos + 8);
		case 11: return deserializeBoxArrowFunctionExpression(pos + 8);
		case 12: return deserializeBoxAssignmentExpression(pos + 8);
		case 13: return deserializeBoxAwaitExpression(pos + 8);
		case 14: return deserializeBoxBinaryExpression(pos + 8);
		case 15: return deserializeBoxCallExpression(pos + 8);
		case 16: return deserializeBoxChainExpression(pos + 8);
		case 17: return deserializeBoxClass(pos + 8);
		case 18: return deserializeBoxConditionalExpression(pos + 8);
		case 19: return deserializeBoxFunction(pos + 8);
		case 20: return deserializeBoxImportExpression(pos + 8);
		case 21: return deserializeBoxLogicalExpression(pos + 8);
		case 22: return deserializeBoxNewExpression(pos + 8);
		case 23: return deserializeBoxObjectExpression(pos + 8);
		case 24: return deserializeBoxParenthesizedExpression(pos + 8);
		case 25: return deserializeBoxSequenceExpression(pos + 8);
		case 26: return deserializeBoxTaggedTemplateExpression(pos + 8);
		case 27: return deserializeBoxThisExpression(pos + 8);
		case 28: return deserializeBoxUnaryExpression(pos + 8);
		case 29: return deserializeBoxUpdateExpression(pos + 8);
		case 30: return deserializeBoxYieldExpression(pos + 8);
		case 31: return deserializeBoxPrivateInExpression(pos + 8);
		case 32: return deserializeBoxJSXElement(pos + 8);
		case 33: return deserializeBoxJSXFragment(pos + 8);
		case 34: return deserializeBoxTSAsExpression(pos + 8);
		case 35: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 36: return deserializeBoxTSTypeAssertion(pos + 8);
		case 37: return deserializeBoxTSNonNullExpression(pos + 8);
		case 38: return deserializeBoxTSInstantiationExpression(pos + 8);
		case 39: return deserializeBoxV8IntrinsicExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		case 64: return deserializeBoxVariableDeclaration(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ForStatementInit`);
	}
}
function deserializeForInStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ForInStatement",
		left: null,
		right: null,
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializeForStatementLeft(pos + 8), node.right = deserializeExpression(pos + 24), node.body = deserializeStatement(pos + 40), parent = previousParent, node;
}
function deserializeForStatementLeft(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierReference(pos + 8);
		case 1: return deserializeBoxTSAsExpression(pos + 8);
		case 2: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 3: return deserializeBoxTSNonNullExpression(pos + 8);
		case 4: return deserializeBoxTSTypeAssertion(pos + 8);
		case 8: return deserializeBoxArrayAssignmentTarget(pos + 8);
		case 9: return deserializeBoxObjectAssignmentTarget(pos + 8);
		case 16: return deserializeBoxVariableDeclaration(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ForStatementLeft`);
	}
}
function deserializeForOfStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ForOfStatement",
		await: deserializeBool(pos + 60),
		left: null,
		right: null,
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializeForStatementLeft(pos + 8), node.right = deserializeExpression(pos + 24), node.body = deserializeStatement(pos + 40), parent = previousParent, node;
}
function deserializeContinueStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ContinueStatement",
		label: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.label = deserializeOptionLabelIdentifier(pos + 8), parent = previousParent, node;
}
function deserializeBreakStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "BreakStatement",
		label: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.label = deserializeOptionLabelIdentifier(pos + 8), parent = previousParent, node;
}
function deserializeReturnStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ReturnStatement",
		argument: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeOptionExpression(pos + 8), parent = previousParent, node;
}
function deserializeWithStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "WithStatement",
		object: null,
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.object = deserializeExpression(pos + 8), node.body = deserializeStatement(pos + 24), parent = previousParent, node;
}
function deserializeSwitchStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "SwitchStatement",
		discriminant: null,
		cases: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.discriminant = deserializeExpression(pos + 8), node.cases = deserializeVecSwitchCase(pos + 24), parent = previousParent, node;
}
function deserializeSwitchCase(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "SwitchCase",
		test: null,
		consequent: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.test = deserializeOptionExpression(pos + 8), node.consequent = deserializeVecStatement(pos + 24), parent = previousParent, node;
}
function deserializeLabeledStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "LabeledStatement",
		label: null,
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.label = deserializeLabelIdentifier(pos + 8), node.body = deserializeStatement(pos + 32), parent = previousParent, node;
}
function deserializeThrowStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ThrowStatement",
		argument: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeTryStatement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TryStatement",
		block: null,
		handler: null,
		finalizer: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.block = deserializeBoxBlockStatement(pos + 8), node.handler = deserializeOptionBoxCatchClause(pos + 16), node.finalizer = deserializeOptionBoxBlockStatement(pos + 24), parent = previousParent, node;
}
function deserializeCatchClause(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "CatchClause",
		param: null,
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.param = deserializeOptionCatchParameter(pos + 8), node.body = deserializeBoxBlockStatement(pos + 40), parent = previousParent, node;
}
function deserializeCatchParameter(pos) {
	let previousParent = parent, pattern = deserializeBindingPattern(pos + 8);
	{
		parent = pattern;
		let typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 24);
		pattern.typeAnnotation = typeAnnotation, typeAnnotation !== null && (pattern.end = typeAnnotation.end, pattern.range[1] = typeAnnotation.end), parent = previousParent;
	}
	return pattern;
}
function deserializeDebuggerStatement(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "DebuggerStatement",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeBindingPattern(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBindingIdentifier(pos + 8);
		case 1: return deserializeBoxObjectPattern(pos + 8);
		case 2: return deserializeBoxArrayPattern(pos + 8);
		case 3: return deserializeBoxAssignmentPattern(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for BindingPattern`);
	}
}
function deserializeAssignmentPattern(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "AssignmentPattern",
		decorators: null,
		left: null,
		right: null,
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.left = deserializeBindingPattern(pos + 8), node.right = deserializeExpression(pos + 24), node.optional = !1, parent = previousParent, node;
}
function deserializeObjectPattern(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ObjectPattern",
		decorators: null,
		properties: null,
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, properties = deserializeVecBindingProperty(pos + 8), rest = deserializeOptionBoxBindingRestElement(pos + 32);
	return rest !== null && properties.push(rest), node.decorators = [], node.properties = properties, node.optional = !1, parent = previousParent, node;
}
function deserializeBindingProperty(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Property",
		kind: null,
		key: null,
		value: null,
		method: null,
		shorthand: deserializeBool(pos + 40),
		computed: deserializeBool(pos + 41),
		optional: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.kind = "init", node.key = deserializePropertyKey(pos + 8), node.value = deserializeBindingPattern(pos + 24), node.method = !1, node.optional = !1, parent = previousParent, node;
}
function deserializeArrayPattern(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ArrayPattern",
		decorators: null,
		elements: null,
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, elements = deserializeVecOptionBindingPattern(pos + 8), rest = deserializeOptionBoxBindingRestElement(pos + 32);
	return rest !== null && elements.push(rest), node.decorators = [], node.elements = elements, node.optional = !1, parent = previousParent, node;
}
function deserializeBindingRestElement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "RestElement",
		decorators: null,
		argument: null,
		optional: null,
		typeAnnotation: null,
		value: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.argument = deserializeBindingPattern(pos + 8), node.optional = !1, parent = previousParent, node;
}
function deserializeFunction(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: deserializeFunctionType(pos + 84),
		id: null,
		generator: deserializeBool(pos + 85),
		async: deserializeBool(pos + 86),
		declare: deserializeBool(pos + 87),
		typeParameters: null,
		params: null,
		returnType: null,
		body: null,
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, params = deserializeBoxFormalParameters(pos + 56);
	{
		let thisParam = deserializeOptionBoxTSThisParameter(pos + 48);
		thisParam !== null && params.unshift(thisParam);
	}
	return node.id = deserializeOptionBindingIdentifier(pos + 8), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 40), node.params = params, node.returnType = deserializeOptionBoxTSTypeAnnotation(pos + 64), node.body = deserializeOptionBoxFunctionBody(pos + 72), node.expression = !1, parent = previousParent, node;
}
function deserializeFunctionType(pos) {
	switch (uint8[pos]) {
		case 0: return "FunctionDeclaration";
		case 1: return "FunctionExpression";
		case 2: return "TSDeclareFunction";
		case 3: return "TSEmptyBodyFunctionExpression";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for FunctionType`);
	}
}
function deserializeFormalParameters(pos) {
	let params = deserializeVecFormalParameter(pos + 8);
	if (uint32[pos + 32 >> 2] !== 0 && uint32[pos + 36 >> 2] !== 0) {
		pos = uint32[pos + 32 >> 2];
		let start, end, previousParent = parent, rest = parent = {
			__proto__: NodeProto,
			type: "RestElement",
			decorators: [],
			argument: null,
			optional: !1,
			typeAnnotation: null,
			value: null,
			start: start = deserializeU32(pos + 8),
			end: end = deserializeU32(pos + 12),
			range: [start, end],
			parent: previousParent
		};
		rest.argument = deserializeBindingPattern(pos + 16), rest.typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 32), rest.typeAnnotation !== null && (end = rest.typeAnnotation.end, rest.end = end, rest.range[1] = end), params.push(rest), parent = previousParent;
	}
	return params;
}
function deserializeFormalParameter(pos) {
	let param, previousParent = parent, hasInitializer = uint32[pos + 56 >> 2] !== 0 && uint32[pos + 60 >> 2] !== 0;
	{
		let accessibility = deserializeOptionTSAccessibility(pos + 65), readonly = deserializeBool(pos + 66), override = deserializeBool(pos + 67);
		if (accessibility === null && !readonly && !override) {
			let optional = deserializeBool(pos + 64);
			if (hasInitializer) {
				let start, end;
				param = parent = {
					__proto__: NodeProto,
					type: "AssignmentPattern",
					decorators: null,
					left: null,
					right: null,
					optional,
					typeAnnotation: null,
					start: start = deserializeU32(pos),
					end: end = deserializeU32(pos + 4),
					range: [start, end],
					parent: previousParent
				}, param.decorators = deserializeVecDecorator(pos + 8), param.left = deserializeBindingPattern(pos + 32), param.left.decorators = [], param.left.optional = !1, parent = param.left;
				let leftTypeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 48);
				param.left.typeAnnotation = leftTypeAnnotation, leftTypeAnnotation !== null && (param.left.end = leftTypeAnnotation.end, param.left.range[1] = leftTypeAnnotation.end), parent = param, param.right = deserializeOptionBoxExpression(pos + 56);
			} else {
				param = deserializeBindingPattern(pos + 32), param.parent = previousParent, parent = param, param.decorators = deserializeVecDecorator(pos + 8), param.optional = optional;
				let typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 48);
				param.typeAnnotation = typeAnnotation, typeAnnotation === null ? optional && (param.end = deserializeU32(pos + 4), param.range[1] = deserializeU32(pos + 4)) : (param.end = typeAnnotation.end, param.range[1] = typeAnnotation.end), parent = previousParent;
			}
		} else {
			let start, end;
			if (param = parent = {
				__proto__: NodeProto,
				type: "TSParameterProperty",
				accessibility,
				decorators: null,
				override,
				parameter: null,
				readonly,
				static: !1,
				start: start = deserializeU32(pos),
				end: end = deserializeU32(pos + 4),
				range: [start, end],
				parent: previousParent
			}, param.decorators = deserializeVecDecorator(pos + 8), hasInitializer) {
				let pattern = deserializeBindingPattern(pos + 32), initializer = deserializeOptionBoxExpression(pos + 56), assignStart, assignEnd, assignParam = parent = {
					__proto__: NodeProto,
					type: "AssignmentPattern",
					decorators: [],
					left: null,
					right: null,
					optional: !1,
					typeAnnotation: null,
					start: assignStart = pattern.start,
					end: assignEnd = initializer.end,
					range: [assignStart, assignEnd],
					parent: param
				};
				assignParam.left = pattern, pattern.parent = assignParam, pattern.decorators = [], pattern.optional = !1, parent = pattern;
				let patternTypeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 48);
				pattern.typeAnnotation = patternTypeAnnotation, patternTypeAnnotation !== null && (pattern.end = patternTypeAnnotation.end, pattern.range[1] = patternTypeAnnotation.end), parent = assignParam, assignParam.right = initializer, initializer !== null && (initializer.parent = assignParam), param.parameter = assignParam;
			} else {
				param.parameter = deserializeBindingPattern(pos + 32), param.parameter.decorators = [];
				let paramOptional = deserializeBool(pos + 64);
				param.parameter.optional = paramOptional, parent = param.parameter;
				let paramTypeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 48);
				if (param.parameter.typeAnnotation = paramTypeAnnotation, paramTypeAnnotation !== null) param.parameter.end = paramTypeAnnotation.end, param.parameter.range[1] = paramTypeAnnotation.end;
				else if (paramOptional) {
					let paramEnd = deserializeU32(pos + 4);
					param.parameter.end = paramEnd, param.parameter.range[1] = paramEnd;
				}
				parent = param;
			}
		}
	}
	return parent = previousParent, param;
}
function deserializeFunctionBody(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "BlockStatement",
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, body = deserializeVecDirective(pos + 8);
	return body.push(...deserializeVecStatement(pos + 32)), node.body = body, parent = previousParent, node;
}
function deserializeArrowFunctionExpression(pos) {
	let expression = deserializeBool(pos + 44), start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ArrowFunctionExpression",
		expression,
		async: deserializeBool(pos + 45),
		typeParameters: null,
		params: null,
		returnType: null,
		body: null,
		id: null,
		generator: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, body = deserializeBoxFunctionBody(pos + 32);
	return expression === !0 && (body = body.body[0].expression, body.parent = parent), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 8), node.params = deserializeBoxFormalParameters(pos + 16), node.returnType = deserializeOptionBoxTSTypeAnnotation(pos + 24), node.body = body, node.generator = !1, parent = previousParent, node;
}
function deserializeYieldExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "YieldExpression",
		delegate: deserializeBool(pos + 24),
		argument: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeOptionExpression(pos + 8), parent = previousParent, node;
}
function deserializeClass(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: deserializeClassType(pos + 132),
		decorators: null,
		id: null,
		typeParameters: null,
		superClass: null,
		superTypeArguments: null,
		implements: null,
		body: null,
		abstract: deserializeBool(pos + 133),
		declare: deserializeBool(pos + 134),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = deserializeVecDecorator(pos + 8), node.id = deserializeOptionBindingIdentifier(pos + 32), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 64), node.superClass = deserializeOptionExpression(pos + 72), node.superTypeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 88), node.implements = deserializeVecTSClassImplements(pos + 96), node.body = deserializeBoxClassBody(pos + 120), parent = previousParent, node;
}
function deserializeClassType(pos) {
	switch (uint8[pos]) {
		case 0: return "ClassDeclaration";
		case 1: return "ClassExpression";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ClassType`);
	}
}
function deserializeClassBody(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ClassBody",
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.body = deserializeVecClassElement(pos + 8), parent = previousParent, node;
}
function deserializeClassElement(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxStaticBlock(pos + 8);
		case 1: return deserializeBoxMethodDefinition(pos + 8);
		case 2: return deserializeBoxPropertyDefinition(pos + 8);
		case 3: return deserializeBoxAccessorProperty(pos + 8);
		case 4: return deserializeBoxTSIndexSignature(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ClassElement`);
	}
}
function deserializeMethodDefinition(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: deserializeMethodDefinitionType(pos + 56),
		decorators: null,
		key: null,
		value: null,
		kind: deserializeMethodDefinitionKind(pos + 57),
		computed: deserializeBool(pos + 58),
		static: deserializeBool(pos + 59),
		override: deserializeBool(pos + 60),
		optional: deserializeBool(pos + 61),
		accessibility: deserializeOptionTSAccessibility(pos + 62),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = deserializeVecDecorator(pos + 8), node.key = deserializePropertyKey(pos + 32), node.value = deserializeBoxFunction(pos + 48), parent = previousParent, node;
}
function deserializeMethodDefinitionType(pos) {
	switch (uint8[pos]) {
		case 0: return "MethodDefinition";
		case 1: return "TSAbstractMethodDefinition";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for MethodDefinitionType`);
	}
}
function deserializePropertyDefinition(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: deserializePropertyDefinitionType(pos + 72),
		decorators: null,
		key: null,
		typeAnnotation: null,
		value: null,
		computed: deserializeBool(pos + 73),
		static: deserializeBool(pos + 74),
		declare: deserializeBool(pos + 75),
		override: deserializeBool(pos + 76),
		optional: deserializeBool(pos + 77),
		definite: deserializeBool(pos + 78),
		readonly: deserializeBool(pos + 79),
		accessibility: deserializeOptionTSAccessibility(pos + 80),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = deserializeVecDecorator(pos + 8), node.key = deserializePropertyKey(pos + 32), node.typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 48), node.value = deserializeOptionExpression(pos + 56), parent = previousParent, node;
}
function deserializePropertyDefinitionType(pos) {
	switch (uint8[pos]) {
		case 0: return "PropertyDefinition";
		case 1: return "TSAbstractPropertyDefinition";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for PropertyDefinitionType`);
	}
}
function deserializeMethodDefinitionKind(pos) {
	switch (uint8[pos]) {
		case 0: return "constructor";
		case 1: return "method";
		case 2: return "get";
		case 3: return "set";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for MethodDefinitionKind`);
	}
}
function deserializePrivateIdentifier(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "PrivateIdentifier",
		name: deserializeStr(pos + 8),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeStaticBlock(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "StaticBlock",
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.body = deserializeVecStatement(pos + 8), parent = previousParent, node;
}
function deserializeAccessorPropertyType(pos) {
	switch (uint8[pos]) {
		case 0: return "AccessorProperty";
		case 1: return "TSAbstractAccessorProperty";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for AccessorPropertyType`);
	}
}
function deserializeAccessorProperty(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: deserializeAccessorPropertyType(pos + 72),
		decorators: null,
		key: null,
		typeAnnotation: null,
		value: null,
		computed: deserializeBool(pos + 73),
		static: deserializeBool(pos + 74),
		override: deserializeBool(pos + 75),
		definite: deserializeBool(pos + 76),
		accessibility: deserializeOptionTSAccessibility(pos + 77),
		declare: null,
		optional: null,
		readonly: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = deserializeVecDecorator(pos + 8), node.key = deserializePropertyKey(pos + 32), node.typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 48), node.value = deserializeOptionExpression(pos + 56), node.declare = !1, node.optional = !1, node.readonly = !1, parent = previousParent, node;
}
function deserializeImportExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ImportExpression",
		source: null,
		options: null,
		phase: deserializeOptionImportPhase(pos + 40),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.source = deserializeExpression(pos + 8), node.options = deserializeOptionExpression(pos + 24), parent = previousParent, node;
}
function deserializeImportDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ImportDeclaration",
		specifiers: null,
		source: null,
		phase: deserializeOptionImportPhase(pos + 88),
		attributes: null,
		importKind: deserializeImportOrExportKind(pos + 89),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, specifiers = deserializeOptionVecImportDeclarationSpecifier(pos + 8);
	specifiers === null && (specifiers = []);
	let withClause = deserializeOptionBoxWithClause(pos + 80);
	return node.specifiers = specifiers, node.source = deserializeStringLiteral(pos + 32), node.attributes = withClause === null ? [] : withClause.attributes, parent = previousParent, node;
}
function deserializeImportPhase(pos) {
	switch (uint8[pos]) {
		case 0: return "source";
		case 1: return "defer";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ImportPhase`);
	}
}
function deserializeImportDeclarationSpecifier(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxImportSpecifier(pos + 8);
		case 1: return deserializeBoxImportDefaultSpecifier(pos + 8);
		case 2: return deserializeBoxImportNamespaceSpecifier(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ImportDeclarationSpecifier`);
	}
}
function deserializeImportSpecifier(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ImportSpecifier",
		imported: null,
		local: null,
		importKind: deserializeImportOrExportKind(pos + 96),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.imported = deserializeModuleExportName(pos + 8), node.local = deserializeBindingIdentifier(pos + 64), parent = previousParent, node;
}
function deserializeImportDefaultSpecifier(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ImportDefaultSpecifier",
		local: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.local = deserializeBindingIdentifier(pos + 8), parent = previousParent, node;
}
function deserializeImportNamespaceSpecifier(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ImportNamespaceSpecifier",
		local: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.local = deserializeBindingIdentifier(pos + 8), parent = previousParent, node;
}
function deserializeWithClause(pos) {
	return { attributes: deserializeVecImportAttribute(pos + 8) };
}
function deserializeImportAttribute(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ImportAttribute",
		key: null,
		value: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.key = deserializeImportAttributeKey(pos + 8), node.value = deserializeStringLiteral(pos + 64), parent = previousParent, node;
}
function deserializeImportAttributeKey(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeIdentifierName(pos + 8);
		case 1: return deserializeStringLiteral(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ImportAttributeKey`);
	}
}
function deserializeExportNamedDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ExportNamedDeclaration",
		declaration: null,
		specifiers: null,
		source: null,
		exportKind: deserializeImportOrExportKind(pos + 104),
		attributes: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, withClause = deserializeOptionBoxWithClause(pos + 96);
	return node.declaration = deserializeOptionDeclaration(pos + 8), node.specifiers = deserializeVecExportSpecifier(pos + 24), node.source = deserializeOptionStringLiteral(pos + 48), node.attributes = withClause === null ? [] : withClause.attributes, parent = previousParent, node;
}
function deserializeExportDefaultDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ExportDefaultDeclaration",
		declaration: null,
		exportKind: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.declaration = deserializeExportDefaultDeclarationKind(pos + 8), node.exportKind = "value", parent = previousParent, node;
}
function deserializeExportAllDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ExportAllDeclaration",
		exported: null,
		source: null,
		attributes: null,
		exportKind: deserializeImportOrExportKind(pos + 120),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, withClause = deserializeOptionBoxWithClause(pos + 112);
	return node.exported = deserializeOptionModuleExportName(pos + 8), node.source = deserializeStringLiteral(pos + 64), node.attributes = withClause === null ? [] : withClause.attributes, parent = previousParent, node;
}
function deserializeExportSpecifier(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "ExportSpecifier",
		local: null,
		exported: null,
		exportKind: deserializeImportOrExportKind(pos + 120),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.local = deserializeModuleExportName(pos + 8), node.exported = deserializeModuleExportName(pos + 64), parent = previousParent, node;
}
function deserializeExportDefaultDeclarationKind(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNullLiteral(pos + 8);
		case 2: return deserializeBoxNumericLiteral(pos + 8);
		case 3: return deserializeBoxBigIntLiteral(pos + 8);
		case 4: return deserializeBoxRegExpLiteral(pos + 8);
		case 5: return deserializeBoxStringLiteral(pos + 8);
		case 6: return deserializeBoxTemplateLiteral(pos + 8);
		case 7: return deserializeBoxIdentifierReference(pos + 8);
		case 8: return deserializeBoxMetaProperty(pos + 8);
		case 9: return deserializeBoxSuper(pos + 8);
		case 10: return deserializeBoxArrayExpression(pos + 8);
		case 11: return deserializeBoxArrowFunctionExpression(pos + 8);
		case 12: return deserializeBoxAssignmentExpression(pos + 8);
		case 13: return deserializeBoxAwaitExpression(pos + 8);
		case 14: return deserializeBoxBinaryExpression(pos + 8);
		case 15: return deserializeBoxCallExpression(pos + 8);
		case 16: return deserializeBoxChainExpression(pos + 8);
		case 17: return deserializeBoxClass(pos + 8);
		case 18: return deserializeBoxConditionalExpression(pos + 8);
		case 19: return deserializeBoxFunction(pos + 8);
		case 20: return deserializeBoxImportExpression(pos + 8);
		case 21: return deserializeBoxLogicalExpression(pos + 8);
		case 22: return deserializeBoxNewExpression(pos + 8);
		case 23: return deserializeBoxObjectExpression(pos + 8);
		case 24: return deserializeBoxParenthesizedExpression(pos + 8);
		case 25: return deserializeBoxSequenceExpression(pos + 8);
		case 26: return deserializeBoxTaggedTemplateExpression(pos + 8);
		case 27: return deserializeBoxThisExpression(pos + 8);
		case 28: return deserializeBoxUnaryExpression(pos + 8);
		case 29: return deserializeBoxUpdateExpression(pos + 8);
		case 30: return deserializeBoxYieldExpression(pos + 8);
		case 31: return deserializeBoxPrivateInExpression(pos + 8);
		case 32: return deserializeBoxJSXElement(pos + 8);
		case 33: return deserializeBoxJSXFragment(pos + 8);
		case 34: return deserializeBoxTSAsExpression(pos + 8);
		case 35: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 36: return deserializeBoxTSTypeAssertion(pos + 8);
		case 37: return deserializeBoxTSNonNullExpression(pos + 8);
		case 38: return deserializeBoxTSInstantiationExpression(pos + 8);
		case 39: return deserializeBoxV8IntrinsicExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		case 64: return deserializeBoxFunction(pos + 8);
		case 65: return deserializeBoxClass(pos + 8);
		case 66: return deserializeBoxTSInterfaceDeclaration(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ExportDefaultDeclarationKind`);
	}
}
function deserializeModuleExportName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeIdentifierName(pos + 8);
		case 1: return deserializeIdentifierReference(pos + 8);
		case 2: return deserializeStringLiteral(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ModuleExportName`);
	}
}
function deserializeV8IntrinsicExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "V8IntrinsicExpression",
		name: null,
		arguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.name = deserializeIdentifierName(pos + 8), node.arguments = deserializeVecArgument(pos + 32), parent = previousParent, node;
}
function deserializeBooleanLiteral(pos) {
	let value = deserializeBool(pos + 8), start = deserializeU32(pos), end = deserializeU32(pos + 4), previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Literal",
		value,
		raw: null,
		start,
		end,
		range: [start, end],
		parent
	};
	return node.raw = start === 0 && end === 0 ? null : value + "", parent = previousParent, node;
}
function deserializeNullLiteral(pos) {
	let start = deserializeU32(pos), end = deserializeU32(pos + 4), previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Literal",
		value: null,
		raw: null,
		start,
		end,
		range: [start, end],
		parent
	};
	return node.raw = start === 0 && end === 0 ? null : "null", parent = previousParent, node;
}
function deserializeNumericLiteral(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "Literal",
		value: deserializeF64(pos + 8),
		raw: deserializeOptionStr(pos + 16),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeStringLiteral(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Literal",
		value: null,
		raw: deserializeOptionStr(pos + 24),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, value = deserializeStr(pos + 8);
	return deserializeBool(pos + 40) && (value = value.replace(/\uFFFD(.{4})/g, (_, hex) => String.fromCodePoint(parseInt(hex, 16)))), node.value = value, parent = previousParent, node;
}
function deserializeBigIntLiteral(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Literal",
		value: null,
		raw: deserializeOptionStr(pos + 24),
		bigint: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, bigint = deserializeStr(pos + 8);
	return node.value = BigInt(bigint), node.bigint = bigint, parent = previousParent, node;
}
function deserializeRegExpLiteral(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Literal",
		value: null,
		raw: deserializeOptionStr(pos + 40),
		regex: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, regex = deserializeRegExp(pos + 8), value = null;
	try {
		value = new RegExp(regex.pattern, regex.flags);
	} catch {}
	return node.value = value, node.regex = regex, parent = previousParent, node;
}
function deserializeRegExp(pos) {
	return {
		pattern: deserializeStr(pos),
		flags: deserializeRegExpFlags(pos + 24)
	};
}
function deserializeRegExpFlags(pos) {
	let flagBits = deserializeU8(pos), flags = "";
	return flagBits & 64 && (flags += "d"), flagBits & 1 && (flags += "g"), flagBits & 2 && (flags += "i"), flagBits & 4 && (flags += "m"), flagBits & 8 && (flags += "s"), flagBits & 16 && (flags += "u"), flagBits & 128 && (flags += "v"), flagBits & 32 && (flags += "y"), flags;
}
function deserializeJSXElement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXElement",
		openingElement: null,
		children: null,
		closingElement: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, closingElement = deserializeOptionBoxJSXClosingElement(pos + 40), openingElement = deserializeBoxJSXOpeningElement(pos + 8);
	return closingElement === null && (openingElement.selfClosing = !0), node.openingElement = openingElement, node.children = deserializeVecJSXChild(pos + 16), node.closingElement = closingElement, parent = previousParent, node;
}
function deserializeJSXOpeningElement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXOpeningElement",
		name: null,
		typeArguments: null,
		attributes: null,
		selfClosing: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.name = deserializeJSXElementName(pos + 8), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), node.attributes = deserializeVecJSXAttributeItem(pos + 32), node.selfClosing = !1, parent = previousParent, node;
}
function deserializeJSXClosingElement(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXClosingElement",
		name: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.name = deserializeJSXElementName(pos + 8), parent = previousParent, node;
}
function deserializeJSXFragment(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXFragment",
		openingFragment: null,
		children: null,
		closingFragment: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.openingFragment = deserializeJSXOpeningFragment(pos + 8), node.children = deserializeVecJSXChild(pos + 16), node.closingFragment = deserializeJSXClosingFragment(pos + 40), parent = previousParent, node;
}
function deserializeJSXOpeningFragment(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXOpeningFragment",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return parent = previousParent, node;
}
function deserializeJSXClosingFragment(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "JSXClosingFragment",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeJSXElementName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxJSXIdentifier(pos + 8);
		case 1:
			let ident = deserializeBoxIdentifierReference(pos + 8);
			return {
				__proto__: NodeProto,
				type: "JSXIdentifier",
				name: ident.name,
				start: ident.start,
				end: ident.end,
				range: ident.range,
				parent
			};
		case 2: return deserializeBoxJSXNamespacedName(pos + 8);
		case 3: return deserializeBoxJSXMemberExpression(pos + 8);
		case 4:
			let thisExpr = deserializeBoxThisExpression(pos + 8);
			return {
				__proto__: NodeProto,
				type: "JSXIdentifier",
				name: "this",
				start: thisExpr.start,
				end: thisExpr.end,
				range: thisExpr.range,
				parent
			};
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for JSXElementName`);
	}
}
function deserializeJSXNamespacedName(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXNamespacedName",
		namespace: null,
		name: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.namespace = deserializeJSXIdentifier(pos + 8), node.name = deserializeJSXIdentifier(pos + 32), parent = previousParent, node;
}
function deserializeJSXMemberExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXMemberExpression",
		object: null,
		property: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.object = deserializeJSXMemberExpressionObject(pos + 8), node.property = deserializeJSXIdentifier(pos + 24), parent = previousParent, node;
}
function deserializeJSXMemberExpressionObject(pos) {
	switch (uint8[pos]) {
		case 0:
			let ident = deserializeBoxIdentifierReference(pos + 8);
			return {
				__proto__: NodeProto,
				type: "JSXIdentifier",
				name: ident.name,
				start: ident.start,
				end: ident.end,
				range: ident.range,
				parent
			};
		case 1: return deserializeBoxJSXMemberExpression(pos + 8);
		case 2:
			let thisExpr = deserializeBoxThisExpression(pos + 8);
			return {
				__proto__: NodeProto,
				type: "JSXIdentifier",
				name: "this",
				start: thisExpr.start,
				end: thisExpr.end,
				range: thisExpr.range,
				parent
			};
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for JSXMemberExpressionObject`);
	}
}
function deserializeJSXExpressionContainer(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXExpressionContainer",
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeJSXExpression(pos + 8), parent = previousParent, node;
}
function deserializeJSXExpression(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNullLiteral(pos + 8);
		case 2: return deserializeBoxNumericLiteral(pos + 8);
		case 3: return deserializeBoxBigIntLiteral(pos + 8);
		case 4: return deserializeBoxRegExpLiteral(pos + 8);
		case 5: return deserializeBoxStringLiteral(pos + 8);
		case 6: return deserializeBoxTemplateLiteral(pos + 8);
		case 7: return deserializeBoxIdentifierReference(pos + 8);
		case 8: return deserializeBoxMetaProperty(pos + 8);
		case 9: return deserializeBoxSuper(pos + 8);
		case 10: return deserializeBoxArrayExpression(pos + 8);
		case 11: return deserializeBoxArrowFunctionExpression(pos + 8);
		case 12: return deserializeBoxAssignmentExpression(pos + 8);
		case 13: return deserializeBoxAwaitExpression(pos + 8);
		case 14: return deserializeBoxBinaryExpression(pos + 8);
		case 15: return deserializeBoxCallExpression(pos + 8);
		case 16: return deserializeBoxChainExpression(pos + 8);
		case 17: return deserializeBoxClass(pos + 8);
		case 18: return deserializeBoxConditionalExpression(pos + 8);
		case 19: return deserializeBoxFunction(pos + 8);
		case 20: return deserializeBoxImportExpression(pos + 8);
		case 21: return deserializeBoxLogicalExpression(pos + 8);
		case 22: return deserializeBoxNewExpression(pos + 8);
		case 23: return deserializeBoxObjectExpression(pos + 8);
		case 24: return deserializeBoxParenthesizedExpression(pos + 8);
		case 25: return deserializeBoxSequenceExpression(pos + 8);
		case 26: return deserializeBoxTaggedTemplateExpression(pos + 8);
		case 27: return deserializeBoxThisExpression(pos + 8);
		case 28: return deserializeBoxUnaryExpression(pos + 8);
		case 29: return deserializeBoxUpdateExpression(pos + 8);
		case 30: return deserializeBoxYieldExpression(pos + 8);
		case 31: return deserializeBoxPrivateInExpression(pos + 8);
		case 32: return deserializeBoxJSXElement(pos + 8);
		case 33: return deserializeBoxJSXFragment(pos + 8);
		case 34: return deserializeBoxTSAsExpression(pos + 8);
		case 35: return deserializeBoxTSSatisfiesExpression(pos + 8);
		case 36: return deserializeBoxTSTypeAssertion(pos + 8);
		case 37: return deserializeBoxTSNonNullExpression(pos + 8);
		case 38: return deserializeBoxTSInstantiationExpression(pos + 8);
		case 39: return deserializeBoxV8IntrinsicExpression(pos + 8);
		case 48: return deserializeBoxComputedMemberExpression(pos + 8);
		case 49: return deserializeBoxStaticMemberExpression(pos + 8);
		case 50: return deserializeBoxPrivateFieldExpression(pos + 8);
		case 64: return deserializeJSXEmptyExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for JSXExpression`);
	}
}
function deserializeJSXEmptyExpression(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "JSXEmptyExpression",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeJSXAttributeItem(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxJSXAttribute(pos + 8);
		case 1: return deserializeBoxJSXSpreadAttribute(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for JSXAttributeItem`);
	}
}
function deserializeJSXAttribute(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXAttribute",
		name: null,
		value: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.name = deserializeJSXAttributeName(pos + 8), node.value = deserializeOptionJSXAttributeValue(pos + 24), parent = previousParent, node;
}
function deserializeJSXSpreadAttribute(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXSpreadAttribute",
		argument: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.argument = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeJSXAttributeName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxJSXIdentifier(pos + 8);
		case 1: return deserializeBoxJSXNamespacedName(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for JSXAttributeName`);
	}
}
function deserializeJSXAttributeValue(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxStringLiteral(pos + 8);
		case 1: return deserializeBoxJSXExpressionContainer(pos + 8);
		case 2: return deserializeBoxJSXElement(pos + 8);
		case 3: return deserializeBoxJSXFragment(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for JSXAttributeValue`);
	}
}
function deserializeJSXIdentifier(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "JSXIdentifier",
		name: deserializeStr(pos + 8),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeJSXChild(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxJSXText(pos + 8);
		case 1: return deserializeBoxJSXElement(pos + 8);
		case 2: return deserializeBoxJSXFragment(pos + 8);
		case 3: return deserializeBoxJSXExpressionContainer(pos + 8);
		case 4: return deserializeBoxJSXSpreadChild(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for JSXChild`);
	}
}
function deserializeJSXSpreadChild(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "JSXSpreadChild",
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeJSXText(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "JSXText",
		value: deserializeStr(pos + 8),
		raw: deserializeOptionStr(pos + 24),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSThisParameter(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: null,
		name: null,
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.name = "this", node.optional = !1, node.typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 16), parent = previousParent, node;
}
function deserializeTSEnumDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSEnumDeclaration",
		id: null,
		body: null,
		const: deserializeBool(pos + 80),
		declare: deserializeBool(pos + 81),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.id = deserializeBindingIdentifier(pos + 8), node.body = deserializeTSEnumBody(pos + 40), parent = previousParent, node;
}
function deserializeTSEnumBody(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSEnumBody",
		members: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.members = deserializeVecTSEnumMember(pos + 8), parent = previousParent, node;
}
function deserializeTSEnumMember(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSEnumMember",
		id: null,
		initializer: null,
		computed: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.id = deserializeTSEnumMemberName(pos + 8), node.initializer = deserializeOptionExpression(pos + 24), node.computed = deserializeU8(pos + 8) > 1, parent = previousParent, node;
}
function deserializeTSEnumMemberName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierName(pos + 8);
		case 1: return deserializeBoxStringLiteral(pos + 8);
		case 2: return deserializeBoxStringLiteral(pos + 8);
		case 3: return deserializeBoxTemplateLiteral(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSEnumMemberName`);
	}
}
function deserializeTSTypeAnnotation(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeAnnotation",
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeAnnotation = deserializeTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSLiteralType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSLiteralType",
		literal: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.literal = deserializeTSLiteral(pos + 8), parent = previousParent, node;
}
function deserializeTSLiteral(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxBooleanLiteral(pos + 8);
		case 1: return deserializeBoxNumericLiteral(pos + 8);
		case 2: return deserializeBoxBigIntLiteral(pos + 8);
		case 3: return deserializeBoxStringLiteral(pos + 8);
		case 4: return deserializeBoxTemplateLiteral(pos + 8);
		case 5: return deserializeBoxUnaryExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSLiteral`);
	}
}
function deserializeTSType(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxTSAnyKeyword(pos + 8);
		case 1: return deserializeBoxTSBigIntKeyword(pos + 8);
		case 2: return deserializeBoxTSBooleanKeyword(pos + 8);
		case 3: return deserializeBoxTSIntrinsicKeyword(pos + 8);
		case 4: return deserializeBoxTSNeverKeyword(pos + 8);
		case 5: return deserializeBoxTSNullKeyword(pos + 8);
		case 6: return deserializeBoxTSNumberKeyword(pos + 8);
		case 7: return deserializeBoxTSObjectKeyword(pos + 8);
		case 8: return deserializeBoxTSStringKeyword(pos + 8);
		case 9: return deserializeBoxTSSymbolKeyword(pos + 8);
		case 10: return deserializeBoxTSThisType(pos + 8);
		case 11: return deserializeBoxTSUndefinedKeyword(pos + 8);
		case 12: return deserializeBoxTSUnknownKeyword(pos + 8);
		case 13: return deserializeBoxTSVoidKeyword(pos + 8);
		case 14: return deserializeBoxTSArrayType(pos + 8);
		case 15: return deserializeBoxTSConditionalType(pos + 8);
		case 16: return deserializeBoxTSConstructorType(pos + 8);
		case 17: return deserializeBoxTSFunctionType(pos + 8);
		case 18: return deserializeBoxTSImportType(pos + 8);
		case 19: return deserializeBoxTSIndexedAccessType(pos + 8);
		case 20: return deserializeBoxTSInferType(pos + 8);
		case 21: return deserializeBoxTSIntersectionType(pos + 8);
		case 22: return deserializeBoxTSLiteralType(pos + 8);
		case 23: return deserializeBoxTSMappedType(pos + 8);
		case 24: return deserializeBoxTSNamedTupleMember(pos + 8);
		case 26: return deserializeBoxTSTemplateLiteralType(pos + 8);
		case 27: return deserializeBoxTSTupleType(pos + 8);
		case 28: return deserializeBoxTSTypeLiteral(pos + 8);
		case 29: return deserializeBoxTSTypeOperator(pos + 8);
		case 30: return deserializeBoxTSTypePredicate(pos + 8);
		case 31: return deserializeBoxTSTypeQuery(pos + 8);
		case 32: return deserializeBoxTSTypeReference(pos + 8);
		case 33: return deserializeBoxTSUnionType(pos + 8);
		case 34: return deserializeBoxTSParenthesizedType(pos + 8);
		case 35: return deserializeBoxJSDocNullableType(pos + 8);
		case 36: return deserializeBoxJSDocNonNullableType(pos + 8);
		case 37: return deserializeBoxJSDocUnknownType(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSType`);
	}
}
function deserializeTSConditionalType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSConditionalType",
		checkType: null,
		extendsType: null,
		trueType: null,
		falseType: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.checkType = deserializeTSType(pos + 8), node.extendsType = deserializeTSType(pos + 24), node.trueType = deserializeTSType(pos + 40), node.falseType = deserializeTSType(pos + 56), parent = previousParent, node;
}
function deserializeTSUnionType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSUnionType",
		types: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.types = deserializeVecTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSIntersectionType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSIntersectionType",
		types: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.types = deserializeVecTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSParenthesizedType(pos) {
	let node;
	return node = deserializeTSType(pos + 8), node;
}
function deserializeTSTypeOperator(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeOperator",
		operator: deserializeTSTypeOperatorOperator(pos + 24),
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeAnnotation = deserializeTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSTypeOperatorOperator(pos) {
	switch (uint8[pos]) {
		case 0: return "keyof";
		case 1: return "unique";
		case 2: return "readonly";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSTypeOperatorOperator`);
	}
}
function deserializeTSArrayType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSArrayType",
		elementType: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.elementType = deserializeTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSIndexedAccessType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSIndexedAccessType",
		objectType: null,
		indexType: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.objectType = deserializeTSType(pos + 8), node.indexType = deserializeTSType(pos + 24), parent = previousParent, node;
}
function deserializeTSTupleType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTupleType",
		elementTypes: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.elementTypes = deserializeVecTSTupleElement(pos + 8), parent = previousParent, node;
}
function deserializeTSNamedTupleMember(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSNamedTupleMember",
		label: null,
		elementType: null,
		optional: deserializeBool(pos + 48),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.label = deserializeIdentifierName(pos + 8), node.elementType = deserializeTSTupleElement(pos + 32), parent = previousParent, node;
}
function deserializeTSOptionalType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSOptionalType",
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeAnnotation = deserializeTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSRestType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSRestType",
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeAnnotation = deserializeTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSTupleElement(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxTSAnyKeyword(pos + 8);
		case 1: return deserializeBoxTSBigIntKeyword(pos + 8);
		case 2: return deserializeBoxTSBooleanKeyword(pos + 8);
		case 3: return deserializeBoxTSIntrinsicKeyword(pos + 8);
		case 4: return deserializeBoxTSNeverKeyword(pos + 8);
		case 5: return deserializeBoxTSNullKeyword(pos + 8);
		case 6: return deserializeBoxTSNumberKeyword(pos + 8);
		case 7: return deserializeBoxTSObjectKeyword(pos + 8);
		case 8: return deserializeBoxTSStringKeyword(pos + 8);
		case 9: return deserializeBoxTSSymbolKeyword(pos + 8);
		case 10: return deserializeBoxTSThisType(pos + 8);
		case 11: return deserializeBoxTSUndefinedKeyword(pos + 8);
		case 12: return deserializeBoxTSUnknownKeyword(pos + 8);
		case 13: return deserializeBoxTSVoidKeyword(pos + 8);
		case 14: return deserializeBoxTSArrayType(pos + 8);
		case 15: return deserializeBoxTSConditionalType(pos + 8);
		case 16: return deserializeBoxTSConstructorType(pos + 8);
		case 17: return deserializeBoxTSFunctionType(pos + 8);
		case 18: return deserializeBoxTSImportType(pos + 8);
		case 19: return deserializeBoxTSIndexedAccessType(pos + 8);
		case 20: return deserializeBoxTSInferType(pos + 8);
		case 21: return deserializeBoxTSIntersectionType(pos + 8);
		case 22: return deserializeBoxTSLiteralType(pos + 8);
		case 23: return deserializeBoxTSMappedType(pos + 8);
		case 24: return deserializeBoxTSNamedTupleMember(pos + 8);
		case 26: return deserializeBoxTSTemplateLiteralType(pos + 8);
		case 27: return deserializeBoxTSTupleType(pos + 8);
		case 28: return deserializeBoxTSTypeLiteral(pos + 8);
		case 29: return deserializeBoxTSTypeOperator(pos + 8);
		case 30: return deserializeBoxTSTypePredicate(pos + 8);
		case 31: return deserializeBoxTSTypeQuery(pos + 8);
		case 32: return deserializeBoxTSTypeReference(pos + 8);
		case 33: return deserializeBoxTSUnionType(pos + 8);
		case 34: return deserializeBoxTSParenthesizedType(pos + 8);
		case 35: return deserializeBoxJSDocNullableType(pos + 8);
		case 36: return deserializeBoxJSDocNonNullableType(pos + 8);
		case 37: return deserializeBoxJSDocUnknownType(pos + 8);
		case 64: return deserializeBoxTSOptionalType(pos + 8);
		case 65: return deserializeBoxTSRestType(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSTupleElement`);
	}
}
function deserializeTSAnyKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSAnyKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSStringKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSStringKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSBooleanKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSBooleanKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSNumberKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSNumberKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSNeverKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSNeverKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSIntrinsicKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSIntrinsicKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSUnknownKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSUnknownKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSNullKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSNullKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSUndefinedKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSUndefinedKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSVoidKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSVoidKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSSymbolKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSSymbolKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSThisType(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSThisType",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSObjectKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSObjectKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSBigIntKeyword(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSBigIntKeyword",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeTSTypeReference(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeReference",
		typeName: null,
		typeArguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeName = deserializeTSTypeName(pos + 8), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), parent = previousParent, node;
}
function deserializeTSTypeName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierReference(pos + 8);
		case 1: return deserializeBoxTSQualifiedName(pos + 8);
		case 2: return deserializeBoxThisExpression(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSTypeName`);
	}
}
function deserializeTSQualifiedName(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSQualifiedName",
		left: null,
		right: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializeTSTypeName(pos + 8), node.right = deserializeIdentifierName(pos + 24), parent = previousParent, node;
}
function deserializeTSTypeParameterInstantiation(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeParameterInstantiation",
		params: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.params = deserializeVecTSType(pos + 8), parent = previousParent, node;
}
function deserializeTSTypeParameter(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeParameter",
		name: null,
		constraint: null,
		default: null,
		in: deserializeBool(pos + 72),
		out: deserializeBool(pos + 73),
		const: deserializeBool(pos + 74),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.name = deserializeBindingIdentifier(pos + 8), node.constraint = deserializeOptionTSType(pos + 40), node.default = deserializeOptionTSType(pos + 56), parent = previousParent, node;
}
function deserializeTSTypeParameterDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeParameterDeclaration",
		params: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.params = deserializeVecTSTypeParameter(pos + 8), parent = previousParent, node;
}
function deserializeTSTypeAliasDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeAliasDeclaration",
		id: null,
		typeParameters: null,
		typeAnnotation: null,
		declare: deserializeBool(pos + 68),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.id = deserializeBindingIdentifier(pos + 8), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 40), node.typeAnnotation = deserializeTSType(pos + 48), parent = previousParent, node;
}
function deserializeTSAccessibility(pos) {
	switch (uint8[pos]) {
		case 0: return "private";
		case 1: return "protected";
		case 2: return "public";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSAccessibility`);
	}
}
function deserializeTSClassImplements(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSClassImplements",
		expression: null,
		typeArguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, expression = deserializeTSTypeName(pos + 8);
	if (expression.type === "TSQualifiedName") {
		let object = expression.left, { right } = expression, start, end, previous = expression = {
			__proto__: NodeProto,
			type: "MemberExpression",
			object,
			property: right,
			optional: !1,
			computed: !1,
			start: start = expression.start,
			end: end = expression.end,
			range: [start, end],
			parent
		};
		for (right.parent = previous;;) {
			if (object.type !== "TSQualifiedName") {
				object.parent = previous;
				break;
			}
			let { left, right } = object;
			previous = previous.object = {
				__proto__: NodeProto,
				type: "MemberExpression",
				object: left,
				property: right,
				optional: !1,
				computed: !1,
				start: start = object.start,
				end: end = object.end,
				range: [start, end],
				parent: previous
			}, right.parent = previous, object = left;
		}
	}
	return node.expression = expression, node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), parent = previousParent, node;
}
function deserializeTSInterfaceDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSInterfaceDeclaration",
		id: null,
		typeParameters: null,
		extends: null,
		body: null,
		declare: deserializeBool(pos + 84),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.id = deserializeBindingIdentifier(pos + 8), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 40), node.extends = deserializeVecTSInterfaceHeritage(pos + 48), node.body = deserializeBoxTSInterfaceBody(pos + 72), parent = previousParent, node;
}
function deserializeTSInterfaceBody(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSInterfaceBody",
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.body = deserializeVecTSSignature(pos + 8), parent = previousParent, node;
}
function deserializeTSPropertySignature(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSPropertySignature",
		computed: deserializeBool(pos + 32),
		optional: deserializeBool(pos + 33),
		readonly: deserializeBool(pos + 34),
		key: null,
		typeAnnotation: null,
		accessibility: null,
		static: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.key = deserializePropertyKey(pos + 8), node.typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 24), node.static = !1, parent = previousParent, node;
}
function deserializeTSSignature(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxTSIndexSignature(pos + 8);
		case 1: return deserializeBoxTSPropertySignature(pos + 8);
		case 2: return deserializeBoxTSCallSignatureDeclaration(pos + 8);
		case 3: return deserializeBoxTSConstructSignatureDeclaration(pos + 8);
		case 4: return deserializeBoxTSMethodSignature(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSSignature`);
	}
}
function deserializeTSIndexSignature(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSIndexSignature",
		parameters: null,
		typeAnnotation: null,
		readonly: deserializeBool(pos + 40),
		static: deserializeBool(pos + 41),
		accessibility: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.parameters = deserializeVecTSIndexSignatureName(pos + 8), node.typeAnnotation = deserializeBoxTSTypeAnnotation(pos + 32), parent = previousParent, node;
}
function deserializeTSCallSignatureDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSCallSignatureDeclaration",
		typeParameters: null,
		params: null,
		returnType: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, params = deserializeBoxFormalParameters(pos + 24), thisParam = deserializeOptionBoxTSThisParameter(pos + 16);
	return thisParam !== null && params.unshift(thisParam), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 8), node.params = params, node.returnType = deserializeOptionBoxTSTypeAnnotation(pos + 32), parent = previousParent, node;
}
function deserializeTSMethodSignatureKind(pos) {
	switch (uint8[pos]) {
		case 0: return "method";
		case 1: return "get";
		case 2: return "set";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSMethodSignatureKind`);
	}
}
function deserializeTSMethodSignature(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSMethodSignature",
		key: null,
		computed: deserializeBool(pos + 60),
		optional: deserializeBool(pos + 61),
		kind: deserializeTSMethodSignatureKind(pos + 62),
		typeParameters: null,
		params: null,
		returnType: null,
		accessibility: null,
		readonly: null,
		static: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, params = deserializeBoxFormalParameters(pos + 40), thisParam = deserializeOptionBoxTSThisParameter(pos + 32);
	return thisParam !== null && params.unshift(thisParam), node.key = deserializePropertyKey(pos + 8), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 24), node.params = params, node.returnType = deserializeOptionBoxTSTypeAnnotation(pos + 48), node.readonly = !1, node.static = !1, parent = previousParent, node;
}
function deserializeTSConstructSignatureDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSConstructSignatureDeclaration",
		typeParameters: null,
		params: null,
		returnType: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 8), node.params = deserializeBoxFormalParameters(pos + 16), node.returnType = deserializeOptionBoxTSTypeAnnotation(pos + 24), parent = previousParent, node;
}
function deserializeTSIndexSignatureName(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: null,
		name: deserializeStr(pos + 8),
		optional: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.decorators = [], node.optional = !1, node.typeAnnotation = deserializeBoxTSTypeAnnotation(pos + 24), parent = previousParent, node;
}
function deserializeTSInterfaceHeritage(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSInterfaceHeritage",
		expression: null,
		typeArguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), parent = previousParent, node;
}
function deserializeTSTypePredicate(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypePredicate",
		parameterName: null,
		asserts: deserializeBool(pos + 32),
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.parameterName = deserializeTSTypePredicateName(pos + 8), node.typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 24), parent = previousParent, node;
}
function deserializeTSTypePredicateName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierName(pos + 8);
		case 1: return deserializeTSThisType(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSTypePredicateName`);
	}
}
function deserializeTSModuleDeclaration(pos) {
	let kind = deserializeTSModuleDeclarationKind(pos + 84), start = deserializeU32(pos), end = deserializeU32(pos + 4), declare = deserializeBool(pos + 85), node, previousParent = parent, body = deserializeOptionTSModuleDeclarationBody(pos + 64);
	if (body === null) node = parent = {
		__proto__: NodeProto,
		type: "TSModuleDeclaration",
		id: null,
		kind,
		declare,
		global: !1,
		start,
		end,
		range: [start, end],
		parent
	}, node.id = deserializeTSModuleDeclarationName(pos + 8);
	else {
		node = parent = {
			__proto__: NodeProto,
			type: "TSModuleDeclaration",
			id: null,
			body,
			kind,
			declare,
			global: !1,
			start,
			end,
			range: [start, end],
			parent
		};
		let id = deserializeTSModuleDeclarationName(pos + 8);
		if (body.type === "TSModuleBlock") node.id = id, body.parent = node;
		else {
			let innerId = body.id;
			if (innerId.type === "Identifier") {
				let start, end, outerId = node.id = parent = {
					__proto__: NodeProto,
					type: "TSQualifiedName",
					left: id,
					right: innerId,
					start: start = id.start,
					end: end = innerId.end,
					range: [start, end],
					parent: node
				};
				id.parent = innerId.parent = outerId;
			} else {
				node.id = innerId, innerId.parent = node;
				let { start } = id;
				for (; innerId.start = innerId.range[0] = start, innerId.left.type !== "Identifier";) innerId = innerId.left;
				let end, right = innerId.left;
				id.parent = right.parent = innerId.left = {
					__proto__: NodeProto,
					type: "TSQualifiedName",
					left: id,
					right,
					start,
					end: end = right.end,
					range: [start, end],
					parent: innerId
				};
			}
			Object.hasOwn(body, "body") ? (body = body.body, node.body = body, body.parent = node) : body = null;
		}
	}
	return parent = previousParent, node;
}
function deserializeTSModuleDeclarationKind(pos) {
	switch (uint8[pos]) {
		case 0: return "module";
		case 1: return "namespace";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSModuleDeclarationKind`);
	}
}
function deserializeTSModuleDeclarationName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBindingIdentifier(pos + 8);
		case 1: return deserializeStringLiteral(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSModuleDeclarationName`);
	}
}
function deserializeTSModuleDeclarationBody(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxTSModuleDeclaration(pos + 8);
		case 1: return deserializeBoxTSModuleBlock(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSModuleDeclarationBody`);
	}
}
function deserializeTSGlobalDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSModuleDeclaration",
		id: null,
		body: null,
		kind: null,
		declare: deserializeBool(pos + 76),
		global: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, keywordStart, keywordEnd;
	return node.id = {
		__proto__: NodeProto,
		type: "Identifier",
		decorators: [],
		name: "global",
		optional: !1,
		typeAnnotation: null,
		start: keywordStart = deserializeU32(pos + 8),
		end: keywordEnd = deserializeU32(pos + 12),
		range: [keywordStart, keywordEnd],
		parent
	}, node.body = deserializeTSModuleBlock(pos + 16), node.kind = "global", node.global = !0, parent = previousParent, node;
}
function deserializeTSModuleBlock(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSModuleBlock",
		body: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, body = deserializeVecDirective(pos + 8);
	return body.push(...deserializeVecStatement(pos + 32)), node.body = body, parent = previousParent, node;
}
function deserializeTSTypeLiteral(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeLiteral",
		members: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.members = deserializeVecTSSignature(pos + 8), parent = previousParent, node;
}
function deserializeTSInferType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSInferType",
		typeParameter: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeParameter = deserializeBoxTSTypeParameter(pos + 8), parent = previousParent, node;
}
function deserializeTSTypeQuery(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeQuery",
		exprName: null,
		typeArguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.exprName = deserializeTSTypeQueryExprName(pos + 8), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 24), parent = previousParent, node;
}
function deserializeTSTypeQueryExprName(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierReference(pos + 8);
		case 1: return deserializeBoxTSQualifiedName(pos + 8);
		case 2: return deserializeBoxThisExpression(pos + 8);
		case 3: return deserializeBoxTSImportType(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSTypeQueryExprName`);
	}
}
function deserializeTSImportType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSImportType",
		source: null,
		options: null,
		qualifier: null,
		typeArguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.source = deserializeStringLiteral(pos + 8), node.options = deserializeOptionBoxObjectExpression(pos + 56), node.qualifier = deserializeOptionTSImportTypeQualifier(pos + 64), node.typeArguments = deserializeOptionBoxTSTypeParameterInstantiation(pos + 80), parent = previousParent, node;
}
function deserializeTSImportTypeQualifier(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxIdentifierName(pos + 8);
		case 1: return deserializeBoxTSImportTypeQualifiedName(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSImportTypeQualifier`);
	}
}
function deserializeTSImportTypeQualifiedName(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSQualifiedName",
		left: null,
		right: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.left = deserializeTSImportTypeQualifier(pos + 8), node.right = deserializeIdentifierName(pos + 24), parent = previousParent, node;
}
function deserializeTSFunctionType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSFunctionType",
		typeParameters: null,
		params: null,
		returnType: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, params = deserializeBoxFormalParameters(pos + 24), thisParam = deserializeOptionBoxTSThisParameter(pos + 16);
	return thisParam !== null && params.unshift(thisParam), node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 8), node.params = params, node.returnType = deserializeBoxTSTypeAnnotation(pos + 32), parent = previousParent, node;
}
function deserializeTSConstructorType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSConstructorType",
		abstract: deserializeBool(pos + 36),
		typeParameters: null,
		params: null,
		returnType: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeParameters = deserializeOptionBoxTSTypeParameterDeclaration(pos + 8), node.params = deserializeBoxFormalParameters(pos + 16), node.returnType = deserializeBoxTSTypeAnnotation(pos + 24), parent = previousParent, node;
}
function deserializeTSMappedType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSMappedType",
		key: null,
		constraint: null,
		nameType: null,
		typeAnnotation: null,
		optional: null,
		readonly: deserializeOptionTSMappedTypeModifierOperator(pos + 93),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	}, optional = deserializeOptionTSMappedTypeModifierOperator(pos + 92);
	return optional === null && (optional = !1), node.key = deserializeBindingIdentifier(pos + 8), node.constraint = deserializeTSType(pos + 40), node.nameType = deserializeOptionTSType(pos + 56), node.typeAnnotation = deserializeOptionTSType(pos + 72), node.optional = optional, parent = previousParent, node;
}
function deserializeTSMappedTypeModifierOperator(pos) {
	switch (uint8[pos]) {
		case 0: return !0;
		case 1: return "+";
		case 2: return "-";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSMappedTypeModifierOperator`);
	}
}
function deserializeTSTemplateLiteralType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTemplateLiteralType",
		quasis: null,
		types: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.quasis = deserializeVecTemplateElement(pos + 8), node.types = deserializeVecTSType(pos + 32), parent = previousParent, node;
}
function deserializeTSAsExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSAsExpression",
		expression: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), node.typeAnnotation = deserializeTSType(pos + 24), parent = previousParent, node;
}
function deserializeTSSatisfiesExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSSatisfiesExpression",
		expression: null,
		typeAnnotation: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), node.typeAnnotation = deserializeTSType(pos + 24), parent = previousParent, node;
}
function deserializeTSTypeAssertion(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSTypeAssertion",
		typeAnnotation: null,
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeAnnotation = deserializeTSType(pos + 8), node.expression = deserializeExpression(pos + 24), parent = previousParent, node;
}
function deserializeTSImportEqualsDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSImportEqualsDeclaration",
		id: null,
		moduleReference: null,
		importKind: deserializeImportOrExportKind(pos + 56),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.id = deserializeBindingIdentifier(pos + 8), node.moduleReference = deserializeTSModuleReference(pos + 40), parent = previousParent, node;
}
function deserializeTSModuleReference(pos) {
	switch (uint8[pos]) {
		case 0: return deserializeBoxTSExternalModuleReference(pos + 8);
		case 1: return deserializeBoxIdentifierReference(pos + 8);
		case 2: return deserializeBoxTSQualifiedName(pos + 8);
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for TSModuleReference`);
	}
}
function deserializeTSExternalModuleReference(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSExternalModuleReference",
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeStringLiteral(pos + 8), parent = previousParent, node;
}
function deserializeTSNonNullExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSNonNullExpression",
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeDecorator(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "Decorator",
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeTSExportAssignment(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSExportAssignment",
		expression: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), parent = previousParent, node;
}
function deserializeTSNamespaceExportDeclaration(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSNamespaceExportDeclaration",
		id: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.id = deserializeIdentifierName(pos + 8), parent = previousParent, node;
}
function deserializeTSInstantiationExpression(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSInstantiationExpression",
		expression: null,
		typeArguments: null,
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.expression = deserializeExpression(pos + 8), node.typeArguments = deserializeBoxTSTypeParameterInstantiation(pos + 24), parent = previousParent, node;
}
function deserializeImportOrExportKind(pos) {
	switch (uint8[pos]) {
		case 0: return "value";
		case 1: return "type";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ImportOrExportKind`);
	}
}
function deserializeJSDocNullableType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSJSDocNullableType",
		typeAnnotation: null,
		postfix: deserializeBool(pos + 24),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeAnnotation = deserializeTSType(pos + 8), parent = previousParent, node;
}
function deserializeJSDocNonNullableType(pos) {
	let start, end, previousParent = parent, node = parent = {
		__proto__: NodeProto,
		type: "TSJSDocNonNullableType",
		typeAnnotation: null,
		postfix: deserializeBool(pos + 24),
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
	return node.typeAnnotation = deserializeTSType(pos + 8), parent = previousParent, node;
}
function deserializeJSDocUnknownType(pos) {
	let start, end;
	return {
		__proto__: NodeProto,
		type: "TSJSDocUnknownType",
		start: start = deserializeU32(pos),
		end: end = deserializeU32(pos + 4),
		range: [start, end],
		parent
	};
}
function deserializeCommentKind(pos) {
	switch (uint8[pos]) {
		case 0: return "Line";
		case 1: return "Block";
		case 2: return "Block";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for CommentKind`);
	}
}
function deserializeComment(pos) {
	let type = deserializeCommentKind(pos + 12), start = deserializeU32(pos), end = deserializeU32(pos + 4);
	return {
		__proto__: NodeProto,
		type,
		value: sourceText$1.slice(start + 2, end - (type === "Line" ? 0 : 2)),
		start,
		end,
		range: [start, end]
	};
}
function deserializeAssignmentOperator(pos) {
	switch (uint8[pos]) {
		case 0: return "=";
		case 1: return "+=";
		case 2: return "-=";
		case 3: return "*=";
		case 4: return "/=";
		case 5: return "%=";
		case 6: return "**=";
		case 7: return "<<=";
		case 8: return ">>=";
		case 9: return ">>>=";
		case 10: return "|=";
		case 11: return "^=";
		case 12: return "&=";
		case 13: return "||=";
		case 14: return "&&=";
		case 15: return "??=";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for AssignmentOperator`);
	}
}
function deserializeBinaryOperator(pos) {
	switch (uint8[pos]) {
		case 0: return "==";
		case 1: return "!=";
		case 2: return "===";
		case 3: return "!==";
		case 4: return "<";
		case 5: return "<=";
		case 6: return ">";
		case 7: return ">=";
		case 8: return "+";
		case 9: return "-";
		case 10: return "*";
		case 11: return "/";
		case 12: return "%";
		case 13: return "**";
		case 14: return "<<";
		case 15: return ">>";
		case 16: return ">>>";
		case 17: return "|";
		case 18: return "^";
		case 19: return "&";
		case 20: return "in";
		case 21: return "instanceof";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for BinaryOperator`);
	}
}
function deserializeLogicalOperator(pos) {
	switch (uint8[pos]) {
		case 0: return "||";
		case 1: return "&&";
		case 2: return "??";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for LogicalOperator`);
	}
}
function deserializeUnaryOperator(pos) {
	switch (uint8[pos]) {
		case 0: return "+";
		case 1: return "-";
		case 2: return "!";
		case 3: return "~";
		case 4: return "typeof";
		case 5: return "void";
		case 6: return "delete";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for UnaryOperator`);
	}
}
function deserializeUpdateOperator(pos) {
	switch (uint8[pos]) {
		case 0: return "++";
		case 1: return "--";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for UpdateOperator`);
	}
}
function deserializeModuleKind(pos) {
	switch (uint8[pos]) {
		case 0: return "script";
		case 1: return "module";
		case 3: return "commonjs";
		default: throw Error(`Unexpected discriminant ${uint8[pos]} for ModuleKind`);
	}
}
function deserializeU32(pos) {
	return uint32[pos >> 2];
}
function deserializeU8(pos) {
	return uint8[pos];
}
function deserializeStr(pos) {
	let pos32 = pos >> 2, len = uint32[pos32 + 2];
	if (len === 0) return "";
	if (pos = uint32[pos32], sourceIsAscii && pos < sourceEndPos) return sourceText$1.substr(pos - sourceStartPos$1, len);
	let end = pos + len;
	if (len > 50) return decodeStr(uint8.subarray(pos, end));
	let out = "", c;
	do
		if (c = uint8[pos++], c < 128) out += fromCodePoint(c);
		else {
			out += decodeStr(uint8.subarray(pos - 1, end));
			break;
		}
	while (pos < end);
	return out;
}
function deserializeVecComment(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeComment(pos)), pos += 16;
	return arr;
}
function deserializeOptionHashbang(pos) {
	return uint32[pos + 8 >> 2] === 0 && uint32[pos + 12 >> 2] === 0 ? null : deserializeHashbang(pos);
}
function deserializeVecDirective(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 72;
	for (; pos !== endPos;) arr.push(deserializeDirective(pos)), pos += 72;
	return arr;
}
function deserializeVecStatement(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeStatement(pos)), pos += 16;
	return arr;
}
function deserializeBoxBooleanLiteral(pos) {
	return deserializeBooleanLiteral(uint32[pos >> 2]);
}
function deserializeBoxNullLiteral(pos) {
	return deserializeNullLiteral(uint32[pos >> 2]);
}
function deserializeBoxNumericLiteral(pos) {
	return deserializeNumericLiteral(uint32[pos >> 2]);
}
function deserializeBoxBigIntLiteral(pos) {
	return deserializeBigIntLiteral(uint32[pos >> 2]);
}
function deserializeBoxRegExpLiteral(pos) {
	return deserializeRegExpLiteral(uint32[pos >> 2]);
}
function deserializeBoxStringLiteral(pos) {
	return deserializeStringLiteral(uint32[pos >> 2]);
}
function deserializeBoxTemplateLiteral(pos) {
	return deserializeTemplateLiteral(uint32[pos >> 2]);
}
function deserializeBoxIdentifierReference(pos) {
	return deserializeIdentifierReference(uint32[pos >> 2]);
}
function deserializeBoxMetaProperty(pos) {
	return deserializeMetaProperty(uint32[pos >> 2]);
}
function deserializeBoxSuper(pos) {
	return deserializeSuper(uint32[pos >> 2]);
}
function deserializeBoxArrayExpression(pos) {
	return deserializeArrayExpression(uint32[pos >> 2]);
}
function deserializeBoxArrowFunctionExpression(pos) {
	return deserializeArrowFunctionExpression(uint32[pos >> 2]);
}
function deserializeBoxAssignmentExpression(pos) {
	return deserializeAssignmentExpression(uint32[pos >> 2]);
}
function deserializeBoxAwaitExpression(pos) {
	return deserializeAwaitExpression(uint32[pos >> 2]);
}
function deserializeBoxBinaryExpression(pos) {
	return deserializeBinaryExpression(uint32[pos >> 2]);
}
function deserializeBoxCallExpression(pos) {
	return deserializeCallExpression(uint32[pos >> 2]);
}
function deserializeBoxChainExpression(pos) {
	return deserializeChainExpression(uint32[pos >> 2]);
}
function deserializeBoxClass(pos) {
	return deserializeClass(uint32[pos >> 2]);
}
function deserializeBoxConditionalExpression(pos) {
	return deserializeConditionalExpression(uint32[pos >> 2]);
}
function deserializeBoxFunction(pos) {
	return deserializeFunction(uint32[pos >> 2]);
}
function deserializeBoxImportExpression(pos) {
	return deserializeImportExpression(uint32[pos >> 2]);
}
function deserializeBoxLogicalExpression(pos) {
	return deserializeLogicalExpression(uint32[pos >> 2]);
}
function deserializeBoxNewExpression(pos) {
	return deserializeNewExpression(uint32[pos >> 2]);
}
function deserializeBoxObjectExpression(pos) {
	return deserializeObjectExpression(uint32[pos >> 2]);
}
function deserializeBoxParenthesizedExpression(pos) {
	return deserializeParenthesizedExpression(uint32[pos >> 2]);
}
function deserializeBoxSequenceExpression(pos) {
	return deserializeSequenceExpression(uint32[pos >> 2]);
}
function deserializeBoxTaggedTemplateExpression(pos) {
	return deserializeTaggedTemplateExpression(uint32[pos >> 2]);
}
function deserializeBoxThisExpression(pos) {
	return deserializeThisExpression(uint32[pos >> 2]);
}
function deserializeBoxUnaryExpression(pos) {
	return deserializeUnaryExpression(uint32[pos >> 2]);
}
function deserializeBoxUpdateExpression(pos) {
	return deserializeUpdateExpression(uint32[pos >> 2]);
}
function deserializeBoxYieldExpression(pos) {
	return deserializeYieldExpression(uint32[pos >> 2]);
}
function deserializeBoxPrivateInExpression(pos) {
	return deserializePrivateInExpression(uint32[pos >> 2]);
}
function deserializeBoxJSXElement(pos) {
	return deserializeJSXElement(uint32[pos >> 2]);
}
function deserializeBoxJSXFragment(pos) {
	return deserializeJSXFragment(uint32[pos >> 2]);
}
function deserializeBoxTSAsExpression(pos) {
	return deserializeTSAsExpression(uint32[pos >> 2]);
}
function deserializeBoxTSSatisfiesExpression(pos) {
	return deserializeTSSatisfiesExpression(uint32[pos >> 2]);
}
function deserializeBoxTSTypeAssertion(pos) {
	return deserializeTSTypeAssertion(uint32[pos >> 2]);
}
function deserializeBoxTSNonNullExpression(pos) {
	return deserializeTSNonNullExpression(uint32[pos >> 2]);
}
function deserializeBoxTSInstantiationExpression(pos) {
	return deserializeTSInstantiationExpression(uint32[pos >> 2]);
}
function deserializeBoxV8IntrinsicExpression(pos) {
	return deserializeV8IntrinsicExpression(uint32[pos >> 2]);
}
function deserializeVecArrayExpressionElement(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeArrayExpressionElement(pos)), pos += 16;
	return arr;
}
function deserializeBoxSpreadElement(pos) {
	return deserializeSpreadElement(uint32[pos >> 2]);
}
function deserializeVecObjectPropertyKind(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeObjectPropertyKind(pos)), pos += 16;
	return arr;
}
function deserializeBoxObjectProperty(pos) {
	return deserializeObjectProperty(uint32[pos >> 2]);
}
function deserializeBool(pos) {
	return uint8[pos] === 1;
}
function deserializeBoxIdentifierName(pos) {
	return deserializeIdentifierName(uint32[pos >> 2]);
}
function deserializeBoxPrivateIdentifier(pos) {
	return deserializePrivateIdentifier(uint32[pos >> 2]);
}
function deserializeVecTemplateElement(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 48;
	for (; pos !== endPos;) arr.push(deserializeTemplateElement(pos)), pos += 48;
	return arr;
}
function deserializeVecExpression(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeExpression(pos)), pos += 16;
	return arr;
}
function deserializeBoxTSTypeParameterInstantiation(pos) {
	return deserializeTSTypeParameterInstantiation(uint32[pos >> 2]);
}
function deserializeOptionBoxTSTypeParameterInstantiation(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxTSTypeParameterInstantiation(pos);
}
function deserializeOptionStr(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeStr(pos);
}
function deserializeBoxComputedMemberExpression(pos) {
	return deserializeComputedMemberExpression(uint32[pos >> 2]);
}
function deserializeBoxStaticMemberExpression(pos) {
	return deserializeStaticMemberExpression(uint32[pos >> 2]);
}
function deserializeBoxPrivateFieldExpression(pos) {
	return deserializePrivateFieldExpression(uint32[pos >> 2]);
}
function deserializeVecArgument(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeArgument(pos)), pos += 16;
	return arr;
}
function deserializeBoxArrayAssignmentTarget(pos) {
	return deserializeArrayAssignmentTarget(uint32[pos >> 2]);
}
function deserializeBoxObjectAssignmentTarget(pos) {
	return deserializeObjectAssignmentTarget(uint32[pos >> 2]);
}
function deserializeOptionAssignmentTargetMaybeDefault(pos) {
	return uint8[pos] === 51 ? null : deserializeAssignmentTargetMaybeDefault(pos);
}
function deserializeVecOptionAssignmentTargetMaybeDefault(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeOptionAssignmentTargetMaybeDefault(pos)), pos += 16;
	return arr;
}
function deserializeBoxAssignmentTargetRest(pos) {
	return deserializeAssignmentTargetRest(uint32[pos >> 2]);
}
function deserializeOptionBoxAssignmentTargetRest(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxAssignmentTargetRest(pos);
}
function deserializeVecAssignmentTargetProperty(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeAssignmentTargetProperty(pos)), pos += 16;
	return arr;
}
function deserializeBoxAssignmentTargetWithDefault(pos) {
	return deserializeAssignmentTargetWithDefault(uint32[pos >> 2]);
}
function deserializeBoxAssignmentTargetPropertyIdentifier(pos) {
	return deserializeAssignmentTargetPropertyIdentifier(uint32[pos >> 2]);
}
function deserializeBoxAssignmentTargetPropertyProperty(pos) {
	return deserializeAssignmentTargetPropertyProperty(uint32[pos >> 2]);
}
function deserializeOptionExpression(pos) {
	return uint8[pos] === 51 ? null : deserializeExpression(pos);
}
function deserializeBoxBlockStatement(pos) {
	return deserializeBlockStatement(uint32[pos >> 2]);
}
function deserializeBoxBreakStatement(pos) {
	return deserializeBreakStatement(uint32[pos >> 2]);
}
function deserializeBoxContinueStatement(pos) {
	return deserializeContinueStatement(uint32[pos >> 2]);
}
function deserializeBoxDebuggerStatement(pos) {
	return deserializeDebuggerStatement(uint32[pos >> 2]);
}
function deserializeBoxDoWhileStatement(pos) {
	return deserializeDoWhileStatement(uint32[pos >> 2]);
}
function deserializeBoxEmptyStatement(pos) {
	return deserializeEmptyStatement(uint32[pos >> 2]);
}
function deserializeBoxExpressionStatement(pos) {
	return deserializeExpressionStatement(uint32[pos >> 2]);
}
function deserializeBoxForInStatement(pos) {
	return deserializeForInStatement(uint32[pos >> 2]);
}
function deserializeBoxForOfStatement(pos) {
	return deserializeForOfStatement(uint32[pos >> 2]);
}
function deserializeBoxForStatement(pos) {
	return deserializeForStatement(uint32[pos >> 2]);
}
function deserializeBoxIfStatement(pos) {
	return deserializeIfStatement(uint32[pos >> 2]);
}
function deserializeBoxLabeledStatement(pos) {
	return deserializeLabeledStatement(uint32[pos >> 2]);
}
function deserializeBoxReturnStatement(pos) {
	return deserializeReturnStatement(uint32[pos >> 2]);
}
function deserializeBoxSwitchStatement(pos) {
	return deserializeSwitchStatement(uint32[pos >> 2]);
}
function deserializeBoxThrowStatement(pos) {
	return deserializeThrowStatement(uint32[pos >> 2]);
}
function deserializeBoxTryStatement(pos) {
	return deserializeTryStatement(uint32[pos >> 2]);
}
function deserializeBoxWhileStatement(pos) {
	return deserializeWhileStatement(uint32[pos >> 2]);
}
function deserializeBoxWithStatement(pos) {
	return deserializeWithStatement(uint32[pos >> 2]);
}
function deserializeBoxVariableDeclaration(pos) {
	return deserializeVariableDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSTypeAliasDeclaration(pos) {
	return deserializeTSTypeAliasDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSInterfaceDeclaration(pos) {
	return deserializeTSInterfaceDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSEnumDeclaration(pos) {
	return deserializeTSEnumDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSModuleDeclaration(pos) {
	return deserializeTSModuleDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSGlobalDeclaration(pos) {
	return deserializeTSGlobalDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSImportEqualsDeclaration(pos) {
	return deserializeTSImportEqualsDeclaration(uint32[pos >> 2]);
}
function deserializeVecVariableDeclarator(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 56;
	for (; pos !== endPos;) arr.push(deserializeVariableDeclarator(pos)), pos += 56;
	return arr;
}
function deserializeBoxTSTypeAnnotation(pos) {
	return deserializeTSTypeAnnotation(uint32[pos >> 2]);
}
function deserializeOptionBoxTSTypeAnnotation(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxTSTypeAnnotation(pos);
}
function deserializeOptionStatement(pos) {
	return uint8[pos] === 70 ? null : deserializeStatement(pos);
}
function deserializeOptionForStatementInit(pos) {
	return uint8[pos] === 65 ? null : deserializeForStatementInit(pos);
}
function deserializeOptionLabelIdentifier(pos) {
	return uint32[pos + 8 >> 2] === 0 && uint32[pos + 12 >> 2] === 0 ? null : deserializeLabelIdentifier(pos);
}
function deserializeVecSwitchCase(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 48;
	for (; pos !== endPos;) arr.push(deserializeSwitchCase(pos)), pos += 48;
	return arr;
}
function deserializeBoxCatchClause(pos) {
	return deserializeCatchClause(uint32[pos >> 2]);
}
function deserializeOptionBoxCatchClause(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxCatchClause(pos);
}
function deserializeOptionBoxBlockStatement(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxBlockStatement(pos);
}
function deserializeOptionCatchParameter(pos) {
	return uint8[pos + 8] === 4 ? null : deserializeCatchParameter(pos);
}
function deserializeBoxBindingIdentifier(pos) {
	return deserializeBindingIdentifier(uint32[pos >> 2]);
}
function deserializeBoxObjectPattern(pos) {
	return deserializeObjectPattern(uint32[pos >> 2]);
}
function deserializeBoxArrayPattern(pos) {
	return deserializeArrayPattern(uint32[pos >> 2]);
}
function deserializeBoxAssignmentPattern(pos) {
	return deserializeAssignmentPattern(uint32[pos >> 2]);
}
function deserializeVecBindingProperty(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 48;
	for (; pos !== endPos;) arr.push(deserializeBindingProperty(pos)), pos += 48;
	return arr;
}
function deserializeBoxBindingRestElement(pos) {
	return deserializeBindingRestElement(uint32[pos >> 2]);
}
function deserializeOptionBoxBindingRestElement(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxBindingRestElement(pos);
}
function deserializeOptionBindingPattern(pos) {
	return uint8[pos] === 4 ? null : deserializeBindingPattern(pos);
}
function deserializeVecOptionBindingPattern(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeOptionBindingPattern(pos)), pos += 16;
	return arr;
}
function deserializeOptionBindingIdentifier(pos) {
	return uint32[pos + 8 >> 2] === 0 && uint32[pos + 12 >> 2] === 0 ? null : deserializeBindingIdentifier(pos);
}
function deserializeBoxTSTypeParameterDeclaration(pos) {
	return deserializeTSTypeParameterDeclaration(uint32[pos >> 2]);
}
function deserializeOptionBoxTSTypeParameterDeclaration(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxTSTypeParameterDeclaration(pos);
}
function deserializeBoxTSThisParameter(pos) {
	return deserializeTSThisParameter(uint32[pos >> 2]);
}
function deserializeOptionBoxTSThisParameter(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxTSThisParameter(pos);
}
function deserializeBoxFormalParameters(pos) {
	return deserializeFormalParameters(uint32[pos >> 2]);
}
function deserializeBoxFunctionBody(pos) {
	return deserializeFunctionBody(uint32[pos >> 2]);
}
function deserializeOptionBoxFunctionBody(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxFunctionBody(pos);
}
function deserializeVecFormalParameter(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 72;
	for (; pos !== endPos;) arr.push(deserializeFormalParameter(pos)), pos += 72;
	return arr;
}
function deserializeVecDecorator(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 24;
	for (; pos !== endPos;) arr.push(deserializeDecorator(pos)), pos += 24;
	return arr;
}
function deserializeBoxExpression(pos) {
	return deserializeExpression(uint32[pos >> 2]);
}
function deserializeOptionBoxExpression(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxExpression(pos);
}
function deserializeOptionTSAccessibility(pos) {
	return uint8[pos] === 3 ? null : deserializeTSAccessibility(pos);
}
function deserializeVecTSClassImplements(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 32;
	for (; pos !== endPos;) arr.push(deserializeTSClassImplements(pos)), pos += 32;
	return arr;
}
function deserializeBoxClassBody(pos) {
	return deserializeClassBody(uint32[pos >> 2]);
}
function deserializeVecClassElement(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeClassElement(pos)), pos += 16;
	return arr;
}
function deserializeBoxStaticBlock(pos) {
	return deserializeStaticBlock(uint32[pos >> 2]);
}
function deserializeBoxMethodDefinition(pos) {
	return deserializeMethodDefinition(uint32[pos >> 2]);
}
function deserializeBoxPropertyDefinition(pos) {
	return deserializePropertyDefinition(uint32[pos >> 2]);
}
function deserializeBoxAccessorProperty(pos) {
	return deserializeAccessorProperty(uint32[pos >> 2]);
}
function deserializeBoxTSIndexSignature(pos) {
	return deserializeTSIndexSignature(uint32[pos >> 2]);
}
function deserializeBoxImportDeclaration(pos) {
	return deserializeImportDeclaration(uint32[pos >> 2]);
}
function deserializeBoxExportAllDeclaration(pos) {
	return deserializeExportAllDeclaration(uint32[pos >> 2]);
}
function deserializeBoxExportDefaultDeclaration(pos) {
	return deserializeExportDefaultDeclaration(uint32[pos >> 2]);
}
function deserializeBoxExportNamedDeclaration(pos) {
	return deserializeExportNamedDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSExportAssignment(pos) {
	return deserializeTSExportAssignment(uint32[pos >> 2]);
}
function deserializeBoxTSNamespaceExportDeclaration(pos) {
	return deserializeTSNamespaceExportDeclaration(uint32[pos >> 2]);
}
function deserializeOptionImportPhase(pos) {
	return uint8[pos] === 2 ? null : deserializeImportPhase(pos);
}
function deserializeVecImportDeclarationSpecifier(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeImportDeclarationSpecifier(pos)), pos += 16;
	return arr;
}
function deserializeOptionVecImportDeclarationSpecifier(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeVecImportDeclarationSpecifier(pos);
}
function deserializeBoxWithClause(pos) {
	return deserializeWithClause(uint32[pos >> 2]);
}
function deserializeOptionBoxWithClause(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxWithClause(pos);
}
function deserializeBoxImportSpecifier(pos) {
	return deserializeImportSpecifier(uint32[pos >> 2]);
}
function deserializeBoxImportDefaultSpecifier(pos) {
	return deserializeImportDefaultSpecifier(uint32[pos >> 2]);
}
function deserializeBoxImportNamespaceSpecifier(pos) {
	return deserializeImportNamespaceSpecifier(uint32[pos >> 2]);
}
function deserializeVecImportAttribute(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 112;
	for (; pos !== endPos;) arr.push(deserializeImportAttribute(pos)), pos += 112;
	return arr;
}
function deserializeOptionDeclaration(pos) {
	return uint8[pos] === 31 ? null : deserializeDeclaration(pos);
}
function deserializeVecExportSpecifier(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 128;
	for (; pos !== endPos;) arr.push(deserializeExportSpecifier(pos)), pos += 128;
	return arr;
}
function deserializeOptionStringLiteral(pos) {
	return uint8[pos + 40] === 2 ? null : deserializeStringLiteral(pos);
}
function deserializeOptionModuleExportName(pos) {
	return uint8[pos] === 3 ? null : deserializeModuleExportName(pos);
}
function deserializeF64(pos) {
	return float64[pos >> 3];
}
function deserializeBoxJSXOpeningElement(pos) {
	return deserializeJSXOpeningElement(uint32[pos >> 2]);
}
function deserializeVecJSXChild(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeJSXChild(pos)), pos += 16;
	return arr;
}
function deserializeBoxJSXClosingElement(pos) {
	return deserializeJSXClosingElement(uint32[pos >> 2]);
}
function deserializeOptionBoxJSXClosingElement(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxJSXClosingElement(pos);
}
function deserializeVecJSXAttributeItem(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeJSXAttributeItem(pos)), pos += 16;
	return arr;
}
function deserializeBoxJSXIdentifier(pos) {
	return deserializeJSXIdentifier(uint32[pos >> 2]);
}
function deserializeBoxJSXNamespacedName(pos) {
	return deserializeJSXNamespacedName(uint32[pos >> 2]);
}
function deserializeBoxJSXMemberExpression(pos) {
	return deserializeJSXMemberExpression(uint32[pos >> 2]);
}
function deserializeBoxJSXAttribute(pos) {
	return deserializeJSXAttribute(uint32[pos >> 2]);
}
function deserializeBoxJSXSpreadAttribute(pos) {
	return deserializeJSXSpreadAttribute(uint32[pos >> 2]);
}
function deserializeOptionJSXAttributeValue(pos) {
	return uint8[pos] === 4 ? null : deserializeJSXAttributeValue(pos);
}
function deserializeBoxJSXExpressionContainer(pos) {
	return deserializeJSXExpressionContainer(uint32[pos >> 2]);
}
function deserializeBoxJSXText(pos) {
	return deserializeJSXText(uint32[pos >> 2]);
}
function deserializeBoxJSXSpreadChild(pos) {
	return deserializeJSXSpreadChild(uint32[pos >> 2]);
}
function deserializeVecTSEnumMember(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 40;
	for (; pos !== endPos;) arr.push(deserializeTSEnumMember(pos)), pos += 40;
	return arr;
}
function deserializeBoxTSAnyKeyword(pos) {
	return deserializeTSAnyKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSBigIntKeyword(pos) {
	return deserializeTSBigIntKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSBooleanKeyword(pos) {
	return deserializeTSBooleanKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSIntrinsicKeyword(pos) {
	return deserializeTSIntrinsicKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSNeverKeyword(pos) {
	return deserializeTSNeverKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSNullKeyword(pos) {
	return deserializeTSNullKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSNumberKeyword(pos) {
	return deserializeTSNumberKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSObjectKeyword(pos) {
	return deserializeTSObjectKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSStringKeyword(pos) {
	return deserializeTSStringKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSSymbolKeyword(pos) {
	return deserializeTSSymbolKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSUndefinedKeyword(pos) {
	return deserializeTSUndefinedKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSUnknownKeyword(pos) {
	return deserializeTSUnknownKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSVoidKeyword(pos) {
	return deserializeTSVoidKeyword(uint32[pos >> 2]);
}
function deserializeBoxTSArrayType(pos) {
	return deserializeTSArrayType(uint32[pos >> 2]);
}
function deserializeBoxTSConditionalType(pos) {
	return deserializeTSConditionalType(uint32[pos >> 2]);
}
function deserializeBoxTSConstructorType(pos) {
	return deserializeTSConstructorType(uint32[pos >> 2]);
}
function deserializeBoxTSFunctionType(pos) {
	return deserializeTSFunctionType(uint32[pos >> 2]);
}
function deserializeBoxTSImportType(pos) {
	return deserializeTSImportType(uint32[pos >> 2]);
}
function deserializeBoxTSIndexedAccessType(pos) {
	return deserializeTSIndexedAccessType(uint32[pos >> 2]);
}
function deserializeBoxTSInferType(pos) {
	return deserializeTSInferType(uint32[pos >> 2]);
}
function deserializeBoxTSIntersectionType(pos) {
	return deserializeTSIntersectionType(uint32[pos >> 2]);
}
function deserializeBoxTSLiteralType(pos) {
	return deserializeTSLiteralType(uint32[pos >> 2]);
}
function deserializeBoxTSMappedType(pos) {
	return deserializeTSMappedType(uint32[pos >> 2]);
}
function deserializeBoxTSNamedTupleMember(pos) {
	return deserializeTSNamedTupleMember(uint32[pos >> 2]);
}
function deserializeBoxTSTemplateLiteralType(pos) {
	return deserializeTSTemplateLiteralType(uint32[pos >> 2]);
}
function deserializeBoxTSThisType(pos) {
	return deserializeTSThisType(uint32[pos >> 2]);
}
function deserializeBoxTSTupleType(pos) {
	return deserializeTSTupleType(uint32[pos >> 2]);
}
function deserializeBoxTSTypeLiteral(pos) {
	return deserializeTSTypeLiteral(uint32[pos >> 2]);
}
function deserializeBoxTSTypeOperator(pos) {
	return deserializeTSTypeOperator(uint32[pos >> 2]);
}
function deserializeBoxTSTypePredicate(pos) {
	return deserializeTSTypePredicate(uint32[pos >> 2]);
}
function deserializeBoxTSTypeQuery(pos) {
	return deserializeTSTypeQuery(uint32[pos >> 2]);
}
function deserializeBoxTSTypeReference(pos) {
	return deserializeTSTypeReference(uint32[pos >> 2]);
}
function deserializeBoxTSUnionType(pos) {
	return deserializeTSUnionType(uint32[pos >> 2]);
}
function deserializeBoxTSParenthesizedType(pos) {
	return deserializeTSParenthesizedType(uint32[pos >> 2]);
}
function deserializeBoxJSDocNullableType(pos) {
	return deserializeJSDocNullableType(uint32[pos >> 2]);
}
function deserializeBoxJSDocNonNullableType(pos) {
	return deserializeJSDocNonNullableType(uint32[pos >> 2]);
}
function deserializeBoxJSDocUnknownType(pos) {
	return deserializeJSDocUnknownType(uint32[pos >> 2]);
}
function deserializeVecTSType(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeTSType(pos)), pos += 16;
	return arr;
}
function deserializeVecTSTupleElement(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeTSTupleElement(pos)), pos += 16;
	return arr;
}
function deserializeBoxTSOptionalType(pos) {
	return deserializeTSOptionalType(uint32[pos >> 2]);
}
function deserializeBoxTSRestType(pos) {
	return deserializeTSRestType(uint32[pos >> 2]);
}
function deserializeBoxTSQualifiedName(pos) {
	return deserializeTSQualifiedName(uint32[pos >> 2]);
}
function deserializeOptionTSType(pos) {
	return uint8[pos] === 38 ? null : deserializeTSType(pos);
}
function deserializeVecTSTypeParameter(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 80;
	for (; pos !== endPos;) arr.push(deserializeTSTypeParameter(pos)), pos += 80;
	return arr;
}
function deserializeVecTSInterfaceHeritage(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 32;
	for (; pos !== endPos;) arr.push(deserializeTSInterfaceHeritage(pos)), pos += 32;
	return arr;
}
function deserializeBoxTSInterfaceBody(pos) {
	return deserializeTSInterfaceBody(uint32[pos >> 2]);
}
function deserializeVecTSSignature(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 16;
	for (; pos !== endPos;) arr.push(deserializeTSSignature(pos)), pos += 16;
	return arr;
}
function deserializeBoxTSPropertySignature(pos) {
	return deserializeTSPropertySignature(uint32[pos >> 2]);
}
function deserializeBoxTSCallSignatureDeclaration(pos) {
	return deserializeTSCallSignatureDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSConstructSignatureDeclaration(pos) {
	return deserializeTSConstructSignatureDeclaration(uint32[pos >> 2]);
}
function deserializeBoxTSMethodSignature(pos) {
	return deserializeTSMethodSignature(uint32[pos >> 2]);
}
function deserializeVecTSIndexSignatureName(pos) {
	let arr = [], pos32 = pos >> 2;
	pos = uint32[pos32];
	let endPos = pos + uint32[pos32 + 2] * 32;
	for (; pos !== endPos;) arr.push(deserializeTSIndexSignatureName(pos)), pos += 32;
	return arr;
}
function deserializeOptionTSModuleDeclarationBody(pos) {
	return uint8[pos] === 2 ? null : deserializeTSModuleDeclarationBody(pos);
}
function deserializeBoxTSModuleBlock(pos) {
	return deserializeTSModuleBlock(uint32[pos >> 2]);
}
function deserializeBoxTSTypeParameter(pos) {
	return deserializeTSTypeParameter(uint32[pos >> 2]);
}
function deserializeOptionBoxObjectExpression(pos) {
	return uint32[pos >> 2] === 0 && uint32[pos + 4 >> 2] === 0 ? null : deserializeBoxObjectExpression(pos);
}
function deserializeOptionTSImportTypeQualifier(pos) {
	return uint8[pos] === 2 ? null : deserializeTSImportTypeQualifier(pos);
}
function deserializeBoxTSImportTypeQualifiedName(pos) {
	return deserializeTSImportTypeQualifiedName(uint32[pos >> 2]);
}
function deserializeOptionTSMappedTypeModifierOperator(pos) {
	return uint8[pos] === 3 ? null : deserializeTSMappedTypeModifierOperator(pos);
}
function deserializeBoxTSExternalModuleReference(pos) {
	return deserializeTSExternalModuleReference(uint32[pos >> 2]);
}
const WHITESPACE_ONLY_REGEXP = /^\s*$/;
function getAllComments() {
	return ast === null && initAst(), ast.comments;
}
function getCommentsBefore(nodeOrToken) {
	ast === null && initAst();
	let { comments } = ast, commentsLength = comments.length, targetStart = nodeOrToken.range[0], sliceStart = commentsLength, sliceEnd = 0;
	for (let lo = 0, hi = commentsLength; lo < hi;) {
		let mid = lo + hi >> 1;
		comments[mid].end <= targetStart ? sliceEnd = lo = mid + 1 : hi = mid;
	}
	for (let i = sliceEnd - 1; i >= 0; i--) {
		let comment = comments[i], gap = sourceText.slice(comment.end, targetStart);
		if (WHITESPACE_ONLY_REGEXP.test(gap)) sliceStart = i, targetStart = comment.start;
		else break;
	}
	return comments.slice(sliceStart, sliceEnd);
}
function getCommentsAfter(nodeOrToken) {
	ast === null && initAst();
	let { comments } = ast, commentsLength = comments.length, targetEnd = nodeOrToken.range[1], sliceStart = commentsLength, sliceEnd = 0;
	for (let lo = 0, hi = commentsLength; lo < hi;) {
		let mid = lo + hi >> 1;
		comments[mid].start < targetEnd ? lo = mid + 1 : sliceStart = hi = mid;
	}
	for (let i = sliceStart; i < commentsLength; i++) {
		let comment = comments[i], gap = sourceText.slice(targetEnd, comment.start);
		if (WHITESPACE_ONLY_REGEXP.test(gap)) sliceEnd = i + 1, targetEnd = comment.end;
		else break;
	}
	return comments.slice(sliceStart, sliceEnd);
}
function getCommentsInside(node) {
	ast === null && initAst();
	let { comments } = ast, commentsLength = comments.length, sliceStart = commentsLength, sliceEnd, { range } = node, rangeStart = range[0], rangeEnd = range[1];
	for (let lo = 0, hi = commentsLength; lo < hi;) {
		let mid = lo + hi >> 1;
		comments[mid].start < rangeStart ? lo = mid + 1 : sliceStart = hi = mid;
	}
	for (let lo = sliceStart, hi = commentsLength; lo < hi;) {
		let mid = lo + hi >> 1;
		comments[mid].start < rangeEnd ? lo = mid + 1 : sliceEnd = hi = mid;
	}
	return comments.slice(sliceStart, sliceEnd);
}
function commentsExistBetween(nodeOrToken1, nodeOrToken2) {
	ast === null && initAst();
	let { comments } = ast, commentsLength = comments.length, betweenRangeStart = nodeOrToken1.range[1], firstCommentBetween = -1;
	for (let lo = 0, hi = commentsLength; lo < hi;) {
		let mid = lo + hi >> 1;
		comments[mid].start < betweenRangeStart ? lo = mid + 1 : firstCommentBetween = hi = mid;
	}
	return 0 <= firstCommentBetween && firstCommentBetween < commentsLength && comments[firstCommentBetween].end <= nodeOrToken2.range[0];
}
function getJSDocComment(node) {
	throw Error("`sourceCode.getJSDocComment` is not supported at present (and deprecated)");
}
var require_eslint_visitor_keys = /* @__PURE__ */ __commonJSMin(((exports) => {
	let KEYS = {
		ArrayExpression: ["elements"],
		ArrayPattern: ["elements"],
		ArrowFunctionExpression: ["params", "body"],
		AssignmentExpression: ["left", "right"],
		AssignmentPattern: ["left", "right"],
		AwaitExpression: ["argument"],
		BinaryExpression: ["left", "right"],
		BlockStatement: ["body"],
		BreakStatement: ["label"],
		CallExpression: ["callee", "arguments"],
		CatchClause: ["param", "body"],
		ChainExpression: ["expression"],
		ClassBody: ["body"],
		ClassDeclaration: [
			"id",
			"superClass",
			"body"
		],
		ClassExpression: [
			"id",
			"superClass",
			"body"
		],
		ConditionalExpression: [
			"test",
			"consequent",
			"alternate"
		],
		ContinueStatement: ["label"],
		DebuggerStatement: [],
		DoWhileStatement: ["body", "test"],
		EmptyStatement: [],
		ExperimentalRestProperty: ["argument"],
		ExperimentalSpreadProperty: ["argument"],
		ExportAllDeclaration: [
			"exported",
			"source",
			"attributes"
		],
		ExportDefaultDeclaration: ["declaration"],
		ExportNamedDeclaration: [
			"declaration",
			"specifiers",
			"source",
			"attributes"
		],
		ExportSpecifier: ["local", "exported"],
		ExpressionStatement: ["expression"],
		ForInStatement: [
			"left",
			"right",
			"body"
		],
		ForOfStatement: [
			"left",
			"right",
			"body"
		],
		ForStatement: [
			"init",
			"test",
			"update",
			"body"
		],
		FunctionDeclaration: [
			"id",
			"params",
			"body"
		],
		FunctionExpression: [
			"id",
			"params",
			"body"
		],
		Identifier: [],
		IfStatement: [
			"test",
			"consequent",
			"alternate"
		],
		ImportAttribute: ["key", "value"],
		ImportDeclaration: [
			"specifiers",
			"source",
			"attributes"
		],
		ImportDefaultSpecifier: ["local"],
		ImportExpression: ["source", "options"],
		ImportNamespaceSpecifier: ["local"],
		ImportSpecifier: ["imported", "local"],
		JSXAttribute: ["name", "value"],
		JSXClosingElement: ["name"],
		JSXClosingFragment: [],
		JSXElement: [
			"openingElement",
			"children",
			"closingElement"
		],
		JSXEmptyExpression: [],
		JSXExpressionContainer: ["expression"],
		JSXFragment: [
			"openingFragment",
			"children",
			"closingFragment"
		],
		JSXIdentifier: [],
		JSXMemberExpression: ["object", "property"],
		JSXNamespacedName: ["namespace", "name"],
		JSXOpeningElement: ["name", "attributes"],
		JSXOpeningFragment: [],
		JSXSpreadAttribute: ["argument"],
		JSXSpreadChild: ["expression"],
		JSXText: [],
		LabeledStatement: ["label", "body"],
		Literal: [],
		LogicalExpression: ["left", "right"],
		MemberExpression: ["object", "property"],
		MetaProperty: ["meta", "property"],
		MethodDefinition: ["key", "value"],
		NewExpression: ["callee", "arguments"],
		ObjectExpression: ["properties"],
		ObjectPattern: ["properties"],
		PrivateIdentifier: [],
		Program: ["body"],
		Property: ["key", "value"],
		PropertyDefinition: ["key", "value"],
		RestElement: ["argument"],
		ReturnStatement: ["argument"],
		SequenceExpression: ["expressions"],
		SpreadElement: ["argument"],
		StaticBlock: ["body"],
		Super: [],
		SwitchCase: ["test", "consequent"],
		SwitchStatement: ["discriminant", "cases"],
		TaggedTemplateExpression: ["tag", "quasi"],
		TemplateElement: [],
		TemplateLiteral: ["quasis", "expressions"],
		ThisExpression: [],
		ThrowStatement: ["argument"],
		TryStatement: [
			"block",
			"handler",
			"finalizer"
		],
		UnaryExpression: ["argument"],
		UpdateExpression: ["argument"],
		VariableDeclaration: ["declarations"],
		VariableDeclarator: ["id", "init"],
		WhileStatement: ["test", "body"],
		WithStatement: ["object", "body"],
		YieldExpression: ["argument"]
	}, NODE_TYPES = Object.keys(KEYS);
	for (let type of NODE_TYPES) Object.freeze(KEYS[type]);
	Object.freeze(KEYS);
	let KEY_BLACKLIST = new Set([
		"parent",
		"leadingComments",
		"trailingComments"
	]);
	function filterKey(key) {
		return !KEY_BLACKLIST.has(key) && key[0] !== "_";
	}
	function getKeys(node) {
		return Object.keys(node).filter(filterKey);
	}
	function unionWith(additionalKeys) {
		let retv = Object.assign({}, KEYS);
		for (let type of Object.keys(additionalKeys)) if (Object.hasOwn(retv, type)) {
			let keys = new Set(additionalKeys[type]);
			for (let key of retv[type]) keys.add(key);
			retv[type] = Object.freeze(Array.from(keys));
		} else retv[type] = Object.freeze(Array.from(additionalKeys[type]));
		return Object.freeze(retv);
	}
	exports.KEYS = KEYS, exports.getKeys = getKeys, exports.unionWith = unionWith;
})), require_get_keys = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getKeys = void 0, exports.getKeys = require_eslint_visitor_keys().getKeys;
})), require_visitor_keys = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k);
		var desc = Object.getOwnPropertyDescriptor(m, k);
		(!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
			enumerable: !0,
			get: function() {
				return m[k];
			}
		}), Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k), o[k2] = m[k];
	})), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: !0,
			value: v
		});
	}) : function(o, v) {
		o.default = v;
	}), __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			return ownKeys = Object.getOwnPropertyNames || function(o) {
				var ar = [];
				for (var k in o) Object.prototype.hasOwnProperty.call(o, k) && (ar[ar.length] = k);
				return ar;
			}, ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) k[i] !== "default" && __createBinding(result, mod, k[i]);
			return __setModuleDefault(result, mod), result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.visitorKeys = void 0;
	let eslintVisitorKeys = __importStar(require_eslint_visitor_keys()), SharedVisitorKeys = (() => {
		let FunctionType = [
			"typeParameters",
			"params",
			"returnType"
		], AnonymousFunction = [...FunctionType, "body"], AbstractPropertyDefinition = [
			"decorators",
			"key",
			"typeAnnotation"
		];
		return {
			AbstractPropertyDefinition: [
				"decorators",
				"key",
				"typeAnnotation"
			],
			AnonymousFunction,
			AsExpression: ["expression", "typeAnnotation"],
			ClassDeclaration: [
				"decorators",
				"id",
				"typeParameters",
				"superClass",
				"superTypeArguments",
				"implements",
				"body"
			],
			Function: ["id", ...AnonymousFunction],
			FunctionType,
			PropertyDefinition: [...AbstractPropertyDefinition, "value"]
		};
	})(), additionalKeys = {
		AccessorProperty: SharedVisitorKeys.PropertyDefinition,
		ArrayPattern: [
			"decorators",
			"elements",
			"typeAnnotation"
		],
		ArrowFunctionExpression: SharedVisitorKeys.AnonymousFunction,
		AssignmentPattern: [
			"decorators",
			"left",
			"right",
			"typeAnnotation"
		],
		CallExpression: [
			"callee",
			"typeArguments",
			"arguments"
		],
		ClassDeclaration: SharedVisitorKeys.ClassDeclaration,
		ClassExpression: SharedVisitorKeys.ClassDeclaration,
		Decorator: ["expression"],
		ExportAllDeclaration: [
			"exported",
			"source",
			"attributes"
		],
		ExportNamedDeclaration: [
			"declaration",
			"specifiers",
			"source",
			"attributes"
		],
		FunctionDeclaration: SharedVisitorKeys.Function,
		FunctionExpression: SharedVisitorKeys.Function,
		Identifier: ["decorators", "typeAnnotation"],
		ImportAttribute: ["key", "value"],
		ImportDeclaration: [
			"specifiers",
			"source",
			"attributes"
		],
		ImportExpression: ["source", "options"],
		JSXClosingFragment: [],
		JSXOpeningElement: [
			"name",
			"typeArguments",
			"attributes"
		],
		JSXOpeningFragment: [],
		JSXSpreadChild: ["expression"],
		MethodDefinition: [
			"decorators",
			"key",
			"value"
		],
		NewExpression: [
			"callee",
			"typeArguments",
			"arguments"
		],
		ObjectPattern: [
			"decorators",
			"properties",
			"typeAnnotation"
		],
		PropertyDefinition: SharedVisitorKeys.PropertyDefinition,
		RestElement: [
			"decorators",
			"argument",
			"typeAnnotation"
		],
		StaticBlock: ["body"],
		TaggedTemplateExpression: [
			"tag",
			"typeArguments",
			"quasi"
		],
		TSAbstractAccessorProperty: SharedVisitorKeys.AbstractPropertyDefinition,
		TSAbstractKeyword: [],
		TSAbstractMethodDefinition: ["key", "value"],
		TSAbstractPropertyDefinition: SharedVisitorKeys.AbstractPropertyDefinition,
		TSAnyKeyword: [],
		TSArrayType: ["elementType"],
		TSAsExpression: SharedVisitorKeys.AsExpression,
		TSAsyncKeyword: [],
		TSBigIntKeyword: [],
		TSBooleanKeyword: [],
		TSCallSignatureDeclaration: SharedVisitorKeys.FunctionType,
		TSClassImplements: ["expression", "typeArguments"],
		TSConditionalType: [
			"checkType",
			"extendsType",
			"trueType",
			"falseType"
		],
		TSConstructorType: SharedVisitorKeys.FunctionType,
		TSConstructSignatureDeclaration: SharedVisitorKeys.FunctionType,
		TSDeclareFunction: SharedVisitorKeys.Function,
		TSDeclareKeyword: [],
		TSEmptyBodyFunctionExpression: ["id", ...SharedVisitorKeys.FunctionType],
		TSEnumBody: ["members"],
		TSEnumDeclaration: ["id", "body"],
		TSEnumMember: ["id", "initializer"],
		TSExportAssignment: ["expression"],
		TSExportKeyword: [],
		TSExternalModuleReference: ["expression"],
		TSFunctionType: SharedVisitorKeys.FunctionType,
		TSImportEqualsDeclaration: ["id", "moduleReference"],
		TSImportType: [
			"source",
			"options",
			"qualifier",
			"typeArguments"
		],
		TSIndexedAccessType: ["objectType", "indexType"],
		TSIndexSignature: ["parameters", "typeAnnotation"],
		TSInferType: ["typeParameter"],
		TSInstantiationExpression: ["expression", "typeArguments"],
		TSInterfaceBody: ["body"],
		TSInterfaceDeclaration: [
			"id",
			"typeParameters",
			"extends",
			"body"
		],
		TSInterfaceHeritage: ["expression", "typeArguments"],
		TSIntersectionType: ["types"],
		TSIntrinsicKeyword: [],
		TSLiteralType: ["literal"],
		TSMappedType: [
			"key",
			"constraint",
			"nameType",
			"typeAnnotation"
		],
		TSMethodSignature: [
			"key",
			"typeParameters",
			"params",
			"returnType"
		],
		TSModuleBlock: ["body"],
		TSModuleDeclaration: ["id", "body"],
		TSNamedTupleMember: ["label", "elementType"],
		TSNamespaceExportDeclaration: ["id"],
		TSNeverKeyword: [],
		TSNonNullExpression: ["expression"],
		TSNullKeyword: [],
		TSNumberKeyword: [],
		TSObjectKeyword: [],
		TSOptionalType: ["typeAnnotation"],
		TSParameterProperty: ["decorators", "parameter"],
		TSPrivateKeyword: [],
		TSPropertySignature: ["key", "typeAnnotation"],
		TSProtectedKeyword: [],
		TSPublicKeyword: [],
		TSQualifiedName: ["left", "right"],
		TSReadonlyKeyword: [],
		TSRestType: ["typeAnnotation"],
		TSSatisfiesExpression: SharedVisitorKeys.AsExpression,
		TSStaticKeyword: [],
		TSStringKeyword: [],
		TSSymbolKeyword: [],
		TSTemplateLiteralType: ["quasis", "types"],
		TSThisType: [],
		TSTupleType: ["elementTypes"],
		TSTypeAliasDeclaration: [
			"id",
			"typeParameters",
			"typeAnnotation"
		],
		TSTypeAnnotation: ["typeAnnotation"],
		TSTypeAssertion: ["typeAnnotation", "expression"],
		TSTypeLiteral: ["members"],
		TSTypeOperator: ["typeAnnotation"],
		TSTypeParameter: [
			"name",
			"constraint",
			"default"
		],
		TSTypeParameterDeclaration: ["params"],
		TSTypeParameterInstantiation: ["params"],
		TSTypePredicate: ["parameterName", "typeAnnotation"],
		TSTypeQuery: ["exprName", "typeArguments"],
		TSTypeReference: ["typeName", "typeArguments"],
		TSUndefinedKeyword: [],
		TSUnionType: ["types"],
		TSUnknownKeyword: [],
		TSVoidKeyword: []
	};
	exports.visitorKeys = eslintVisitorKeys.unionWith(additionalKeys);
})), require_dist$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.visitorKeys = exports.getKeys = void 0;
	var get_keys_1 = require_get_keys();
	Object.defineProperty(exports, "getKeys", {
		enumerable: !0,
		get: function() {
			return get_keys_1.getKeys;
		}
	});
	var visitor_keys_1 = require_visitor_keys();
	Object.defineProperty(exports, "visitorKeys", {
		enumerable: !0,
		get: function() {
			return visitor_keys_1.visitorKeys;
		}
	});
})), require_ast_spec = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.AST_TOKEN_TYPES = exports.AST_NODE_TYPES = void 0;
	var AST_NODE_TYPES;
	(function(AST_NODE_TYPES) {
		AST_NODE_TYPES.AccessorProperty = "AccessorProperty", AST_NODE_TYPES.ArrayExpression = "ArrayExpression", AST_NODE_TYPES.ArrayPattern = "ArrayPattern", AST_NODE_TYPES.ArrowFunctionExpression = "ArrowFunctionExpression", AST_NODE_TYPES.AssignmentExpression = "AssignmentExpression", AST_NODE_TYPES.AssignmentPattern = "AssignmentPattern", AST_NODE_TYPES.AwaitExpression = "AwaitExpression", AST_NODE_TYPES.BinaryExpression = "BinaryExpression", AST_NODE_TYPES.BlockStatement = "BlockStatement", AST_NODE_TYPES.BreakStatement = "BreakStatement", AST_NODE_TYPES.CallExpression = "CallExpression", AST_NODE_TYPES.CatchClause = "CatchClause", AST_NODE_TYPES.ChainExpression = "ChainExpression", AST_NODE_TYPES.ClassBody = "ClassBody", AST_NODE_TYPES.ClassDeclaration = "ClassDeclaration", AST_NODE_TYPES.ClassExpression = "ClassExpression", AST_NODE_TYPES.ConditionalExpression = "ConditionalExpression", AST_NODE_TYPES.ContinueStatement = "ContinueStatement", AST_NODE_TYPES.DebuggerStatement = "DebuggerStatement", AST_NODE_TYPES.Decorator = "Decorator", AST_NODE_TYPES.DoWhileStatement = "DoWhileStatement", AST_NODE_TYPES.EmptyStatement = "EmptyStatement", AST_NODE_TYPES.ExportAllDeclaration = "ExportAllDeclaration", AST_NODE_TYPES.ExportDefaultDeclaration = "ExportDefaultDeclaration", AST_NODE_TYPES.ExportNamedDeclaration = "ExportNamedDeclaration", AST_NODE_TYPES.ExportSpecifier = "ExportSpecifier", AST_NODE_TYPES.ExpressionStatement = "ExpressionStatement", AST_NODE_TYPES.ForInStatement = "ForInStatement", AST_NODE_TYPES.ForOfStatement = "ForOfStatement", AST_NODE_TYPES.ForStatement = "ForStatement", AST_NODE_TYPES.FunctionDeclaration = "FunctionDeclaration", AST_NODE_TYPES.FunctionExpression = "FunctionExpression", AST_NODE_TYPES.Identifier = "Identifier", AST_NODE_TYPES.IfStatement = "IfStatement", AST_NODE_TYPES.ImportAttribute = "ImportAttribute", AST_NODE_TYPES.ImportDeclaration = "ImportDeclaration", AST_NODE_TYPES.ImportDefaultSpecifier = "ImportDefaultSpecifier", AST_NODE_TYPES.ImportExpression = "ImportExpression", AST_NODE_TYPES.ImportNamespaceSpecifier = "ImportNamespaceSpecifier", AST_NODE_TYPES.ImportSpecifier = "ImportSpecifier", AST_NODE_TYPES.JSXAttribute = "JSXAttribute", AST_NODE_TYPES.JSXClosingElement = "JSXClosingElement", AST_NODE_TYPES.JSXClosingFragment = "JSXClosingFragment", AST_NODE_TYPES.JSXElement = "JSXElement", AST_NODE_TYPES.JSXEmptyExpression = "JSXEmptyExpression", AST_NODE_TYPES.JSXExpressionContainer = "JSXExpressionContainer", AST_NODE_TYPES.JSXFragment = "JSXFragment", AST_NODE_TYPES.JSXIdentifier = "JSXIdentifier", AST_NODE_TYPES.JSXMemberExpression = "JSXMemberExpression", AST_NODE_TYPES.JSXNamespacedName = "JSXNamespacedName", AST_NODE_TYPES.JSXOpeningElement = "JSXOpeningElement", AST_NODE_TYPES.JSXOpeningFragment = "JSXOpeningFragment", AST_NODE_TYPES.JSXSpreadAttribute = "JSXSpreadAttribute", AST_NODE_TYPES.JSXSpreadChild = "JSXSpreadChild", AST_NODE_TYPES.JSXText = "JSXText", AST_NODE_TYPES.LabeledStatement = "LabeledStatement", AST_NODE_TYPES.Literal = "Literal", AST_NODE_TYPES.LogicalExpression = "LogicalExpression", AST_NODE_TYPES.MemberExpression = "MemberExpression", AST_NODE_TYPES.MetaProperty = "MetaProperty", AST_NODE_TYPES.MethodDefinition = "MethodDefinition", AST_NODE_TYPES.NewExpression = "NewExpression", AST_NODE_TYPES.ObjectExpression = "ObjectExpression", AST_NODE_TYPES.ObjectPattern = "ObjectPattern", AST_NODE_TYPES.PrivateIdentifier = "PrivateIdentifier", AST_NODE_TYPES.Program = "Program", AST_NODE_TYPES.Property = "Property", AST_NODE_TYPES.PropertyDefinition = "PropertyDefinition", AST_NODE_TYPES.RestElement = "RestElement", AST_NODE_TYPES.ReturnStatement = "ReturnStatement", AST_NODE_TYPES.SequenceExpression = "SequenceExpression", AST_NODE_TYPES.SpreadElement = "SpreadElement", AST_NODE_TYPES.StaticBlock = "StaticBlock", AST_NODE_TYPES.Super = "Super", AST_NODE_TYPES.SwitchCase = "SwitchCase", AST_NODE_TYPES.SwitchStatement = "SwitchStatement", AST_NODE_TYPES.TaggedTemplateExpression = "TaggedTemplateExpression", AST_NODE_TYPES.TemplateElement = "TemplateElement", AST_NODE_TYPES.TemplateLiteral = "TemplateLiteral", AST_NODE_TYPES.ThisExpression = "ThisExpression", AST_NODE_TYPES.ThrowStatement = "ThrowStatement", AST_NODE_TYPES.TryStatement = "TryStatement", AST_NODE_TYPES.UnaryExpression = "UnaryExpression", AST_NODE_TYPES.UpdateExpression = "UpdateExpression", AST_NODE_TYPES.VariableDeclaration = "VariableDeclaration", AST_NODE_TYPES.VariableDeclarator = "VariableDeclarator", AST_NODE_TYPES.WhileStatement = "WhileStatement", AST_NODE_TYPES.WithStatement = "WithStatement", AST_NODE_TYPES.YieldExpression = "YieldExpression", AST_NODE_TYPES.TSAbstractAccessorProperty = "TSAbstractAccessorProperty", AST_NODE_TYPES.TSAbstractKeyword = "TSAbstractKeyword", AST_NODE_TYPES.TSAbstractMethodDefinition = "TSAbstractMethodDefinition", AST_NODE_TYPES.TSAbstractPropertyDefinition = "TSAbstractPropertyDefinition", AST_NODE_TYPES.TSAnyKeyword = "TSAnyKeyword", AST_NODE_TYPES.TSArrayType = "TSArrayType", AST_NODE_TYPES.TSAsExpression = "TSAsExpression", AST_NODE_TYPES.TSAsyncKeyword = "TSAsyncKeyword", AST_NODE_TYPES.TSBigIntKeyword = "TSBigIntKeyword", AST_NODE_TYPES.TSBooleanKeyword = "TSBooleanKeyword", AST_NODE_TYPES.TSCallSignatureDeclaration = "TSCallSignatureDeclaration", AST_NODE_TYPES.TSClassImplements = "TSClassImplements", AST_NODE_TYPES.TSConditionalType = "TSConditionalType", AST_NODE_TYPES.TSConstructorType = "TSConstructorType", AST_NODE_TYPES.TSConstructSignatureDeclaration = "TSConstructSignatureDeclaration", AST_NODE_TYPES.TSDeclareFunction = "TSDeclareFunction", AST_NODE_TYPES.TSDeclareKeyword = "TSDeclareKeyword", AST_NODE_TYPES.TSEmptyBodyFunctionExpression = "TSEmptyBodyFunctionExpression", AST_NODE_TYPES.TSEnumBody = "TSEnumBody", AST_NODE_TYPES.TSEnumDeclaration = "TSEnumDeclaration", AST_NODE_TYPES.TSEnumMember = "TSEnumMember", AST_NODE_TYPES.TSExportAssignment = "TSExportAssignment", AST_NODE_TYPES.TSExportKeyword = "TSExportKeyword", AST_NODE_TYPES.TSExternalModuleReference = "TSExternalModuleReference", AST_NODE_TYPES.TSFunctionType = "TSFunctionType", AST_NODE_TYPES.TSImportEqualsDeclaration = "TSImportEqualsDeclaration", AST_NODE_TYPES.TSImportType = "TSImportType", AST_NODE_TYPES.TSIndexedAccessType = "TSIndexedAccessType", AST_NODE_TYPES.TSIndexSignature = "TSIndexSignature", AST_NODE_TYPES.TSInferType = "TSInferType", AST_NODE_TYPES.TSInstantiationExpression = "TSInstantiationExpression", AST_NODE_TYPES.TSInterfaceBody = "TSInterfaceBody", AST_NODE_TYPES.TSInterfaceDeclaration = "TSInterfaceDeclaration", AST_NODE_TYPES.TSInterfaceHeritage = "TSInterfaceHeritage", AST_NODE_TYPES.TSIntersectionType = "TSIntersectionType", AST_NODE_TYPES.TSIntrinsicKeyword = "TSIntrinsicKeyword", AST_NODE_TYPES.TSLiteralType = "TSLiteralType", AST_NODE_TYPES.TSMappedType = "TSMappedType", AST_NODE_TYPES.TSMethodSignature = "TSMethodSignature", AST_NODE_TYPES.TSModuleBlock = "TSModuleBlock", AST_NODE_TYPES.TSModuleDeclaration = "TSModuleDeclaration", AST_NODE_TYPES.TSNamedTupleMember = "TSNamedTupleMember", AST_NODE_TYPES.TSNamespaceExportDeclaration = "TSNamespaceExportDeclaration", AST_NODE_TYPES.TSNeverKeyword = "TSNeverKeyword", AST_NODE_TYPES.TSNonNullExpression = "TSNonNullExpression", AST_NODE_TYPES.TSNullKeyword = "TSNullKeyword", AST_NODE_TYPES.TSNumberKeyword = "TSNumberKeyword", AST_NODE_TYPES.TSObjectKeyword = "TSObjectKeyword", AST_NODE_TYPES.TSOptionalType = "TSOptionalType", AST_NODE_TYPES.TSParameterProperty = "TSParameterProperty", AST_NODE_TYPES.TSPrivateKeyword = "TSPrivateKeyword", AST_NODE_TYPES.TSPropertySignature = "TSPropertySignature", AST_NODE_TYPES.TSProtectedKeyword = "TSProtectedKeyword", AST_NODE_TYPES.TSPublicKeyword = "TSPublicKeyword", AST_NODE_TYPES.TSQualifiedName = "TSQualifiedName", AST_NODE_TYPES.TSReadonlyKeyword = "TSReadonlyKeyword", AST_NODE_TYPES.TSRestType = "TSRestType", AST_NODE_TYPES.TSSatisfiesExpression = "TSSatisfiesExpression", AST_NODE_TYPES.TSStaticKeyword = "TSStaticKeyword", AST_NODE_TYPES.TSStringKeyword = "TSStringKeyword", AST_NODE_TYPES.TSSymbolKeyword = "TSSymbolKeyword", AST_NODE_TYPES.TSTemplateLiteralType = "TSTemplateLiteralType", AST_NODE_TYPES.TSThisType = "TSThisType", AST_NODE_TYPES.TSTupleType = "TSTupleType", AST_NODE_TYPES.TSTypeAliasDeclaration = "TSTypeAliasDeclaration", AST_NODE_TYPES.TSTypeAnnotation = "TSTypeAnnotation", AST_NODE_TYPES.TSTypeAssertion = "TSTypeAssertion", AST_NODE_TYPES.TSTypeLiteral = "TSTypeLiteral", AST_NODE_TYPES.TSTypeOperator = "TSTypeOperator", AST_NODE_TYPES.TSTypeParameter = "TSTypeParameter", AST_NODE_TYPES.TSTypeParameterDeclaration = "TSTypeParameterDeclaration", AST_NODE_TYPES.TSTypeParameterInstantiation = "TSTypeParameterInstantiation", AST_NODE_TYPES.TSTypePredicate = "TSTypePredicate", AST_NODE_TYPES.TSTypeQuery = "TSTypeQuery", AST_NODE_TYPES.TSTypeReference = "TSTypeReference", AST_NODE_TYPES.TSUndefinedKeyword = "TSUndefinedKeyword", AST_NODE_TYPES.TSUnionType = "TSUnionType", AST_NODE_TYPES.TSUnknownKeyword = "TSUnknownKeyword", AST_NODE_TYPES.TSVoidKeyword = "TSVoidKeyword";
	})(AST_NODE_TYPES || (exports.AST_NODE_TYPES = AST_NODE_TYPES = {}));
	var AST_TOKEN_TYPES;
	(function(AST_TOKEN_TYPES) {
		AST_TOKEN_TYPES.Boolean = "Boolean", AST_TOKEN_TYPES.Identifier = "Identifier", AST_TOKEN_TYPES.JSXIdentifier = "JSXIdentifier", AST_TOKEN_TYPES.PrivateIdentifier = "PrivateIdentifier", AST_TOKEN_TYPES.JSXText = "JSXText", AST_TOKEN_TYPES.Keyword = "Keyword", AST_TOKEN_TYPES.Null = "Null", AST_TOKEN_TYPES.Numeric = "Numeric", AST_TOKEN_TYPES.Punctuator = "Punctuator", AST_TOKEN_TYPES.RegularExpression = "RegularExpression", AST_TOKEN_TYPES.String = "String", AST_TOKEN_TYPES.Template = "Template", AST_TOKEN_TYPES.Block = "Block", AST_TOKEN_TYPES.Line = "Line";
	})(AST_TOKEN_TYPES || (exports.AST_TOKEN_TYPES = AST_TOKEN_TYPES = {}));
})), require_lib$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
})), require_parser_options = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
})), require_ts_estree = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k);
		var desc = Object.getOwnPropertyDescriptor(m, k);
		(!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
			enumerable: !0,
			get: function() {
				return m[k];
			}
		}), Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k), o[k2] = m[k];
	})), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: !0,
			value: v
		});
	}) : function(o, v) {
		o.default = v;
	}), __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			return ownKeys = Object.getOwnPropertyNames || function(o) {
				var ar = [];
				for (var k in o) Object.prototype.hasOwnProperty.call(o, k) && (ar[ar.length] = k);
				return ar;
			}, ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) k[i] !== "default" && __createBinding(result, mod, k[i]);
			return __setModuleDefault(result, mod), result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TSESTree = void 0, exports.TSESTree = __importStar(require_ast_spec());
})), require_dist$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k);
		var desc = Object.getOwnPropertyDescriptor(m, k);
		(!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
			enumerable: !0,
			get: function() {
				return m[k];
			}
		}), Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k), o[k2] = m[k];
	})), __exportStar = exports && exports.__exportStar || function(m, exports$5) {
		for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports$5, p) && __createBinding(exports$5, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.AST_TOKEN_TYPES = exports.AST_NODE_TYPES = void 0;
	var ast_spec_1 = require_ast_spec();
	Object.defineProperty(exports, "AST_NODE_TYPES", {
		enumerable: !0,
		get: function() {
			return ast_spec_1.AST_NODE_TYPES;
		}
	}), Object.defineProperty(exports, "AST_TOKEN_TYPES", {
		enumerable: !0,
		get: function() {
			return ast_spec_1.AST_TOKEN_TYPES;
		}
	}), __exportStar(require_lib$2(), exports), __exportStar(require_parser_options(), exports), __exportStar(require_ts_estree(), exports);
})), require_assert$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.assert = assert;
	function assert(value, message) {
		if (value == null) throw Error(message);
	}
})), require_ID = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.createIdGenerator = createIdGenerator, exports.resetIds = resetIds;
	let ID_CACHE = /* @__PURE__ */ new Map(), NEXT_KEY = 0;
	function createIdGenerator() {
		let key = NEXT_KEY += 1;
		return ID_CACHE.set(key, 0), () => {
			let next = (ID_CACHE.get(key) ?? 0) + 1;
			return ID_CACHE.set(key, next), next;
		};
	}
	function resetIds() {
		ID_CACHE.clear();
	}
})), require_DefinitionBase = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.DefinitionBase = void 0;
	let generator = (0, require_ID().createIdGenerator)();
	var DefinitionBase = class {
		$id = generator();
		type;
		name;
		node;
		parent;
		constructor(type, name, node, parent) {
			this.type = type, this.name = name, this.node = node, this.parent = parent;
		}
	};
	exports.DefinitionBase = DefinitionBase;
})), require_DefinitionType = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.DefinitionType = void 0;
	var DefinitionType;
	(function(DefinitionType) {
		DefinitionType.CatchClause = "CatchClause", DefinitionType.ClassName = "ClassName", DefinitionType.FunctionName = "FunctionName", DefinitionType.ImplicitGlobalVariable = "ImplicitGlobalVariable", DefinitionType.ImportBinding = "ImportBinding", DefinitionType.Parameter = "Parameter", DefinitionType.TSEnumName = "TSEnumName", DefinitionType.TSEnumMember = "TSEnumMemberName", DefinitionType.TSModuleName = "TSModuleName", DefinitionType.Type = "Type", DefinitionType.Variable = "Variable";
	})(DefinitionType || (exports.DefinitionType = DefinitionType = {}));
})), require_CatchClauseDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.CatchClauseDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var CatchClauseDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !1;
		isVariableDefinition = !0;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.CatchClause, name, node, null);
		}
	};
	exports.CatchClauseDefinition = CatchClauseDefinition;
})), require_ClassNameDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ClassNameDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var ClassNameDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !0;
		isVariableDefinition = !0;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.ClassName, name, node, null);
		}
	};
	exports.ClassNameDefinition = ClassNameDefinition;
})), require_Definition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
})), require_FunctionNameDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.FunctionNameDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var FunctionNameDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !1;
		isVariableDefinition = !0;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.FunctionName, name, node, null);
		}
	};
	exports.FunctionNameDefinition = FunctionNameDefinition;
})), require_ImplicitGlobalVariableDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ImplicitGlobalVariableDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var ImplicitGlobalVariableDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !1;
		isVariableDefinition = !0;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.ImplicitGlobalVariable, name, node, null);
		}
	};
	exports.ImplicitGlobalVariableDefinition = ImplicitGlobalVariableDefinition;
})), require_ImportBindingDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ImportBindingDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var ImportBindingDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !0;
		isVariableDefinition = !0;
		constructor(name, node, decl) {
			super(DefinitionType_1.DefinitionType.ImportBinding, name, node, decl);
		}
	};
	exports.ImportBindingDefinition = ImportBindingDefinition;
})), require_ParameterDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ParameterDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var ParameterDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !1;
		isVariableDefinition = !0;
		rest;
		constructor(name, node, rest) {
			super(DefinitionType_1.DefinitionType.Parameter, name, node, null), this.rest = rest;
		}
	};
	exports.ParameterDefinition = ParameterDefinition;
})), require_TSEnumMemberDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TSEnumMemberDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var TSEnumMemberDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !0;
		isVariableDefinition = !0;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.TSEnumMember, name, node, null);
		}
	};
	exports.TSEnumMemberDefinition = TSEnumMemberDefinition;
})), require_TSEnumNameDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TSEnumNameDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var TSEnumNameDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !0;
		isVariableDefinition = !0;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.TSEnumName, name, node, null);
		}
	};
	exports.TSEnumNameDefinition = TSEnumNameDefinition;
})), require_TSModuleNameDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TSModuleNameDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var TSModuleNameDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !0;
		isVariableDefinition = !0;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.TSModuleName, name, node, null);
		}
	};
	exports.TSModuleNameDefinition = TSModuleNameDefinition;
})), require_TypeDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TypeDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var TypeDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !0;
		isVariableDefinition = !1;
		constructor(name, node) {
			super(DefinitionType_1.DefinitionType.Type, name, node, null);
		}
	};
	exports.TypeDefinition = TypeDefinition;
})), require_VariableDefinition = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.VariableDefinition = void 0;
	let DefinitionBase_1 = require_DefinitionBase(), DefinitionType_1 = require_DefinitionType();
	var VariableDefinition = class extends DefinitionBase_1.DefinitionBase {
		isTypeDefinition = !1;
		isVariableDefinition = !0;
		constructor(name, node, decl) {
			super(DefinitionType_1.DefinitionType.Variable, name, node, decl);
		}
	};
	exports.VariableDefinition = VariableDefinition;
})), require_definition = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k);
		var desc = Object.getOwnPropertyDescriptor(m, k);
		(!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
			enumerable: !0,
			get: function() {
				return m[k];
			}
		}), Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k), o[k2] = m[k];
	})), __exportStar = exports && exports.__exportStar || function(m, exports$4) {
		for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports$4, p) && __createBinding(exports$4, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: !0 }), __exportStar(require_CatchClauseDefinition(), exports), __exportStar(require_ClassNameDefinition(), exports), __exportStar(require_Definition(), exports), __exportStar(require_DefinitionType(), exports), __exportStar(require_FunctionNameDefinition(), exports), __exportStar(require_ImplicitGlobalVariableDefinition(), exports), __exportStar(require_ImportBindingDefinition(), exports), __exportStar(require_ParameterDefinition(), exports), __exportStar(require_TSEnumMemberDefinition(), exports), __exportStar(require_TSEnumNameDefinition(), exports), __exportStar(require_TSModuleNameDefinition(), exports), __exportStar(require_TypeDefinition(), exports), __exportStar(require_VariableDefinition(), exports);
})), require_base_config = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TYPE_VALUE = exports.VALUE = exports.TYPE = void 0, exports.TYPE = Object.freeze({
		eslintImplicitGlobalSetting: "readonly",
		isTypeVariable: !0,
		isValueVariable: !1
	}), exports.VALUE = Object.freeze({
		eslintImplicitGlobalSetting: "readonly",
		isTypeVariable: !1,
		isValueVariable: !0
	}), exports.TYPE_VALUE = Object.freeze({
		eslintImplicitGlobalSetting: "readonly",
		isTypeVariable: !0,
		isValueVariable: !0
	});
})), require_decorators = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decorators = void 0;
	let base_config_1 = require_base_config();
	exports.decorators = {
		libs: [],
		variables: [
			["ClassMemberDecoratorContext", base_config_1.TYPE],
			["DecoratorContext", base_config_1.TYPE],
			["DecoratorMetadataObject", base_config_1.TYPE],
			["DecoratorMetadata", base_config_1.TYPE],
			["ClassDecoratorContext", base_config_1.TYPE],
			["ClassMethodDecoratorContext", base_config_1.TYPE],
			["ClassGetterDecoratorContext", base_config_1.TYPE],
			["ClassSetterDecoratorContext", base_config_1.TYPE],
			["ClassAccessorDecoratorContext", base_config_1.TYPE],
			["ClassAccessorDecoratorTarget", base_config_1.TYPE],
			["ClassAccessorDecoratorResult", base_config_1.TYPE],
			["ClassFieldDecoratorContext", base_config_1.TYPE]
		]
	};
})), require_decorators_legacy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decorators_legacy = void 0;
	let base_config_1 = require_base_config();
	exports.decorators_legacy = {
		libs: [],
		variables: [
			["ClassDecorator", base_config_1.TYPE],
			["PropertyDecorator", base_config_1.TYPE],
			["MethodDecorator", base_config_1.TYPE],
			["ParameterDecorator", base_config_1.TYPE]
		]
	};
})), require_dom = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.dom = void 0;
	let base_config_1 = require_base_config();
	exports.dom = {
		libs: [],
		variables: [
			["AddEventListenerOptions", base_config_1.TYPE],
			["AddressErrors", base_config_1.TYPE],
			["AesCbcParams", base_config_1.TYPE],
			["AesCtrParams", base_config_1.TYPE],
			["AesDerivedKeyParams", base_config_1.TYPE],
			["AesGcmParams", base_config_1.TYPE],
			["AesKeyAlgorithm", base_config_1.TYPE],
			["AesKeyGenParams", base_config_1.TYPE],
			["Algorithm", base_config_1.TYPE],
			["AnalyserOptions", base_config_1.TYPE],
			["AnimationEventInit", base_config_1.TYPE],
			["AnimationPlaybackEventInit", base_config_1.TYPE],
			["AssignedNodesOptions", base_config_1.TYPE],
			["AudioBufferOptions", base_config_1.TYPE],
			["AudioBufferSourceOptions", base_config_1.TYPE],
			["AudioConfiguration", base_config_1.TYPE],
			["AudioContextOptions", base_config_1.TYPE],
			["AudioDataCopyToOptions", base_config_1.TYPE],
			["AudioDataInit", base_config_1.TYPE],
			["AudioDecoderConfig", base_config_1.TYPE],
			["AudioDecoderInit", base_config_1.TYPE],
			["AudioDecoderSupport", base_config_1.TYPE],
			["AudioEncoderConfig", base_config_1.TYPE],
			["AudioEncoderInit", base_config_1.TYPE],
			["AudioEncoderSupport", base_config_1.TYPE],
			["AudioNodeOptions", base_config_1.TYPE],
			["AudioProcessingEventInit", base_config_1.TYPE],
			["AudioTimestamp", base_config_1.TYPE],
			["AudioWorkletNodeOptions", base_config_1.TYPE],
			["AuthenticationExtensionsClientInputs", base_config_1.TYPE],
			["AuthenticationExtensionsClientInputsJSON", base_config_1.TYPE],
			["AuthenticationExtensionsClientOutputs", base_config_1.TYPE],
			["AuthenticationExtensionsLargeBlobInputs", base_config_1.TYPE],
			["AuthenticationExtensionsLargeBlobInputsJSON", base_config_1.TYPE],
			["AuthenticationExtensionsLargeBlobOutputs", base_config_1.TYPE],
			["AuthenticationExtensionsPRFInputs", base_config_1.TYPE],
			["AuthenticationExtensionsPRFInputsJSON", base_config_1.TYPE],
			["AuthenticationExtensionsPRFOutputs", base_config_1.TYPE],
			["AuthenticationExtensionsPRFValues", base_config_1.TYPE],
			["AuthenticationExtensionsPRFValuesJSON", base_config_1.TYPE],
			["AuthenticatorSelectionCriteria", base_config_1.TYPE],
			["AvcEncoderConfig", base_config_1.TYPE],
			["BiquadFilterOptions", base_config_1.TYPE],
			["BlobEventInit", base_config_1.TYPE],
			["BlobPropertyBag", base_config_1.TYPE],
			["CSSMatrixComponentOptions", base_config_1.TYPE],
			["CSSNumericType", base_config_1.TYPE],
			["CSSStyleSheetInit", base_config_1.TYPE],
			["CacheQueryOptions", base_config_1.TYPE],
			["CanvasRenderingContext2DSettings", base_config_1.TYPE],
			["CaretPositionFromPointOptions", base_config_1.TYPE],
			["ChannelMergerOptions", base_config_1.TYPE],
			["ChannelSplitterOptions", base_config_1.TYPE],
			["CheckVisibilityOptions", base_config_1.TYPE],
			["ClientQueryOptions", base_config_1.TYPE],
			["ClipboardEventInit", base_config_1.TYPE],
			["ClipboardItemOptions", base_config_1.TYPE],
			["CloseEventInit", base_config_1.TYPE],
			["CompositionEventInit", base_config_1.TYPE],
			["ComputedEffectTiming", base_config_1.TYPE],
			["ComputedKeyframe", base_config_1.TYPE],
			["ConstantSourceOptions", base_config_1.TYPE],
			["ConstrainBooleanParameters", base_config_1.TYPE],
			["ConstrainDOMStringParameters", base_config_1.TYPE],
			["ConstrainDoubleRange", base_config_1.TYPE],
			["ConstrainULongRange", base_config_1.TYPE],
			["ContentVisibilityAutoStateChangeEventInit", base_config_1.TYPE],
			["ConvolverOptions", base_config_1.TYPE],
			["CookieChangeEventInit", base_config_1.TYPE],
			["CookieInit", base_config_1.TYPE],
			["CookieListItem", base_config_1.TYPE],
			["CookieStoreDeleteOptions", base_config_1.TYPE],
			["CookieStoreGetOptions", base_config_1.TYPE],
			["CredentialCreationOptions", base_config_1.TYPE],
			["CredentialPropertiesOutput", base_config_1.TYPE],
			["CredentialRequestOptions", base_config_1.TYPE],
			["CryptoKeyPair", base_config_1.TYPE],
			["CustomEventInit", base_config_1.TYPE],
			["DOMMatrix2DInit", base_config_1.TYPE],
			["DOMMatrixInit", base_config_1.TYPE],
			["DOMPointInit", base_config_1.TYPE],
			["DOMQuadInit", base_config_1.TYPE],
			["DOMRectInit", base_config_1.TYPE],
			["DelayOptions", base_config_1.TYPE],
			["DeviceMotionEventAccelerationInit", base_config_1.TYPE],
			["DeviceMotionEventInit", base_config_1.TYPE],
			["DeviceMotionEventRotationRateInit", base_config_1.TYPE],
			["DeviceOrientationEventInit", base_config_1.TYPE],
			["DisplayMediaStreamOptions", base_config_1.TYPE],
			["DocumentTimelineOptions", base_config_1.TYPE],
			["DoubleRange", base_config_1.TYPE],
			["DragEventInit", base_config_1.TYPE],
			["DynamicsCompressorOptions", base_config_1.TYPE],
			["EcKeyAlgorithm", base_config_1.TYPE],
			["EcKeyGenParams", base_config_1.TYPE],
			["EcKeyImportParams", base_config_1.TYPE],
			["EcdhKeyDeriveParams", base_config_1.TYPE],
			["EcdsaParams", base_config_1.TYPE],
			["EffectTiming", base_config_1.TYPE],
			["ElementCreationOptions", base_config_1.TYPE],
			["ElementDefinitionOptions", base_config_1.TYPE],
			["EncodedAudioChunkInit", base_config_1.TYPE],
			["EncodedAudioChunkMetadata", base_config_1.TYPE],
			["EncodedVideoChunkInit", base_config_1.TYPE],
			["EncodedVideoChunkMetadata", base_config_1.TYPE],
			["ErrorEventInit", base_config_1.TYPE],
			["EventInit", base_config_1.TYPE],
			["EventListenerOptions", base_config_1.TYPE],
			["EventModifierInit", base_config_1.TYPE],
			["EventSourceInit", base_config_1.TYPE],
			["FilePropertyBag", base_config_1.TYPE],
			["FileSystemCreateWritableOptions", base_config_1.TYPE],
			["FileSystemFlags", base_config_1.TYPE],
			["FileSystemGetDirectoryOptions", base_config_1.TYPE],
			["FileSystemGetFileOptions", base_config_1.TYPE],
			["FileSystemRemoveOptions", base_config_1.TYPE],
			["FocusEventInit", base_config_1.TYPE],
			["FocusOptions", base_config_1.TYPE],
			["FontFaceDescriptors", base_config_1.TYPE],
			["FontFaceSetLoadEventInit", base_config_1.TYPE],
			["FormDataEventInit", base_config_1.TYPE],
			["FullscreenOptions", base_config_1.TYPE],
			["GainOptions", base_config_1.TYPE],
			["GamepadEffectParameters", base_config_1.TYPE],
			["GamepadEventInit", base_config_1.TYPE],
			["GetAnimationsOptions", base_config_1.TYPE],
			["GetComposedRangesOptions", base_config_1.TYPE],
			["GetHTMLOptions", base_config_1.TYPE],
			["GetNotificationOptions", base_config_1.TYPE],
			["GetRootNodeOptions", base_config_1.TYPE],
			["HashChangeEventInit", base_config_1.TYPE],
			["HkdfParams", base_config_1.TYPE],
			["HmacImportParams", base_config_1.TYPE],
			["HmacKeyAlgorithm", base_config_1.TYPE],
			["HmacKeyGenParams", base_config_1.TYPE],
			["IDBDatabaseInfo", base_config_1.TYPE],
			["IDBIndexParameters", base_config_1.TYPE],
			["IDBObjectStoreParameters", base_config_1.TYPE],
			["IDBTransactionOptions", base_config_1.TYPE],
			["IDBVersionChangeEventInit", base_config_1.TYPE],
			["IIRFilterOptions", base_config_1.TYPE],
			["IdleRequestOptions", base_config_1.TYPE],
			["ImageBitmapOptions", base_config_1.TYPE],
			["ImageBitmapRenderingContextSettings", base_config_1.TYPE],
			["ImageDataSettings", base_config_1.TYPE],
			["ImageDecodeOptions", base_config_1.TYPE],
			["ImageDecodeResult", base_config_1.TYPE],
			["ImageDecoderInit", base_config_1.TYPE],
			["ImageEncodeOptions", base_config_1.TYPE],
			["ImportNodeOptions", base_config_1.TYPE],
			["InputEventInit", base_config_1.TYPE],
			["IntersectionObserverInit", base_config_1.TYPE],
			["JsonWebKey", base_config_1.TYPE],
			["KeyAlgorithm", base_config_1.TYPE],
			["KeySystemTrackConfiguration", base_config_1.TYPE],
			["KeyboardEventInit", base_config_1.TYPE],
			["Keyframe", base_config_1.TYPE],
			["KeyframeAnimationOptions", base_config_1.TYPE],
			["KeyframeEffectOptions", base_config_1.TYPE],
			["LockInfo", base_config_1.TYPE],
			["LockManagerSnapshot", base_config_1.TYPE],
			["LockOptions", base_config_1.TYPE],
			["MIDIConnectionEventInit", base_config_1.TYPE],
			["MIDIMessageEventInit", base_config_1.TYPE],
			["MIDIOptions", base_config_1.TYPE],
			["MediaCapabilitiesDecodingInfo", base_config_1.TYPE],
			["MediaCapabilitiesEncodingInfo", base_config_1.TYPE],
			["MediaCapabilitiesInfo", base_config_1.TYPE],
			["MediaCapabilitiesKeySystemConfiguration", base_config_1.TYPE],
			["MediaConfiguration", base_config_1.TYPE],
			["MediaDecodingConfiguration", base_config_1.TYPE],
			["MediaElementAudioSourceOptions", base_config_1.TYPE],
			["MediaEncodingConfiguration", base_config_1.TYPE],
			["MediaEncryptedEventInit", base_config_1.TYPE],
			["MediaImage", base_config_1.TYPE],
			["MediaKeyMessageEventInit", base_config_1.TYPE],
			["MediaKeySystemConfiguration", base_config_1.TYPE],
			["MediaKeySystemMediaCapability", base_config_1.TYPE],
			["MediaKeysPolicy", base_config_1.TYPE],
			["MediaMetadataInit", base_config_1.TYPE],
			["MediaPositionState", base_config_1.TYPE],
			["MediaQueryListEventInit", base_config_1.TYPE],
			["MediaRecorderOptions", base_config_1.TYPE],
			["MediaSessionActionDetails", base_config_1.TYPE],
			["MediaSettingsRange", base_config_1.TYPE],
			["MediaStreamAudioSourceOptions", base_config_1.TYPE],
			["MediaStreamConstraints", base_config_1.TYPE],
			["MediaStreamTrackEventInit", base_config_1.TYPE],
			["MediaTrackCapabilities", base_config_1.TYPE],
			["MediaTrackConstraintSet", base_config_1.TYPE],
			["MediaTrackConstraints", base_config_1.TYPE],
			["MediaTrackSettings", base_config_1.TYPE],
			["MediaTrackSupportedConstraints", base_config_1.TYPE],
			["MessageEventInit", base_config_1.TYPE],
			["MouseEventInit", base_config_1.TYPE],
			["MultiCacheQueryOptions", base_config_1.TYPE],
			["MutationObserverInit", base_config_1.TYPE],
			["NavigationPreloadState", base_config_1.TYPE],
			["NotificationOptions", base_config_1.TYPE],
			["OfflineAudioCompletionEventInit", base_config_1.TYPE],
			["OfflineAudioContextOptions", base_config_1.TYPE],
			["OptionalEffectTiming", base_config_1.TYPE],
			["OpusEncoderConfig", base_config_1.TYPE],
			["OscillatorOptions", base_config_1.TYPE],
			["PageRevealEventInit", base_config_1.TYPE],
			["PageSwapEventInit", base_config_1.TYPE],
			["PageTransitionEventInit", base_config_1.TYPE],
			["PannerOptions", base_config_1.TYPE],
			["PayerErrors", base_config_1.TYPE],
			["PaymentCurrencyAmount", base_config_1.TYPE],
			["PaymentDetailsBase", base_config_1.TYPE],
			["PaymentDetailsInit", base_config_1.TYPE],
			["PaymentDetailsModifier", base_config_1.TYPE],
			["PaymentDetailsUpdate", base_config_1.TYPE],
			["PaymentItem", base_config_1.TYPE],
			["PaymentMethodChangeEventInit", base_config_1.TYPE],
			["PaymentMethodData", base_config_1.TYPE],
			["PaymentOptions", base_config_1.TYPE],
			["PaymentRequestUpdateEventInit", base_config_1.TYPE],
			["PaymentShippingOption", base_config_1.TYPE],
			["PaymentValidationErrors", base_config_1.TYPE],
			["Pbkdf2Params", base_config_1.TYPE],
			["PerformanceMarkOptions", base_config_1.TYPE],
			["PerformanceMeasureOptions", base_config_1.TYPE],
			["PerformanceObserverInit", base_config_1.TYPE],
			["PeriodicWaveConstraints", base_config_1.TYPE],
			["PeriodicWaveOptions", base_config_1.TYPE],
			["PermissionDescriptor", base_config_1.TYPE],
			["PhotoCapabilities", base_config_1.TYPE],
			["PhotoSettings", base_config_1.TYPE],
			["PictureInPictureEventInit", base_config_1.TYPE],
			["PlaneLayout", base_config_1.TYPE],
			["PointerEventInit", base_config_1.TYPE],
			["PointerLockOptions", base_config_1.TYPE],
			["PopStateEventInit", base_config_1.TYPE],
			["PositionOptions", base_config_1.TYPE],
			["ProgressEventInit", base_config_1.TYPE],
			["PromiseRejectionEventInit", base_config_1.TYPE],
			["PropertyDefinition", base_config_1.TYPE],
			["PropertyIndexedKeyframes", base_config_1.TYPE],
			["PublicKeyCredentialCreationOptions", base_config_1.TYPE],
			["PublicKeyCredentialCreationOptionsJSON", base_config_1.TYPE],
			["PublicKeyCredentialDescriptor", base_config_1.TYPE],
			["PublicKeyCredentialDescriptorJSON", base_config_1.TYPE],
			["PublicKeyCredentialEntity", base_config_1.TYPE],
			["PublicKeyCredentialParameters", base_config_1.TYPE],
			["PublicKeyCredentialRequestOptions", base_config_1.TYPE],
			["PublicKeyCredentialRequestOptionsJSON", base_config_1.TYPE],
			["PublicKeyCredentialRpEntity", base_config_1.TYPE],
			["PublicKeyCredentialUserEntity", base_config_1.TYPE],
			["PublicKeyCredentialUserEntityJSON", base_config_1.TYPE],
			["PushSubscriptionJSON", base_config_1.TYPE],
			["PushSubscriptionOptionsInit", base_config_1.TYPE],
			["QueuingStrategy", base_config_1.TYPE],
			["QueuingStrategyInit", base_config_1.TYPE],
			["RTCAnswerOptions", base_config_1.TYPE],
			["RTCCertificateExpiration", base_config_1.TYPE],
			["RTCConfiguration", base_config_1.TYPE],
			["RTCDTMFToneChangeEventInit", base_config_1.TYPE],
			["RTCDataChannelEventInit", base_config_1.TYPE],
			["RTCDataChannelInit", base_config_1.TYPE],
			["RTCDtlsFingerprint", base_config_1.TYPE],
			["RTCEncodedAudioFrameMetadata", base_config_1.TYPE],
			["RTCEncodedFrameMetadata", base_config_1.TYPE],
			["RTCEncodedVideoFrameMetadata", base_config_1.TYPE],
			["RTCErrorEventInit", base_config_1.TYPE],
			["RTCErrorInit", base_config_1.TYPE],
			["RTCIceCandidateInit", base_config_1.TYPE],
			["RTCIceCandidatePairStats", base_config_1.TYPE],
			["RTCIceServer", base_config_1.TYPE],
			["RTCInboundRtpStreamStats", base_config_1.TYPE],
			["RTCLocalIceCandidateInit", base_config_1.TYPE],
			["RTCLocalSessionDescriptionInit", base_config_1.TYPE],
			["RTCOfferAnswerOptions", base_config_1.TYPE],
			["RTCOfferOptions", base_config_1.TYPE],
			["RTCOutboundRtpStreamStats", base_config_1.TYPE],
			["RTCPeerConnectionIceErrorEventInit", base_config_1.TYPE],
			["RTCPeerConnectionIceEventInit", base_config_1.TYPE],
			["RTCReceivedRtpStreamStats", base_config_1.TYPE],
			["RTCRtcpParameters", base_config_1.TYPE],
			["RTCRtpCapabilities", base_config_1.TYPE],
			["RTCRtpCodec", base_config_1.TYPE],
			["RTCRtpCodecParameters", base_config_1.TYPE],
			["RTCRtpCodingParameters", base_config_1.TYPE],
			["RTCRtpContributingSource", base_config_1.TYPE],
			["RTCRtpEncodingParameters", base_config_1.TYPE],
			["RTCRtpHeaderExtensionCapability", base_config_1.TYPE],
			["RTCRtpHeaderExtensionParameters", base_config_1.TYPE],
			["RTCRtpParameters", base_config_1.TYPE],
			["RTCRtpReceiveParameters", base_config_1.TYPE],
			["RTCRtpSendParameters", base_config_1.TYPE],
			["RTCRtpStreamStats", base_config_1.TYPE],
			["RTCRtpSynchronizationSource", base_config_1.TYPE],
			["RTCRtpTransceiverInit", base_config_1.TYPE],
			["RTCSentRtpStreamStats", base_config_1.TYPE],
			["RTCSessionDescriptionInit", base_config_1.TYPE],
			["RTCSetParameterOptions", base_config_1.TYPE],
			["RTCStats", base_config_1.TYPE],
			["RTCTrackEventInit", base_config_1.TYPE],
			["RTCTransportStats", base_config_1.TYPE],
			["ReadableStreamGetReaderOptions", base_config_1.TYPE],
			["ReadableStreamIteratorOptions", base_config_1.TYPE],
			["ReadableStreamReadDoneResult", base_config_1.TYPE],
			["ReadableStreamReadValueResult", base_config_1.TYPE],
			["ReadableWritablePair", base_config_1.TYPE],
			["RegistrationOptions", base_config_1.TYPE],
			["ReportingObserverOptions", base_config_1.TYPE],
			["RequestInit", base_config_1.TYPE],
			["ResizeObserverOptions", base_config_1.TYPE],
			["ResponseInit", base_config_1.TYPE],
			["RsaHashedImportParams", base_config_1.TYPE],
			["RsaHashedKeyAlgorithm", base_config_1.TYPE],
			["RsaHashedKeyGenParams", base_config_1.TYPE],
			["RsaKeyAlgorithm", base_config_1.TYPE],
			["RsaKeyGenParams", base_config_1.TYPE],
			["RsaOaepParams", base_config_1.TYPE],
			["RsaOtherPrimesInfo", base_config_1.TYPE],
			["RsaPssParams", base_config_1.TYPE],
			["SVGBoundingBoxOptions", base_config_1.TYPE],
			["ScrollIntoViewOptions", base_config_1.TYPE],
			["ScrollOptions", base_config_1.TYPE],
			["ScrollToOptions", base_config_1.TYPE],
			["SecurityPolicyViolationEventInit", base_config_1.TYPE],
			["ShadowRootInit", base_config_1.TYPE],
			["ShareData", base_config_1.TYPE],
			["SpeechSynthesisErrorEventInit", base_config_1.TYPE],
			["SpeechSynthesisEventInit", base_config_1.TYPE],
			["StartViewTransitionOptions", base_config_1.TYPE],
			["StaticRangeInit", base_config_1.TYPE],
			["StereoPannerOptions", base_config_1.TYPE],
			["StorageEstimate", base_config_1.TYPE],
			["StorageEventInit", base_config_1.TYPE],
			["StreamPipeOptions", base_config_1.TYPE],
			["StructuredSerializeOptions", base_config_1.TYPE],
			["SubmitEventInit", base_config_1.TYPE],
			["TextDecodeOptions", base_config_1.TYPE],
			["TextDecoderOptions", base_config_1.TYPE],
			["TextEncoderEncodeIntoResult", base_config_1.TYPE],
			["ToggleEventInit", base_config_1.TYPE],
			["TouchEventInit", base_config_1.TYPE],
			["TouchInit", base_config_1.TYPE],
			["TrackEventInit", base_config_1.TYPE],
			["Transformer", base_config_1.TYPE],
			["TransitionEventInit", base_config_1.TYPE],
			["UIEventInit", base_config_1.TYPE],
			["ULongRange", base_config_1.TYPE],
			["UnderlyingByteSource", base_config_1.TYPE],
			["UnderlyingDefaultSource", base_config_1.TYPE],
			["UnderlyingSink", base_config_1.TYPE],
			["UnderlyingSource", base_config_1.TYPE],
			["ValidityStateFlags", base_config_1.TYPE],
			["VideoColorSpaceInit", base_config_1.TYPE],
			["VideoConfiguration", base_config_1.TYPE],
			["VideoDecoderConfig", base_config_1.TYPE],
			["VideoDecoderInit", base_config_1.TYPE],
			["VideoDecoderSupport", base_config_1.TYPE],
			["VideoEncoderConfig", base_config_1.TYPE],
			["VideoEncoderEncodeOptions", base_config_1.TYPE],
			["VideoEncoderEncodeOptionsForAvc", base_config_1.TYPE],
			["VideoEncoderInit", base_config_1.TYPE],
			["VideoEncoderSupport", base_config_1.TYPE],
			["VideoFrameBufferInit", base_config_1.TYPE],
			["VideoFrameCallbackMetadata", base_config_1.TYPE],
			["VideoFrameCopyToOptions", base_config_1.TYPE],
			["VideoFrameInit", base_config_1.TYPE],
			["WaveShaperOptions", base_config_1.TYPE],
			["WebGLContextAttributes", base_config_1.TYPE],
			["WebGLContextEventInit", base_config_1.TYPE],
			["WebTransportCloseInfo", base_config_1.TYPE],
			["WebTransportErrorOptions", base_config_1.TYPE],
			["WebTransportHash", base_config_1.TYPE],
			["WebTransportOptions", base_config_1.TYPE],
			["WebTransportSendOptions", base_config_1.TYPE],
			["WebTransportSendStreamOptions", base_config_1.TYPE],
			["WheelEventInit", base_config_1.TYPE],
			["WindowPostMessageOptions", base_config_1.TYPE],
			["WorkerOptions", base_config_1.TYPE],
			["WorkletOptions", base_config_1.TYPE],
			["WriteParams", base_config_1.TYPE],
			["NodeFilter", base_config_1.TYPE_VALUE],
			["XPathNSResolver", base_config_1.TYPE],
			["ANGLE_instanced_arrays", base_config_1.TYPE],
			["ARIAMixin", base_config_1.TYPE],
			["AbortController", base_config_1.TYPE_VALUE],
			["AbortSignalEventMap", base_config_1.TYPE],
			["AbortSignal", base_config_1.TYPE_VALUE],
			["AbstractRange", base_config_1.TYPE_VALUE],
			["AbstractWorkerEventMap", base_config_1.TYPE],
			["AbstractWorker", base_config_1.TYPE],
			["AnalyserNode", base_config_1.TYPE_VALUE],
			["Animatable", base_config_1.TYPE],
			["AnimationEventMap", base_config_1.TYPE],
			["Animation", base_config_1.TYPE_VALUE],
			["AnimationEffect", base_config_1.TYPE_VALUE],
			["AnimationEvent", base_config_1.TYPE_VALUE],
			["AnimationFrameProvider", base_config_1.TYPE],
			["AnimationPlaybackEvent", base_config_1.TYPE_VALUE],
			["AnimationTimeline", base_config_1.TYPE_VALUE],
			["Attr", base_config_1.TYPE_VALUE],
			["AudioBuffer", base_config_1.TYPE_VALUE],
			["AudioBufferSourceNode", base_config_1.TYPE_VALUE],
			["AudioContext", base_config_1.TYPE_VALUE],
			["AudioData", base_config_1.TYPE_VALUE],
			["AudioDecoderEventMap", base_config_1.TYPE],
			["AudioDecoder", base_config_1.TYPE_VALUE],
			["AudioDestinationNode", base_config_1.TYPE_VALUE],
			["AudioEncoderEventMap", base_config_1.TYPE],
			["AudioEncoder", base_config_1.TYPE_VALUE],
			["AudioListener", base_config_1.TYPE_VALUE],
			["AudioNode", base_config_1.TYPE_VALUE],
			["AudioParam", base_config_1.TYPE_VALUE],
			["AudioParamMap", base_config_1.TYPE_VALUE],
			["AudioProcessingEvent", base_config_1.TYPE_VALUE],
			["AudioScheduledSourceNodeEventMap", base_config_1.TYPE],
			["AudioScheduledSourceNode", base_config_1.TYPE_VALUE],
			["AudioWorklet", base_config_1.TYPE_VALUE],
			["AudioWorkletNodeEventMap", base_config_1.TYPE],
			["AudioWorkletNode", base_config_1.TYPE_VALUE],
			["AuthenticatorAssertionResponse", base_config_1.TYPE_VALUE],
			["AuthenticatorAttestationResponse", base_config_1.TYPE_VALUE],
			["AuthenticatorResponse", base_config_1.TYPE_VALUE],
			["BarProp", base_config_1.TYPE_VALUE],
			["BaseAudioContextEventMap", base_config_1.TYPE],
			["BaseAudioContext", base_config_1.TYPE_VALUE],
			["BeforeUnloadEvent", base_config_1.TYPE_VALUE],
			["BiquadFilterNode", base_config_1.TYPE_VALUE],
			["Blob", base_config_1.TYPE_VALUE],
			["BlobEvent", base_config_1.TYPE_VALUE],
			["Body", base_config_1.TYPE],
			["BroadcastChannelEventMap", base_config_1.TYPE],
			["BroadcastChannel", base_config_1.TYPE_VALUE],
			["ByteLengthQueuingStrategy", base_config_1.TYPE_VALUE],
			["CDATASection", base_config_1.TYPE_VALUE],
			["CSPViolationReportBody", base_config_1.TYPE_VALUE],
			["CSSAnimation", base_config_1.TYPE_VALUE],
			["CSSConditionRule", base_config_1.TYPE_VALUE],
			["CSSContainerRule", base_config_1.TYPE_VALUE],
			["CSSCounterStyleRule", base_config_1.TYPE_VALUE],
			["CSSFontFaceRule", base_config_1.TYPE_VALUE],
			["CSSFontFeatureValuesRule", base_config_1.TYPE_VALUE],
			["CSSFontPaletteValuesRule", base_config_1.TYPE_VALUE],
			["CSSGroupingRule", base_config_1.TYPE_VALUE],
			["CSSImageValue", base_config_1.TYPE_VALUE],
			["CSSImportRule", base_config_1.TYPE_VALUE],
			["CSSKeyframeRule", base_config_1.TYPE_VALUE],
			["CSSKeyframesRule", base_config_1.TYPE_VALUE],
			["CSSKeywordValue", base_config_1.TYPE_VALUE],
			["CSSLayerBlockRule", base_config_1.TYPE_VALUE],
			["CSSLayerStatementRule", base_config_1.TYPE_VALUE],
			["CSSMathClamp", base_config_1.TYPE_VALUE],
			["CSSMathInvert", base_config_1.TYPE_VALUE],
			["CSSMathMax", base_config_1.TYPE_VALUE],
			["CSSMathMin", base_config_1.TYPE_VALUE],
			["CSSMathNegate", base_config_1.TYPE_VALUE],
			["CSSMathProduct", base_config_1.TYPE_VALUE],
			["CSSMathSum", base_config_1.TYPE_VALUE],
			["CSSMathValue", base_config_1.TYPE_VALUE],
			["CSSMatrixComponent", base_config_1.TYPE_VALUE],
			["CSSMediaRule", base_config_1.TYPE_VALUE],
			["CSSNamespaceRule", base_config_1.TYPE_VALUE],
			["CSSNestedDeclarations", base_config_1.TYPE_VALUE],
			["CSSNumericArray", base_config_1.TYPE_VALUE],
			["CSSNumericValue", base_config_1.TYPE_VALUE],
			["CSSPageRule", base_config_1.TYPE_VALUE],
			["CSSPerspective", base_config_1.TYPE_VALUE],
			["CSSPropertyRule", base_config_1.TYPE_VALUE],
			["CSSRotate", base_config_1.TYPE_VALUE],
			["CSSRule", base_config_1.TYPE_VALUE],
			["CSSRuleList", base_config_1.TYPE_VALUE],
			["CSSScale", base_config_1.TYPE_VALUE],
			["CSSScopeRule", base_config_1.TYPE_VALUE],
			["CSSSkew", base_config_1.TYPE_VALUE],
			["CSSSkewX", base_config_1.TYPE_VALUE],
			["CSSSkewY", base_config_1.TYPE_VALUE],
			["CSSStartingStyleRule", base_config_1.TYPE_VALUE],
			["CSSStyleDeclaration", base_config_1.TYPE_VALUE],
			["CSSStyleRule", base_config_1.TYPE_VALUE],
			["CSSStyleSheet", base_config_1.TYPE_VALUE],
			["CSSStyleValue", base_config_1.TYPE_VALUE],
			["CSSSupportsRule", base_config_1.TYPE_VALUE],
			["CSSTransformComponent", base_config_1.TYPE_VALUE],
			["CSSTransformValue", base_config_1.TYPE_VALUE],
			["CSSTransition", base_config_1.TYPE_VALUE],
			["CSSTranslate", base_config_1.TYPE_VALUE],
			["CSSUnitValue", base_config_1.TYPE_VALUE],
			["CSSUnparsedValue", base_config_1.TYPE_VALUE],
			["CSSVariableReferenceValue", base_config_1.TYPE_VALUE],
			["CSSViewTransitionRule", base_config_1.TYPE_VALUE],
			["Cache", base_config_1.TYPE_VALUE],
			["CacheStorage", base_config_1.TYPE_VALUE],
			["CanvasCaptureMediaStreamTrack", base_config_1.TYPE_VALUE],
			["CanvasCompositing", base_config_1.TYPE],
			["CanvasDrawImage", base_config_1.TYPE],
			["CanvasDrawPath", base_config_1.TYPE],
			["CanvasFillStrokeStyles", base_config_1.TYPE],
			["CanvasFilters", base_config_1.TYPE],
			["CanvasGradient", base_config_1.TYPE_VALUE],
			["CanvasImageData", base_config_1.TYPE],
			["CanvasImageSmoothing", base_config_1.TYPE],
			["CanvasPath", base_config_1.TYPE],
			["CanvasPathDrawingStyles", base_config_1.TYPE],
			["CanvasPattern", base_config_1.TYPE_VALUE],
			["CanvasRect", base_config_1.TYPE],
			["CanvasRenderingContext2D", base_config_1.TYPE_VALUE],
			["CanvasSettings", base_config_1.TYPE],
			["CanvasShadowStyles", base_config_1.TYPE],
			["CanvasState", base_config_1.TYPE],
			["CanvasText", base_config_1.TYPE],
			["CanvasTextDrawingStyles", base_config_1.TYPE],
			["CanvasTransform", base_config_1.TYPE],
			["CanvasUserInterface", base_config_1.TYPE],
			["CaretPosition", base_config_1.TYPE_VALUE],
			["ChannelMergerNode", base_config_1.TYPE_VALUE],
			["ChannelSplitterNode", base_config_1.TYPE_VALUE],
			["CharacterData", base_config_1.TYPE_VALUE],
			["ChildNode", base_config_1.TYPE],
			["ClientRect", base_config_1.TYPE],
			["Clipboard", base_config_1.TYPE_VALUE],
			["ClipboardEvent", base_config_1.TYPE_VALUE],
			["ClipboardItem", base_config_1.TYPE_VALUE],
			["CloseEvent", base_config_1.TYPE_VALUE],
			["Comment", base_config_1.TYPE_VALUE],
			["CompositionEvent", base_config_1.TYPE_VALUE],
			["CompressionStream", base_config_1.TYPE_VALUE],
			["ConstantSourceNode", base_config_1.TYPE_VALUE],
			["ContentVisibilityAutoStateChangeEvent", base_config_1.TYPE_VALUE],
			["ConvolverNode", base_config_1.TYPE_VALUE],
			["CookieChangeEvent", base_config_1.TYPE_VALUE],
			["CookieStoreEventMap", base_config_1.TYPE],
			["CookieStore", base_config_1.TYPE_VALUE],
			["CookieStoreManager", base_config_1.TYPE_VALUE],
			["CountQueuingStrategy", base_config_1.TYPE_VALUE],
			["Credential", base_config_1.TYPE_VALUE],
			["CredentialsContainer", base_config_1.TYPE_VALUE],
			["Crypto", base_config_1.TYPE_VALUE],
			["CryptoKey", base_config_1.TYPE_VALUE],
			["CustomElementRegistry", base_config_1.TYPE_VALUE],
			["CustomEvent", base_config_1.TYPE_VALUE],
			["CustomStateSet", base_config_1.TYPE_VALUE],
			["DOMException", base_config_1.TYPE_VALUE],
			["DOMImplementation", base_config_1.TYPE_VALUE],
			["DOMMatrix", base_config_1.TYPE_VALUE],
			["SVGMatrix", base_config_1.TYPE_VALUE],
			["WebKitCSSMatrix", base_config_1.TYPE_VALUE],
			["DOMMatrixReadOnly", base_config_1.TYPE_VALUE],
			["DOMParser", base_config_1.TYPE_VALUE],
			["DOMPoint", base_config_1.TYPE_VALUE],
			["SVGPoint", base_config_1.TYPE_VALUE],
			["DOMPointReadOnly", base_config_1.TYPE_VALUE],
			["DOMQuad", base_config_1.TYPE_VALUE],
			["DOMRect", base_config_1.TYPE_VALUE],
			["SVGRect", base_config_1.TYPE_VALUE],
			["DOMRectList", base_config_1.TYPE_VALUE],
			["DOMRectReadOnly", base_config_1.TYPE_VALUE],
			["DOMStringList", base_config_1.TYPE_VALUE],
			["DOMStringMap", base_config_1.TYPE_VALUE],
			["DOMTokenList", base_config_1.TYPE_VALUE],
			["DataTransfer", base_config_1.TYPE_VALUE],
			["DataTransferItem", base_config_1.TYPE_VALUE],
			["DataTransferItemList", base_config_1.TYPE_VALUE],
			["DecompressionStream", base_config_1.TYPE_VALUE],
			["DelayNode", base_config_1.TYPE_VALUE],
			["DeviceMotionEvent", base_config_1.TYPE_VALUE],
			["DeviceMotionEventAcceleration", base_config_1.TYPE],
			["DeviceMotionEventRotationRate", base_config_1.TYPE],
			["DeviceOrientationEvent", base_config_1.TYPE_VALUE],
			["DocumentEventMap", base_config_1.TYPE],
			["Document", base_config_1.TYPE_VALUE],
			["DocumentFragment", base_config_1.TYPE_VALUE],
			["DocumentOrShadowRoot", base_config_1.TYPE],
			["DocumentTimeline", base_config_1.TYPE_VALUE],
			["DocumentType", base_config_1.TYPE_VALUE],
			["DragEvent", base_config_1.TYPE_VALUE],
			["DynamicsCompressorNode", base_config_1.TYPE_VALUE],
			["EXT_blend_minmax", base_config_1.TYPE],
			["EXT_color_buffer_float", base_config_1.TYPE],
			["EXT_color_buffer_half_float", base_config_1.TYPE],
			["EXT_float_blend", base_config_1.TYPE],
			["EXT_frag_depth", base_config_1.TYPE],
			["EXT_sRGB", base_config_1.TYPE],
			["EXT_shader_texture_lod", base_config_1.TYPE],
			["EXT_texture_compression_bptc", base_config_1.TYPE],
			["EXT_texture_compression_rgtc", base_config_1.TYPE],
			["EXT_texture_filter_anisotropic", base_config_1.TYPE],
			["EXT_texture_norm16", base_config_1.TYPE],
			["ElementEventMap", base_config_1.TYPE],
			["Element", base_config_1.TYPE_VALUE],
			["ElementCSSInlineStyle", base_config_1.TYPE],
			["ElementContentEditable", base_config_1.TYPE],
			["ElementInternals", base_config_1.TYPE_VALUE],
			["EncodedAudioChunk", base_config_1.TYPE_VALUE],
			["EncodedVideoChunk", base_config_1.TYPE_VALUE],
			["ErrorEvent", base_config_1.TYPE_VALUE],
			["Event", base_config_1.TYPE_VALUE],
			["EventCounts", base_config_1.TYPE_VALUE],
			["EventListener", base_config_1.TYPE],
			["EventListenerObject", base_config_1.TYPE],
			["EventSourceEventMap", base_config_1.TYPE],
			["EventSource", base_config_1.TYPE_VALUE],
			["EventTarget", base_config_1.TYPE_VALUE],
			["External", base_config_1.TYPE_VALUE],
			["File", base_config_1.TYPE_VALUE],
			["FileList", base_config_1.TYPE_VALUE],
			["FileReaderEventMap", base_config_1.TYPE],
			["FileReader", base_config_1.TYPE_VALUE],
			["FileSystem", base_config_1.TYPE_VALUE],
			["FileSystemDirectoryEntry", base_config_1.TYPE_VALUE],
			["FileSystemDirectoryHandle", base_config_1.TYPE_VALUE],
			["FileSystemDirectoryReader", base_config_1.TYPE_VALUE],
			["FileSystemEntry", base_config_1.TYPE_VALUE],
			["FileSystemFileEntry", base_config_1.TYPE_VALUE],
			["FileSystemFileHandle", base_config_1.TYPE_VALUE],
			["FileSystemHandle", base_config_1.TYPE_VALUE],
			["FileSystemWritableFileStream", base_config_1.TYPE_VALUE],
			["FocusEvent", base_config_1.TYPE_VALUE],
			["FontFace", base_config_1.TYPE_VALUE],
			["FontFaceSetEventMap", base_config_1.TYPE],
			["FontFaceSet", base_config_1.TYPE_VALUE],
			["FontFaceSetLoadEvent", base_config_1.TYPE_VALUE],
			["FontFaceSource", base_config_1.TYPE],
			["FormData", base_config_1.TYPE_VALUE],
			["FormDataEvent", base_config_1.TYPE_VALUE],
			["FragmentDirective", base_config_1.TYPE_VALUE],
			["GPUError", base_config_1.TYPE],
			["GainNode", base_config_1.TYPE_VALUE],
			["Gamepad", base_config_1.TYPE_VALUE],
			["GamepadButton", base_config_1.TYPE_VALUE],
			["GamepadEvent", base_config_1.TYPE_VALUE],
			["GamepadHapticActuator", base_config_1.TYPE_VALUE],
			["GenericTransformStream", base_config_1.TYPE],
			["Geolocation", base_config_1.TYPE_VALUE],
			["GeolocationCoordinates", base_config_1.TYPE_VALUE],
			["GeolocationPosition", base_config_1.TYPE_VALUE],
			["GeolocationPositionError", base_config_1.TYPE_VALUE],
			["GlobalEventHandlersEventMap", base_config_1.TYPE],
			["GlobalEventHandlers", base_config_1.TYPE],
			["HTMLAllCollection", base_config_1.TYPE_VALUE],
			["HTMLAnchorElement", base_config_1.TYPE_VALUE],
			["HTMLAreaElement", base_config_1.TYPE_VALUE],
			["HTMLAudioElement", base_config_1.TYPE_VALUE],
			["HTMLBRElement", base_config_1.TYPE_VALUE],
			["HTMLBaseElement", base_config_1.TYPE_VALUE],
			["HTMLBodyElementEventMap", base_config_1.TYPE],
			["HTMLBodyElement", base_config_1.TYPE_VALUE],
			["HTMLButtonElement", base_config_1.TYPE_VALUE],
			["HTMLCanvasElement", base_config_1.TYPE_VALUE],
			["HTMLCollectionBase", base_config_1.TYPE],
			["HTMLCollection", base_config_1.TYPE_VALUE],
			["HTMLCollectionOf", base_config_1.TYPE],
			["HTMLDListElement", base_config_1.TYPE_VALUE],
			["HTMLDataElement", base_config_1.TYPE_VALUE],
			["HTMLDataListElement", base_config_1.TYPE_VALUE],
			["HTMLDetailsElement", base_config_1.TYPE_VALUE],
			["HTMLDialogElement", base_config_1.TYPE_VALUE],
			["HTMLDirectoryElement", base_config_1.TYPE_VALUE],
			["HTMLDivElement", base_config_1.TYPE_VALUE],
			["HTMLDocument", base_config_1.TYPE_VALUE],
			["HTMLElementEventMap", base_config_1.TYPE],
			["HTMLElement", base_config_1.TYPE_VALUE],
			["HTMLEmbedElement", base_config_1.TYPE_VALUE],
			["HTMLFieldSetElement", base_config_1.TYPE_VALUE],
			["HTMLFontElement", base_config_1.TYPE_VALUE],
			["HTMLFormControlsCollection", base_config_1.TYPE_VALUE],
			["HTMLFormElement", base_config_1.TYPE_VALUE],
			["HTMLFrameElement", base_config_1.TYPE_VALUE],
			["HTMLFrameSetElementEventMap", base_config_1.TYPE],
			["HTMLFrameSetElement", base_config_1.TYPE_VALUE],
			["HTMLHRElement", base_config_1.TYPE_VALUE],
			["HTMLHeadElement", base_config_1.TYPE_VALUE],
			["HTMLHeadingElement", base_config_1.TYPE_VALUE],
			["HTMLHtmlElement", base_config_1.TYPE_VALUE],
			["HTMLHyperlinkElementUtils", base_config_1.TYPE],
			["HTMLIFrameElement", base_config_1.TYPE_VALUE],
			["HTMLImageElement", base_config_1.TYPE_VALUE],
			["HTMLInputElement", base_config_1.TYPE_VALUE],
			["HTMLLIElement", base_config_1.TYPE_VALUE],
			["HTMLLabelElement", base_config_1.TYPE_VALUE],
			["HTMLLegendElement", base_config_1.TYPE_VALUE],
			["HTMLLinkElement", base_config_1.TYPE_VALUE],
			["HTMLMapElement", base_config_1.TYPE_VALUE],
			["HTMLMarqueeElement", base_config_1.TYPE_VALUE],
			["HTMLMediaElementEventMap", base_config_1.TYPE],
			["HTMLMediaElement", base_config_1.TYPE_VALUE],
			["HTMLMenuElement", base_config_1.TYPE_VALUE],
			["HTMLMetaElement", base_config_1.TYPE_VALUE],
			["HTMLMeterElement", base_config_1.TYPE_VALUE],
			["HTMLModElement", base_config_1.TYPE_VALUE],
			["HTMLOListElement", base_config_1.TYPE_VALUE],
			["HTMLObjectElement", base_config_1.TYPE_VALUE],
			["HTMLOptGroupElement", base_config_1.TYPE_VALUE],
			["HTMLOptionElement", base_config_1.TYPE_VALUE],
			["HTMLOptionsCollection", base_config_1.TYPE_VALUE],
			["HTMLOrSVGElement", base_config_1.TYPE],
			["HTMLOutputElement", base_config_1.TYPE_VALUE],
			["HTMLParagraphElement", base_config_1.TYPE_VALUE],
			["HTMLParamElement", base_config_1.TYPE_VALUE],
			["HTMLPictureElement", base_config_1.TYPE_VALUE],
			["HTMLPreElement", base_config_1.TYPE_VALUE],
			["HTMLProgressElement", base_config_1.TYPE_VALUE],
			["HTMLQuoteElement", base_config_1.TYPE_VALUE],
			["HTMLScriptElement", base_config_1.TYPE_VALUE],
			["HTMLSelectElement", base_config_1.TYPE_VALUE],
			["HTMLSlotElement", base_config_1.TYPE_VALUE],
			["HTMLSourceElement", base_config_1.TYPE_VALUE],
			["HTMLSpanElement", base_config_1.TYPE_VALUE],
			["HTMLStyleElement", base_config_1.TYPE_VALUE],
			["HTMLTableCaptionElement", base_config_1.TYPE_VALUE],
			["HTMLTableCellElement", base_config_1.TYPE_VALUE],
			["HTMLTableColElement", base_config_1.TYPE_VALUE],
			["HTMLTableDataCellElement", base_config_1.TYPE],
			["HTMLTableElement", base_config_1.TYPE_VALUE],
			["HTMLTableHeaderCellElement", base_config_1.TYPE],
			["HTMLTableRowElement", base_config_1.TYPE_VALUE],
			["HTMLTableSectionElement", base_config_1.TYPE_VALUE],
			["HTMLTemplateElement", base_config_1.TYPE_VALUE],
			["HTMLTextAreaElement", base_config_1.TYPE_VALUE],
			["HTMLTimeElement", base_config_1.TYPE_VALUE],
			["HTMLTitleElement", base_config_1.TYPE_VALUE],
			["HTMLTrackElement", base_config_1.TYPE_VALUE],
			["HTMLUListElement", base_config_1.TYPE_VALUE],
			["HTMLUnknownElement", base_config_1.TYPE_VALUE],
			["HTMLVideoElementEventMap", base_config_1.TYPE],
			["HTMLVideoElement", base_config_1.TYPE_VALUE],
			["HashChangeEvent", base_config_1.TYPE_VALUE],
			["Headers", base_config_1.TYPE_VALUE],
			["Highlight", base_config_1.TYPE_VALUE],
			["HighlightRegistry", base_config_1.TYPE_VALUE],
			["History", base_config_1.TYPE_VALUE],
			["IDBCursor", base_config_1.TYPE_VALUE],
			["IDBCursorWithValue", base_config_1.TYPE_VALUE],
			["IDBDatabaseEventMap", base_config_1.TYPE],
			["IDBDatabase", base_config_1.TYPE_VALUE],
			["IDBFactory", base_config_1.TYPE_VALUE],
			["IDBIndex", base_config_1.TYPE_VALUE],
			["IDBKeyRange", base_config_1.TYPE_VALUE],
			["IDBObjectStore", base_config_1.TYPE_VALUE],
			["IDBOpenDBRequestEventMap", base_config_1.TYPE],
			["IDBOpenDBRequest", base_config_1.TYPE_VALUE],
			["IDBRequestEventMap", base_config_1.TYPE],
			["IDBRequest", base_config_1.TYPE_VALUE],
			["IDBTransactionEventMap", base_config_1.TYPE],
			["IDBTransaction", base_config_1.TYPE_VALUE],
			["IDBVersionChangeEvent", base_config_1.TYPE_VALUE],
			["IIRFilterNode", base_config_1.TYPE_VALUE],
			["IdleDeadline", base_config_1.TYPE_VALUE],
			["ImageBitmap", base_config_1.TYPE_VALUE],
			["ImageBitmapRenderingContext", base_config_1.TYPE_VALUE],
			["ImageCapture", base_config_1.TYPE_VALUE],
			["ImageData", base_config_1.TYPE_VALUE],
			["ImageDecoder", base_config_1.TYPE_VALUE],
			["ImageTrack", base_config_1.TYPE_VALUE],
			["ImageTrackList", base_config_1.TYPE_VALUE],
			["ImportMeta", base_config_1.TYPE],
			["InputDeviceInfo", base_config_1.TYPE_VALUE],
			["InputEvent", base_config_1.TYPE_VALUE],
			["IntersectionObserver", base_config_1.TYPE_VALUE],
			["IntersectionObserverEntry", base_config_1.TYPE_VALUE],
			["KHR_parallel_shader_compile", base_config_1.TYPE],
			["KeyboardEvent", base_config_1.TYPE_VALUE],
			["KeyframeEffect", base_config_1.TYPE_VALUE],
			["LargestContentfulPaint", base_config_1.TYPE_VALUE],
			["LinkStyle", base_config_1.TYPE],
			["Location", base_config_1.TYPE_VALUE],
			["Lock", base_config_1.TYPE_VALUE],
			["LockManager", base_config_1.TYPE_VALUE],
			["MIDIAccessEventMap", base_config_1.TYPE],
			["MIDIAccess", base_config_1.TYPE_VALUE],
			["MIDIConnectionEvent", base_config_1.TYPE_VALUE],
			["MIDIInputEventMap", base_config_1.TYPE],
			["MIDIInput", base_config_1.TYPE_VALUE],
			["MIDIInputMap", base_config_1.TYPE_VALUE],
			["MIDIMessageEvent", base_config_1.TYPE_VALUE],
			["MIDIOutput", base_config_1.TYPE_VALUE],
			["MIDIOutputMap", base_config_1.TYPE_VALUE],
			["MIDIPortEventMap", base_config_1.TYPE],
			["MIDIPort", base_config_1.TYPE_VALUE],
			["MathMLElementEventMap", base_config_1.TYPE],
			["MathMLElement", base_config_1.TYPE_VALUE],
			["MediaCapabilities", base_config_1.TYPE_VALUE],
			["MediaDeviceInfo", base_config_1.TYPE_VALUE],
			["MediaDevicesEventMap", base_config_1.TYPE],
			["MediaDevices", base_config_1.TYPE_VALUE],
			["MediaElementAudioSourceNode", base_config_1.TYPE_VALUE],
			["MediaEncryptedEvent", base_config_1.TYPE_VALUE],
			["MediaError", base_config_1.TYPE_VALUE],
			["MediaKeyMessageEvent", base_config_1.TYPE_VALUE],
			["MediaKeySessionEventMap", base_config_1.TYPE],
			["MediaKeySession", base_config_1.TYPE_VALUE],
			["MediaKeyStatusMap", base_config_1.TYPE_VALUE],
			["MediaKeySystemAccess", base_config_1.TYPE_VALUE],
			["MediaKeys", base_config_1.TYPE_VALUE],
			["MediaList", base_config_1.TYPE_VALUE],
			["MediaMetadata", base_config_1.TYPE_VALUE],
			["MediaQueryListEventMap", base_config_1.TYPE],
			["MediaQueryList", base_config_1.TYPE_VALUE],
			["MediaQueryListEvent", base_config_1.TYPE_VALUE],
			["MediaRecorderEventMap", base_config_1.TYPE],
			["MediaRecorder", base_config_1.TYPE_VALUE],
			["MediaSession", base_config_1.TYPE_VALUE],
			["MediaSourceEventMap", base_config_1.TYPE],
			["MediaSource", base_config_1.TYPE_VALUE],
			["MediaSourceHandle", base_config_1.TYPE_VALUE],
			["MediaStreamEventMap", base_config_1.TYPE],
			["MediaStream", base_config_1.TYPE_VALUE],
			["MediaStreamAudioDestinationNode", base_config_1.TYPE_VALUE],
			["MediaStreamAudioSourceNode", base_config_1.TYPE_VALUE],
			["MediaStreamTrackEventMap", base_config_1.TYPE],
			["MediaStreamTrack", base_config_1.TYPE_VALUE],
			["MediaStreamTrackEvent", base_config_1.TYPE_VALUE],
			["MessageChannel", base_config_1.TYPE_VALUE],
			["MessageEvent", base_config_1.TYPE_VALUE],
			["MessageEventTargetEventMap", base_config_1.TYPE],
			["MessageEventTarget", base_config_1.TYPE],
			["MessagePortEventMap", base_config_1.TYPE],
			["MessagePort", base_config_1.TYPE_VALUE],
			["MimeType", base_config_1.TYPE_VALUE],
			["MimeTypeArray", base_config_1.TYPE_VALUE],
			["MouseEvent", base_config_1.TYPE_VALUE],
			["MutationObserver", base_config_1.TYPE_VALUE],
			["MutationRecord", base_config_1.TYPE_VALUE],
			["NamedNodeMap", base_config_1.TYPE_VALUE],
			["NavigationActivation", base_config_1.TYPE_VALUE],
			["NavigationHistoryEntryEventMap", base_config_1.TYPE],
			["NavigationHistoryEntry", base_config_1.TYPE_VALUE],
			["NavigationPreloadManager", base_config_1.TYPE_VALUE],
			["Navigator", base_config_1.TYPE_VALUE],
			["NavigatorAutomationInformation", base_config_1.TYPE],
			["NavigatorBadge", base_config_1.TYPE],
			["NavigatorConcurrentHardware", base_config_1.TYPE],
			["NavigatorContentUtils", base_config_1.TYPE],
			["NavigatorCookies", base_config_1.TYPE],
			["NavigatorID", base_config_1.TYPE],
			["NavigatorLanguage", base_config_1.TYPE],
			["NavigatorLocks", base_config_1.TYPE],
			["NavigatorLogin", base_config_1.TYPE_VALUE],
			["NavigatorOnLine", base_config_1.TYPE],
			["NavigatorPlugins", base_config_1.TYPE],
			["NavigatorStorage", base_config_1.TYPE],
			["Node", base_config_1.TYPE_VALUE],
			["NodeIterator", base_config_1.TYPE_VALUE],
			["NodeList", base_config_1.TYPE_VALUE],
			["NodeListOf", base_config_1.TYPE],
			["NonDocumentTypeChildNode", base_config_1.TYPE],
			["NonElementParentNode", base_config_1.TYPE],
			["NotificationEventMap", base_config_1.TYPE],
			["Notification", base_config_1.TYPE_VALUE],
			["OES_draw_buffers_indexed", base_config_1.TYPE],
			["OES_element_index_uint", base_config_1.TYPE],
			["OES_fbo_render_mipmap", base_config_1.TYPE],
			["OES_standard_derivatives", base_config_1.TYPE],
			["OES_texture_float", base_config_1.TYPE],
			["OES_texture_float_linear", base_config_1.TYPE],
			["OES_texture_half_float", base_config_1.TYPE],
			["OES_texture_half_float_linear", base_config_1.TYPE],
			["OES_vertex_array_object", base_config_1.TYPE],
			["OVR_multiview2", base_config_1.TYPE],
			["OfflineAudioCompletionEvent", base_config_1.TYPE_VALUE],
			["OfflineAudioContextEventMap", base_config_1.TYPE],
			["OfflineAudioContext", base_config_1.TYPE_VALUE],
			["OffscreenCanvasEventMap", base_config_1.TYPE],
			["OffscreenCanvas", base_config_1.TYPE_VALUE],
			["OffscreenCanvasRenderingContext2D", base_config_1.TYPE_VALUE],
			["OscillatorNode", base_config_1.TYPE_VALUE],
			["OverconstrainedError", base_config_1.TYPE_VALUE],
			["PageRevealEvent", base_config_1.TYPE_VALUE],
			["PageSwapEvent", base_config_1.TYPE_VALUE],
			["PageTransitionEvent", base_config_1.TYPE_VALUE],
			["PannerNode", base_config_1.TYPE_VALUE],
			["ParentNode", base_config_1.TYPE],
			["Path2D", base_config_1.TYPE_VALUE],
			["PaymentAddress", base_config_1.TYPE_VALUE],
			["PaymentMethodChangeEvent", base_config_1.TYPE_VALUE],
			["PaymentRequestEventMap", base_config_1.TYPE],
			["PaymentRequest", base_config_1.TYPE_VALUE],
			["PaymentRequestUpdateEvent", base_config_1.TYPE_VALUE],
			["PaymentResponseEventMap", base_config_1.TYPE],
			["PaymentResponse", base_config_1.TYPE_VALUE],
			["PerformanceEventMap", base_config_1.TYPE],
			["Performance", base_config_1.TYPE_VALUE],
			["PerformanceEntry", base_config_1.TYPE_VALUE],
			["PerformanceEventTiming", base_config_1.TYPE_VALUE],
			["PerformanceMark", base_config_1.TYPE_VALUE],
			["PerformanceMeasure", base_config_1.TYPE_VALUE],
			["PerformanceNavigation", base_config_1.TYPE_VALUE],
			["PerformanceNavigationTiming", base_config_1.TYPE_VALUE],
			["PerformanceObserver", base_config_1.TYPE_VALUE],
			["PerformanceObserverEntryList", base_config_1.TYPE_VALUE],
			["PerformancePaintTiming", base_config_1.TYPE_VALUE],
			["PerformanceResourceTiming", base_config_1.TYPE_VALUE],
			["PerformanceServerTiming", base_config_1.TYPE_VALUE],
			["PerformanceTiming", base_config_1.TYPE_VALUE],
			["PeriodicWave", base_config_1.TYPE_VALUE],
			["PermissionStatusEventMap", base_config_1.TYPE],
			["PermissionStatus", base_config_1.TYPE_VALUE],
			["Permissions", base_config_1.TYPE_VALUE],
			["PictureInPictureEvent", base_config_1.TYPE_VALUE],
			["PictureInPictureWindowEventMap", base_config_1.TYPE],
			["PictureInPictureWindow", base_config_1.TYPE_VALUE],
			["Plugin", base_config_1.TYPE_VALUE],
			["PluginArray", base_config_1.TYPE_VALUE],
			["PointerEvent", base_config_1.TYPE_VALUE],
			["PopStateEvent", base_config_1.TYPE_VALUE],
			["PopoverInvokerElement", base_config_1.TYPE],
			["ProcessingInstruction", base_config_1.TYPE_VALUE],
			["ProgressEvent", base_config_1.TYPE_VALUE],
			["PromiseRejectionEvent", base_config_1.TYPE_VALUE],
			["PublicKeyCredential", base_config_1.TYPE_VALUE],
			["PushManager", base_config_1.TYPE_VALUE],
			["PushSubscription", base_config_1.TYPE_VALUE],
			["PushSubscriptionOptions", base_config_1.TYPE_VALUE],
			["RTCCertificate", base_config_1.TYPE_VALUE],
			["RTCDTMFSenderEventMap", base_config_1.TYPE],
			["RTCDTMFSender", base_config_1.TYPE_VALUE],
			["RTCDTMFToneChangeEvent", base_config_1.TYPE_VALUE],
			["RTCDataChannelEventMap", base_config_1.TYPE],
			["RTCDataChannel", base_config_1.TYPE_VALUE],
			["RTCDataChannelEvent", base_config_1.TYPE_VALUE],
			["RTCDtlsTransportEventMap", base_config_1.TYPE],
			["RTCDtlsTransport", base_config_1.TYPE_VALUE],
			["RTCEncodedAudioFrame", base_config_1.TYPE_VALUE],
			["RTCEncodedVideoFrame", base_config_1.TYPE_VALUE],
			["RTCError", base_config_1.TYPE_VALUE],
			["RTCErrorEvent", base_config_1.TYPE_VALUE],
			["RTCIceCandidate", base_config_1.TYPE_VALUE],
			["RTCIceCandidatePair", base_config_1.TYPE],
			["RTCIceTransportEventMap", base_config_1.TYPE],
			["RTCIceTransport", base_config_1.TYPE_VALUE],
			["RTCPeerConnectionEventMap", base_config_1.TYPE],
			["RTCPeerConnection", base_config_1.TYPE_VALUE],
			["RTCPeerConnectionIceErrorEvent", base_config_1.TYPE_VALUE],
			["RTCPeerConnectionIceEvent", base_config_1.TYPE_VALUE],
			["RTCRtpReceiver", base_config_1.TYPE_VALUE],
			["RTCRtpScriptTransform", base_config_1.TYPE_VALUE],
			["RTCRtpSender", base_config_1.TYPE_VALUE],
			["RTCRtpTransceiver", base_config_1.TYPE_VALUE],
			["RTCSctpTransportEventMap", base_config_1.TYPE],
			["RTCSctpTransport", base_config_1.TYPE_VALUE],
			["RTCSessionDescription", base_config_1.TYPE_VALUE],
			["RTCStatsReport", base_config_1.TYPE_VALUE],
			["RTCTrackEvent", base_config_1.TYPE_VALUE],
			["RadioNodeList", base_config_1.TYPE_VALUE],
			["Range", base_config_1.TYPE_VALUE],
			["ReadableByteStreamController", base_config_1.TYPE_VALUE],
			["ReadableStream", base_config_1.TYPE_VALUE],
			["ReadableStreamBYOBReader", base_config_1.TYPE_VALUE],
			["ReadableStreamBYOBRequest", base_config_1.TYPE_VALUE],
			["ReadableStreamDefaultController", base_config_1.TYPE_VALUE],
			["ReadableStreamDefaultReader", base_config_1.TYPE_VALUE],
			["ReadableStreamGenericReader", base_config_1.TYPE],
			["RemotePlaybackEventMap", base_config_1.TYPE],
			["RemotePlayback", base_config_1.TYPE_VALUE],
			["Report", base_config_1.TYPE_VALUE],
			["ReportBody", base_config_1.TYPE_VALUE],
			["ReportingObserver", base_config_1.TYPE_VALUE],
			["Request", base_config_1.TYPE_VALUE],
			["ResizeObserver", base_config_1.TYPE_VALUE],
			["ResizeObserverEntry", base_config_1.TYPE_VALUE],
			["ResizeObserverSize", base_config_1.TYPE_VALUE],
			["Response", base_config_1.TYPE_VALUE],
			["SVGAElement", base_config_1.TYPE_VALUE],
			["SVGAngle", base_config_1.TYPE_VALUE],
			["SVGAnimateElement", base_config_1.TYPE_VALUE],
			["SVGAnimateMotionElement", base_config_1.TYPE_VALUE],
			["SVGAnimateTransformElement", base_config_1.TYPE_VALUE],
			["SVGAnimatedAngle", base_config_1.TYPE_VALUE],
			["SVGAnimatedBoolean", base_config_1.TYPE_VALUE],
			["SVGAnimatedEnumeration", base_config_1.TYPE_VALUE],
			["SVGAnimatedInteger", base_config_1.TYPE_VALUE],
			["SVGAnimatedLength", base_config_1.TYPE_VALUE],
			["SVGAnimatedLengthList", base_config_1.TYPE_VALUE],
			["SVGAnimatedNumber", base_config_1.TYPE_VALUE],
			["SVGAnimatedNumberList", base_config_1.TYPE_VALUE],
			["SVGAnimatedPoints", base_config_1.TYPE],
			["SVGAnimatedPreserveAspectRatio", base_config_1.TYPE_VALUE],
			["SVGAnimatedRect", base_config_1.TYPE_VALUE],
			["SVGAnimatedString", base_config_1.TYPE_VALUE],
			["SVGAnimatedTransformList", base_config_1.TYPE_VALUE],
			["SVGAnimationElement", base_config_1.TYPE_VALUE],
			["SVGCircleElement", base_config_1.TYPE_VALUE],
			["SVGClipPathElement", base_config_1.TYPE_VALUE],
			["SVGComponentTransferFunctionElement", base_config_1.TYPE_VALUE],
			["SVGDefsElement", base_config_1.TYPE_VALUE],
			["SVGDescElement", base_config_1.TYPE_VALUE],
			["SVGElementEventMap", base_config_1.TYPE],
			["SVGElement", base_config_1.TYPE_VALUE],
			["SVGEllipseElement", base_config_1.TYPE_VALUE],
			["SVGFEBlendElement", base_config_1.TYPE_VALUE],
			["SVGFEColorMatrixElement", base_config_1.TYPE_VALUE],
			["SVGFEComponentTransferElement", base_config_1.TYPE_VALUE],
			["SVGFECompositeElement", base_config_1.TYPE_VALUE],
			["SVGFEConvolveMatrixElement", base_config_1.TYPE_VALUE],
			["SVGFEDiffuseLightingElement", base_config_1.TYPE_VALUE],
			["SVGFEDisplacementMapElement", base_config_1.TYPE_VALUE],
			["SVGFEDistantLightElement", base_config_1.TYPE_VALUE],
			["SVGFEDropShadowElement", base_config_1.TYPE_VALUE],
			["SVGFEFloodElement", base_config_1.TYPE_VALUE],
			["SVGFEFuncAElement", base_config_1.TYPE_VALUE],
			["SVGFEFuncBElement", base_config_1.TYPE_VALUE],
			["SVGFEFuncGElement", base_config_1.TYPE_VALUE],
			["SVGFEFuncRElement", base_config_1.TYPE_VALUE],
			["SVGFEGaussianBlurElement", base_config_1.TYPE_VALUE],
			["SVGFEImageElement", base_config_1.TYPE_VALUE],
			["SVGFEMergeElement", base_config_1.TYPE_VALUE],
			["SVGFEMergeNodeElement", base_config_1.TYPE_VALUE],
			["SVGFEMorphologyElement", base_config_1.TYPE_VALUE],
			["SVGFEOffsetElement", base_config_1.TYPE_VALUE],
			["SVGFEPointLightElement", base_config_1.TYPE_VALUE],
			["SVGFESpecularLightingElement", base_config_1.TYPE_VALUE],
			["SVGFESpotLightElement", base_config_1.TYPE_VALUE],
			["SVGFETileElement", base_config_1.TYPE_VALUE],
			["SVGFETurbulenceElement", base_config_1.TYPE_VALUE],
			["SVGFilterElement", base_config_1.TYPE_VALUE],
			["SVGFilterPrimitiveStandardAttributes", base_config_1.TYPE],
			["SVGFitToViewBox", base_config_1.TYPE],
			["SVGForeignObjectElement", base_config_1.TYPE_VALUE],
			["SVGGElement", base_config_1.TYPE_VALUE],
			["SVGGeometryElement", base_config_1.TYPE_VALUE],
			["SVGGradientElement", base_config_1.TYPE_VALUE],
			["SVGGraphicsElement", base_config_1.TYPE_VALUE],
			["SVGImageElement", base_config_1.TYPE_VALUE],
			["SVGLength", base_config_1.TYPE_VALUE],
			["SVGLengthList", base_config_1.TYPE_VALUE],
			["SVGLineElement", base_config_1.TYPE_VALUE],
			["SVGLinearGradientElement", base_config_1.TYPE_VALUE],
			["SVGMPathElement", base_config_1.TYPE_VALUE],
			["SVGMarkerElement", base_config_1.TYPE_VALUE],
			["SVGMaskElement", base_config_1.TYPE_VALUE],
			["SVGMetadataElement", base_config_1.TYPE_VALUE],
			["SVGNumber", base_config_1.TYPE_VALUE],
			["SVGNumberList", base_config_1.TYPE_VALUE],
			["SVGPathElement", base_config_1.TYPE_VALUE],
			["SVGPatternElement", base_config_1.TYPE_VALUE],
			["SVGPointList", base_config_1.TYPE_VALUE],
			["SVGPolygonElement", base_config_1.TYPE_VALUE],
			["SVGPolylineElement", base_config_1.TYPE_VALUE],
			["SVGPreserveAspectRatio", base_config_1.TYPE_VALUE],
			["SVGRadialGradientElement", base_config_1.TYPE_VALUE],
			["SVGRectElement", base_config_1.TYPE_VALUE],
			["SVGSVGElementEventMap", base_config_1.TYPE],
			["SVGSVGElement", base_config_1.TYPE_VALUE],
			["SVGScriptElement", base_config_1.TYPE_VALUE],
			["SVGSetElement", base_config_1.TYPE_VALUE],
			["SVGStopElement", base_config_1.TYPE_VALUE],
			["SVGStringList", base_config_1.TYPE_VALUE],
			["SVGStyleElement", base_config_1.TYPE_VALUE],
			["SVGSwitchElement", base_config_1.TYPE_VALUE],
			["SVGSymbolElement", base_config_1.TYPE_VALUE],
			["SVGTSpanElement", base_config_1.TYPE_VALUE],
			["SVGTests", base_config_1.TYPE],
			["SVGTextContentElement", base_config_1.TYPE_VALUE],
			["SVGTextElement", base_config_1.TYPE_VALUE],
			["SVGTextPathElement", base_config_1.TYPE_VALUE],
			["SVGTextPositioningElement", base_config_1.TYPE_VALUE],
			["SVGTitleElement", base_config_1.TYPE_VALUE],
			["SVGTransform", base_config_1.TYPE_VALUE],
			["SVGTransformList", base_config_1.TYPE_VALUE],
			["SVGURIReference", base_config_1.TYPE],
			["SVGUnitTypes", base_config_1.TYPE_VALUE],
			["SVGUseElement", base_config_1.TYPE_VALUE],
			["SVGViewElement", base_config_1.TYPE_VALUE],
			["Screen", base_config_1.TYPE_VALUE],
			["ScreenOrientationEventMap", base_config_1.TYPE],
			["ScreenOrientation", base_config_1.TYPE_VALUE],
			["ScriptProcessorNodeEventMap", base_config_1.TYPE],
			["ScriptProcessorNode", base_config_1.TYPE_VALUE],
			["SecurityPolicyViolationEvent", base_config_1.TYPE_VALUE],
			["Selection", base_config_1.TYPE_VALUE],
			["ServiceWorkerEventMap", base_config_1.TYPE],
			["ServiceWorker", base_config_1.TYPE_VALUE],
			["ServiceWorkerContainerEventMap", base_config_1.TYPE],
			["ServiceWorkerContainer", base_config_1.TYPE_VALUE],
			["ServiceWorkerRegistrationEventMap", base_config_1.TYPE],
			["ServiceWorkerRegistration", base_config_1.TYPE_VALUE],
			["ShadowRootEventMap", base_config_1.TYPE],
			["ShadowRoot", base_config_1.TYPE_VALUE],
			["SharedWorker", base_config_1.TYPE_VALUE],
			["Slottable", base_config_1.TYPE],
			["SourceBufferEventMap", base_config_1.TYPE],
			["SourceBuffer", base_config_1.TYPE_VALUE],
			["SourceBufferListEventMap", base_config_1.TYPE],
			["SourceBufferList", base_config_1.TYPE_VALUE],
			["SpeechRecognitionAlternative", base_config_1.TYPE_VALUE],
			["SpeechRecognitionResult", base_config_1.TYPE_VALUE],
			["SpeechRecognitionResultList", base_config_1.TYPE_VALUE],
			["SpeechSynthesisEventMap", base_config_1.TYPE],
			["SpeechSynthesis", base_config_1.TYPE_VALUE],
			["SpeechSynthesisErrorEvent", base_config_1.TYPE_VALUE],
			["SpeechSynthesisEvent", base_config_1.TYPE_VALUE],
			["SpeechSynthesisUtteranceEventMap", base_config_1.TYPE],
			["SpeechSynthesisUtterance", base_config_1.TYPE_VALUE],
			["SpeechSynthesisVoice", base_config_1.TYPE_VALUE],
			["StaticRange", base_config_1.TYPE_VALUE],
			["StereoPannerNode", base_config_1.TYPE_VALUE],
			["Storage", base_config_1.TYPE_VALUE],
			["StorageEvent", base_config_1.TYPE_VALUE],
			["StorageManager", base_config_1.TYPE_VALUE],
			["StyleMedia", base_config_1.TYPE],
			["StylePropertyMap", base_config_1.TYPE_VALUE],
			["StylePropertyMapReadOnly", base_config_1.TYPE_VALUE],
			["StyleSheet", base_config_1.TYPE_VALUE],
			["StyleSheetList", base_config_1.TYPE_VALUE],
			["SubmitEvent", base_config_1.TYPE_VALUE],
			["SubtleCrypto", base_config_1.TYPE_VALUE],
			["Text", base_config_1.TYPE_VALUE],
			["TextDecoder", base_config_1.TYPE_VALUE],
			["TextDecoderCommon", base_config_1.TYPE],
			["TextDecoderStream", base_config_1.TYPE_VALUE],
			["TextEncoder", base_config_1.TYPE_VALUE],
			["TextEncoderCommon", base_config_1.TYPE],
			["TextEncoderStream", base_config_1.TYPE_VALUE],
			["TextEvent", base_config_1.TYPE_VALUE],
			["TextMetrics", base_config_1.TYPE_VALUE],
			["TextTrackEventMap", base_config_1.TYPE],
			["TextTrack", base_config_1.TYPE_VALUE],
			["TextTrackCueEventMap", base_config_1.TYPE],
			["TextTrackCue", base_config_1.TYPE_VALUE],
			["TextTrackCueList", base_config_1.TYPE_VALUE],
			["TextTrackListEventMap", base_config_1.TYPE],
			["TextTrackList", base_config_1.TYPE_VALUE],
			["TimeRanges", base_config_1.TYPE_VALUE],
			["ToggleEvent", base_config_1.TYPE_VALUE],
			["Touch", base_config_1.TYPE_VALUE],
			["TouchEvent", base_config_1.TYPE_VALUE],
			["TouchList", base_config_1.TYPE_VALUE],
			["TrackEvent", base_config_1.TYPE_VALUE],
			["TransformStream", base_config_1.TYPE_VALUE],
			["TransformStreamDefaultController", base_config_1.TYPE_VALUE],
			["TransitionEvent", base_config_1.TYPE_VALUE],
			["TreeWalker", base_config_1.TYPE_VALUE],
			["UIEvent", base_config_1.TYPE_VALUE],
			["URL", base_config_1.TYPE_VALUE],
			["webkitURL", base_config_1.TYPE_VALUE],
			["URLSearchParams", base_config_1.TYPE_VALUE],
			["UserActivation", base_config_1.TYPE_VALUE],
			["VTTCue", base_config_1.TYPE_VALUE],
			["VTTRegion", base_config_1.TYPE_VALUE],
			["ValidityState", base_config_1.TYPE_VALUE],
			["VideoColorSpace", base_config_1.TYPE_VALUE],
			["VideoDecoderEventMap", base_config_1.TYPE],
			["VideoDecoder", base_config_1.TYPE_VALUE],
			["VideoEncoderEventMap", base_config_1.TYPE],
			["VideoEncoder", base_config_1.TYPE_VALUE],
			["VideoFrame", base_config_1.TYPE_VALUE],
			["VideoPlaybackQuality", base_config_1.TYPE_VALUE],
			["ViewTransition", base_config_1.TYPE_VALUE],
			["ViewTransitionTypeSet", base_config_1.TYPE_VALUE],
			["VisualViewportEventMap", base_config_1.TYPE],
			["VisualViewport", base_config_1.TYPE_VALUE],
			["WEBGL_color_buffer_float", base_config_1.TYPE],
			["WEBGL_compressed_texture_astc", base_config_1.TYPE],
			["WEBGL_compressed_texture_etc", base_config_1.TYPE],
			["WEBGL_compressed_texture_etc1", base_config_1.TYPE],
			["WEBGL_compressed_texture_pvrtc", base_config_1.TYPE],
			["WEBGL_compressed_texture_s3tc", base_config_1.TYPE],
			["WEBGL_compressed_texture_s3tc_srgb", base_config_1.TYPE],
			["WEBGL_debug_renderer_info", base_config_1.TYPE],
			["WEBGL_debug_shaders", base_config_1.TYPE],
			["WEBGL_depth_texture", base_config_1.TYPE],
			["WEBGL_draw_buffers", base_config_1.TYPE],
			["WEBGL_lose_context", base_config_1.TYPE],
			["WEBGL_multi_draw", base_config_1.TYPE],
			["WakeLock", base_config_1.TYPE_VALUE],
			["WakeLockSentinelEventMap", base_config_1.TYPE],
			["WakeLockSentinel", base_config_1.TYPE_VALUE],
			["WaveShaperNode", base_config_1.TYPE_VALUE],
			["WebGL2RenderingContext", base_config_1.TYPE_VALUE],
			["WebGL2RenderingContextBase", base_config_1.TYPE],
			["WebGL2RenderingContextOverloads", base_config_1.TYPE],
			["WebGLActiveInfo", base_config_1.TYPE_VALUE],
			["WebGLBuffer", base_config_1.TYPE_VALUE],
			["WebGLContextEvent", base_config_1.TYPE_VALUE],
			["WebGLFramebuffer", base_config_1.TYPE_VALUE],
			["WebGLProgram", base_config_1.TYPE_VALUE],
			["WebGLQuery", base_config_1.TYPE_VALUE],
			["WebGLRenderbuffer", base_config_1.TYPE_VALUE],
			["WebGLRenderingContext", base_config_1.TYPE_VALUE],
			["WebGLRenderingContextBase", base_config_1.TYPE],
			["WebGLRenderingContextOverloads", base_config_1.TYPE],
			["WebGLSampler", base_config_1.TYPE_VALUE],
			["WebGLShader", base_config_1.TYPE_VALUE],
			["WebGLShaderPrecisionFormat", base_config_1.TYPE_VALUE],
			["WebGLSync", base_config_1.TYPE_VALUE],
			["WebGLTexture", base_config_1.TYPE_VALUE],
			["WebGLTransformFeedback", base_config_1.TYPE_VALUE],
			["WebGLUniformLocation", base_config_1.TYPE_VALUE],
			["WebGLVertexArrayObject", base_config_1.TYPE_VALUE],
			["WebGLVertexArrayObjectOES", base_config_1.TYPE],
			["WebSocketEventMap", base_config_1.TYPE],
			["WebSocket", base_config_1.TYPE_VALUE],
			["WebTransport", base_config_1.TYPE_VALUE],
			["WebTransportBidirectionalStream", base_config_1.TYPE_VALUE],
			["WebTransportDatagramDuplexStream", base_config_1.TYPE_VALUE],
			["WebTransportError", base_config_1.TYPE_VALUE],
			["WheelEvent", base_config_1.TYPE_VALUE],
			["WindowEventMap", base_config_1.TYPE],
			["Window", base_config_1.TYPE_VALUE],
			["WindowEventHandlersEventMap", base_config_1.TYPE],
			["WindowEventHandlers", base_config_1.TYPE],
			["WindowLocalStorage", base_config_1.TYPE],
			["WindowOrWorkerGlobalScope", base_config_1.TYPE],
			["WindowSessionStorage", base_config_1.TYPE],
			["WorkerEventMap", base_config_1.TYPE],
			["Worker", base_config_1.TYPE_VALUE],
			["Worklet", base_config_1.TYPE_VALUE],
			["WritableStream", base_config_1.TYPE_VALUE],
			["WritableStreamDefaultController", base_config_1.TYPE_VALUE],
			["WritableStreamDefaultWriter", base_config_1.TYPE_VALUE],
			["XMLDocument", base_config_1.TYPE_VALUE],
			["XMLHttpRequestEventMap", base_config_1.TYPE],
			["XMLHttpRequest", base_config_1.TYPE_VALUE],
			["XMLHttpRequestEventTargetEventMap", base_config_1.TYPE],
			["XMLHttpRequestEventTarget", base_config_1.TYPE_VALUE],
			["XMLHttpRequestUpload", base_config_1.TYPE_VALUE],
			["XMLSerializer", base_config_1.TYPE_VALUE],
			["XPathEvaluator", base_config_1.TYPE_VALUE],
			["XPathEvaluatorBase", base_config_1.TYPE],
			["XPathExpression", base_config_1.TYPE_VALUE],
			["XPathResult", base_config_1.TYPE_VALUE],
			["XSLTProcessor", base_config_1.TYPE_VALUE],
			["CSS", base_config_1.TYPE_VALUE],
			["WebAssembly", base_config_1.TYPE_VALUE],
			["Console", base_config_1.TYPE],
			["AudioDataOutputCallback", base_config_1.TYPE],
			["BlobCallback", base_config_1.TYPE],
			["CustomElementConstructor", base_config_1.TYPE],
			["DecodeErrorCallback", base_config_1.TYPE],
			["DecodeSuccessCallback", base_config_1.TYPE],
			["EncodedAudioChunkOutputCallback", base_config_1.TYPE],
			["EncodedVideoChunkOutputCallback", base_config_1.TYPE],
			["ErrorCallback", base_config_1.TYPE],
			["FileCallback", base_config_1.TYPE],
			["FileSystemEntriesCallback", base_config_1.TYPE],
			["FileSystemEntryCallback", base_config_1.TYPE],
			["FrameRequestCallback", base_config_1.TYPE],
			["FunctionStringCallback", base_config_1.TYPE],
			["IdleRequestCallback", base_config_1.TYPE],
			["IntersectionObserverCallback", base_config_1.TYPE],
			["LockGrantedCallback", base_config_1.TYPE],
			["MediaSessionActionHandler", base_config_1.TYPE],
			["MutationCallback", base_config_1.TYPE],
			["NotificationPermissionCallback", base_config_1.TYPE],
			["OnBeforeUnloadEventHandlerNonNull", base_config_1.TYPE],
			["OnErrorEventHandlerNonNull", base_config_1.TYPE],
			["PerformanceObserverCallback", base_config_1.TYPE],
			["PositionCallback", base_config_1.TYPE],
			["PositionErrorCallback", base_config_1.TYPE],
			["QueuingStrategySize", base_config_1.TYPE],
			["RTCPeerConnectionErrorCallback", base_config_1.TYPE],
			["RTCSessionDescriptionCallback", base_config_1.TYPE],
			["RemotePlaybackAvailabilityCallback", base_config_1.TYPE],
			["ReportingObserverCallback", base_config_1.TYPE],
			["ResizeObserverCallback", base_config_1.TYPE],
			["TransformerFlushCallback", base_config_1.TYPE],
			["TransformerStartCallback", base_config_1.TYPE],
			["TransformerTransformCallback", base_config_1.TYPE],
			["UnderlyingSinkAbortCallback", base_config_1.TYPE],
			["UnderlyingSinkCloseCallback", base_config_1.TYPE],
			["UnderlyingSinkStartCallback", base_config_1.TYPE],
			["UnderlyingSinkWriteCallback", base_config_1.TYPE],
			["UnderlyingSourceCancelCallback", base_config_1.TYPE],
			["UnderlyingSourcePullCallback", base_config_1.TYPE],
			["UnderlyingSourceStartCallback", base_config_1.TYPE],
			["VideoFrameOutputCallback", base_config_1.TYPE],
			["VideoFrameRequestCallback", base_config_1.TYPE],
			["ViewTransitionUpdateCallback", base_config_1.TYPE],
			["VoidFunction", base_config_1.TYPE],
			["WebCodecsErrorCallback", base_config_1.TYPE],
			["HTMLElementTagNameMap", base_config_1.TYPE],
			["HTMLElementDeprecatedTagNameMap", base_config_1.TYPE],
			["SVGElementTagNameMap", base_config_1.TYPE],
			["MathMLElementTagNameMap", base_config_1.TYPE],
			["ElementTagNameMap", base_config_1.TYPE],
			["AlgorithmIdentifier", base_config_1.TYPE],
			["AllowSharedBufferSource", base_config_1.TYPE],
			["AutoFill", base_config_1.TYPE],
			["AutoFillField", base_config_1.TYPE],
			["AutoFillSection", base_config_1.TYPE],
			["Base64URLString", base_config_1.TYPE],
			["BigInteger", base_config_1.TYPE],
			["BlobPart", base_config_1.TYPE],
			["BodyInit", base_config_1.TYPE],
			["BufferSource", base_config_1.TYPE],
			["COSEAlgorithmIdentifier", base_config_1.TYPE],
			["CSSKeywordish", base_config_1.TYPE],
			["CSSNumberish", base_config_1.TYPE],
			["CSSPerspectiveValue", base_config_1.TYPE],
			["CSSUnparsedSegment", base_config_1.TYPE],
			["CanvasImageSource", base_config_1.TYPE],
			["ClipboardItemData", base_config_1.TYPE],
			["ClipboardItems", base_config_1.TYPE],
			["ConstrainBoolean", base_config_1.TYPE],
			["ConstrainDOMString", base_config_1.TYPE],
			["ConstrainDouble", base_config_1.TYPE],
			["ConstrainULong", base_config_1.TYPE],
			["CookieList", base_config_1.TYPE],
			["DOMHighResTimeStamp", base_config_1.TYPE],
			["EpochTimeStamp", base_config_1.TYPE],
			["EventListenerOrEventListenerObject", base_config_1.TYPE],
			["FileSystemWriteChunkType", base_config_1.TYPE],
			["Float32List", base_config_1.TYPE],
			["FormDataEntryValue", base_config_1.TYPE],
			["GLbitfield", base_config_1.TYPE],
			["GLboolean", base_config_1.TYPE],
			["GLclampf", base_config_1.TYPE],
			["GLenum", base_config_1.TYPE],
			["GLfloat", base_config_1.TYPE],
			["GLint", base_config_1.TYPE],
			["GLint64", base_config_1.TYPE],
			["GLintptr", base_config_1.TYPE],
			["GLsizei", base_config_1.TYPE],
			["GLsizeiptr", base_config_1.TYPE],
			["GLuint", base_config_1.TYPE],
			["GLuint64", base_config_1.TYPE],
			["HTMLOrSVGImageElement", base_config_1.TYPE],
			["HTMLOrSVGScriptElement", base_config_1.TYPE],
			["HashAlgorithmIdentifier", base_config_1.TYPE],
			["HeadersInit", base_config_1.TYPE],
			["IDBValidKey", base_config_1.TYPE],
			["ImageBitmapSource", base_config_1.TYPE],
			["ImageBufferSource", base_config_1.TYPE],
			["ImageDataArray", base_config_1.TYPE],
			["Int32List", base_config_1.TYPE],
			["LineAndPositionSetting", base_config_1.TYPE],
			["MediaProvider", base_config_1.TYPE],
			["MessageEventSource", base_config_1.TYPE],
			["MutationRecordType", base_config_1.TYPE],
			["NamedCurve", base_config_1.TYPE],
			["OffscreenRenderingContext", base_config_1.TYPE],
			["OnBeforeUnloadEventHandler", base_config_1.TYPE],
			["OnErrorEventHandler", base_config_1.TYPE],
			["OptionalPostfixToken", base_config_1.TYPE],
			["OptionalPrefixToken", base_config_1.TYPE],
			["PerformanceEntryList", base_config_1.TYPE],
			["PublicKeyCredentialClientCapabilities", base_config_1.TYPE],
			["PublicKeyCredentialJSON", base_config_1.TYPE],
			["RTCRtpTransform", base_config_1.TYPE],
			["ReadableStreamController", base_config_1.TYPE],
			["ReadableStreamReadResult", base_config_1.TYPE],
			["ReadableStreamReader", base_config_1.TYPE],
			["RenderingContext", base_config_1.TYPE],
			["ReportList", base_config_1.TYPE],
			["RequestInfo", base_config_1.TYPE],
			["TexImageSource", base_config_1.TYPE],
			["TimerHandler", base_config_1.TYPE],
			["Transferable", base_config_1.TYPE],
			["Uint32List", base_config_1.TYPE],
			["VibratePattern", base_config_1.TYPE],
			["WindowProxy", base_config_1.TYPE],
			["XMLHttpRequestBodyInit", base_config_1.TYPE],
			["AlignSetting", base_config_1.TYPE],
			["AlphaOption", base_config_1.TYPE],
			["AnimationPlayState", base_config_1.TYPE],
			["AnimationReplaceState", base_config_1.TYPE],
			["AppendMode", base_config_1.TYPE],
			["AttestationConveyancePreference", base_config_1.TYPE],
			["AudioContextLatencyCategory", base_config_1.TYPE],
			["AudioContextState", base_config_1.TYPE],
			["AudioSampleFormat", base_config_1.TYPE],
			["AuthenticatorAttachment", base_config_1.TYPE],
			["AuthenticatorTransport", base_config_1.TYPE],
			["AutoFillAddressKind", base_config_1.TYPE],
			["AutoFillBase", base_config_1.TYPE],
			["AutoFillContactField", base_config_1.TYPE],
			["AutoFillContactKind", base_config_1.TYPE],
			["AutoFillCredentialField", base_config_1.TYPE],
			["AutoFillNormalField", base_config_1.TYPE],
			["AutoKeyword", base_config_1.TYPE],
			["AutomationRate", base_config_1.TYPE],
			["AvcBitstreamFormat", base_config_1.TYPE],
			["BinaryType", base_config_1.TYPE],
			["BiquadFilterType", base_config_1.TYPE],
			["BitrateMode", base_config_1.TYPE],
			["CSSMathOperator", base_config_1.TYPE],
			["CSSNumericBaseType", base_config_1.TYPE],
			["CanPlayTypeResult", base_config_1.TYPE],
			["CanvasDirection", base_config_1.TYPE],
			["CanvasFillRule", base_config_1.TYPE],
			["CanvasFontKerning", base_config_1.TYPE],
			["CanvasFontStretch", base_config_1.TYPE],
			["CanvasFontVariantCaps", base_config_1.TYPE],
			["CanvasLineCap", base_config_1.TYPE],
			["CanvasLineJoin", base_config_1.TYPE],
			["CanvasTextAlign", base_config_1.TYPE],
			["CanvasTextBaseline", base_config_1.TYPE],
			["CanvasTextRendering", base_config_1.TYPE],
			["ChannelCountMode", base_config_1.TYPE],
			["ChannelInterpretation", base_config_1.TYPE],
			["ClientTypes", base_config_1.TYPE],
			["CodecState", base_config_1.TYPE],
			["ColorGamut", base_config_1.TYPE],
			["ColorSpaceConversion", base_config_1.TYPE],
			["CompositeOperation", base_config_1.TYPE],
			["CompositeOperationOrAuto", base_config_1.TYPE],
			["CompressionFormat", base_config_1.TYPE],
			["CookieSameSite", base_config_1.TYPE],
			["CredentialMediationRequirement", base_config_1.TYPE],
			["DOMParserSupportedType", base_config_1.TYPE],
			["DirectionSetting", base_config_1.TYPE],
			["DisplayCaptureSurfaceType", base_config_1.TYPE],
			["DistanceModelType", base_config_1.TYPE],
			["DocumentReadyState", base_config_1.TYPE],
			["DocumentVisibilityState", base_config_1.TYPE],
			["EncodedAudioChunkType", base_config_1.TYPE],
			["EncodedVideoChunkType", base_config_1.TYPE],
			["EndOfStreamError", base_config_1.TYPE],
			["EndingType", base_config_1.TYPE],
			["FileSystemHandleKind", base_config_1.TYPE],
			["FillLightMode", base_config_1.TYPE],
			["FillMode", base_config_1.TYPE],
			["FontDisplay", base_config_1.TYPE],
			["FontFaceLoadStatus", base_config_1.TYPE],
			["FontFaceSetLoadStatus", base_config_1.TYPE],
			["FullscreenNavigationUI", base_config_1.TYPE],
			["GamepadHapticEffectType", base_config_1.TYPE],
			["GamepadHapticsResult", base_config_1.TYPE],
			["GamepadMappingType", base_config_1.TYPE],
			["GlobalCompositeOperation", base_config_1.TYPE],
			["HardwareAcceleration", base_config_1.TYPE],
			["HdrMetadataType", base_config_1.TYPE],
			["HighlightType", base_config_1.TYPE],
			["IDBCursorDirection", base_config_1.TYPE],
			["IDBRequestReadyState", base_config_1.TYPE],
			["IDBTransactionDurability", base_config_1.TYPE],
			["IDBTransactionMode", base_config_1.TYPE],
			["ImageOrientation", base_config_1.TYPE],
			["ImageSmoothingQuality", base_config_1.TYPE],
			["InsertPosition", base_config_1.TYPE],
			["IterationCompositeOperation", base_config_1.TYPE],
			["KeyFormat", base_config_1.TYPE],
			["KeyType", base_config_1.TYPE],
			["KeyUsage", base_config_1.TYPE],
			["LatencyMode", base_config_1.TYPE],
			["LineAlignSetting", base_config_1.TYPE],
			["LockMode", base_config_1.TYPE],
			["LoginStatus", base_config_1.TYPE],
			["MIDIPortConnectionState", base_config_1.TYPE],
			["MIDIPortDeviceState", base_config_1.TYPE],
			["MIDIPortType", base_config_1.TYPE],
			["MediaDecodingType", base_config_1.TYPE],
			["MediaDeviceKind", base_config_1.TYPE],
			["MediaEncodingType", base_config_1.TYPE],
			["MediaKeyMessageType", base_config_1.TYPE],
			["MediaKeySessionClosedReason", base_config_1.TYPE],
			["MediaKeySessionType", base_config_1.TYPE],
			["MediaKeyStatus", base_config_1.TYPE],
			["MediaKeysRequirement", base_config_1.TYPE],
			["MediaSessionAction", base_config_1.TYPE],
			["MediaSessionPlaybackState", base_config_1.TYPE],
			["MediaStreamTrackState", base_config_1.TYPE],
			["NavigationTimingType", base_config_1.TYPE],
			["NavigationType", base_config_1.TYPE],
			["NotificationDirection", base_config_1.TYPE],
			["NotificationPermission", base_config_1.TYPE],
			["OffscreenRenderingContextId", base_config_1.TYPE],
			["OpusBitstreamFormat", base_config_1.TYPE],
			["OrientationType", base_config_1.TYPE],
			["OscillatorType", base_config_1.TYPE],
			["OverSampleType", base_config_1.TYPE],
			["PanningModelType", base_config_1.TYPE],
			["PaymentComplete", base_config_1.TYPE],
			["PaymentShippingType", base_config_1.TYPE],
			["PermissionName", base_config_1.TYPE],
			["PermissionState", base_config_1.TYPE],
			["PlaybackDirection", base_config_1.TYPE],
			["PositionAlignSetting", base_config_1.TYPE],
			["PredefinedColorSpace", base_config_1.TYPE],
			["PremultiplyAlpha", base_config_1.TYPE],
			["PresentationStyle", base_config_1.TYPE],
			["PublicKeyCredentialType", base_config_1.TYPE],
			["PushEncryptionKeyName", base_config_1.TYPE],
			["RTCBundlePolicy", base_config_1.TYPE],
			["RTCDataChannelState", base_config_1.TYPE],
			["RTCDegradationPreference", base_config_1.TYPE],
			["RTCDtlsRole", base_config_1.TYPE],
			["RTCDtlsTransportState", base_config_1.TYPE],
			["RTCEncodedVideoFrameType", base_config_1.TYPE],
			["RTCErrorDetailType", base_config_1.TYPE],
			["RTCIceCandidateType", base_config_1.TYPE],
			["RTCIceComponent", base_config_1.TYPE],
			["RTCIceConnectionState", base_config_1.TYPE],
			["RTCIceGathererState", base_config_1.TYPE],
			["RTCIceGatheringState", base_config_1.TYPE],
			["RTCIceProtocol", base_config_1.TYPE],
			["RTCIceRole", base_config_1.TYPE],
			["RTCIceTcpCandidateType", base_config_1.TYPE],
			["RTCIceTransportPolicy", base_config_1.TYPE],
			["RTCIceTransportState", base_config_1.TYPE],
			["RTCPeerConnectionState", base_config_1.TYPE],
			["RTCPriorityType", base_config_1.TYPE],
			["RTCQualityLimitationReason", base_config_1.TYPE],
			["RTCRtcpMuxPolicy", base_config_1.TYPE],
			["RTCRtpTransceiverDirection", base_config_1.TYPE],
			["RTCSctpTransportState", base_config_1.TYPE],
			["RTCSdpType", base_config_1.TYPE],
			["RTCSignalingState", base_config_1.TYPE],
			["RTCStatsIceCandidatePairState", base_config_1.TYPE],
			["RTCStatsType", base_config_1.TYPE],
			["ReadableStreamReaderMode", base_config_1.TYPE],
			["ReadableStreamType", base_config_1.TYPE],
			["ReadyState", base_config_1.TYPE],
			["RecordingState", base_config_1.TYPE],
			["RedEyeReduction", base_config_1.TYPE],
			["ReferrerPolicy", base_config_1.TYPE],
			["RemotePlaybackState", base_config_1.TYPE],
			["RequestCache", base_config_1.TYPE],
			["RequestCredentials", base_config_1.TYPE],
			["RequestDestination", base_config_1.TYPE],
			["RequestMode", base_config_1.TYPE],
			["RequestPriority", base_config_1.TYPE],
			["RequestRedirect", base_config_1.TYPE],
			["ResidentKeyRequirement", base_config_1.TYPE],
			["ResizeObserverBoxOptions", base_config_1.TYPE],
			["ResizeQuality", base_config_1.TYPE],
			["ResponseType", base_config_1.TYPE],
			["ScrollBehavior", base_config_1.TYPE],
			["ScrollLogicalPosition", base_config_1.TYPE],
			["ScrollRestoration", base_config_1.TYPE],
			["ScrollSetting", base_config_1.TYPE],
			["SecurityPolicyViolationEventDisposition", base_config_1.TYPE],
			["SelectionMode", base_config_1.TYPE],
			["ServiceWorkerState", base_config_1.TYPE],
			["ServiceWorkerUpdateViaCache", base_config_1.TYPE],
			["ShadowRootMode", base_config_1.TYPE],
			["SlotAssignmentMode", base_config_1.TYPE],
			["SpeechSynthesisErrorCode", base_config_1.TYPE],
			["TextTrackKind", base_config_1.TYPE],
			["TextTrackMode", base_config_1.TYPE],
			["TouchType", base_config_1.TYPE],
			["TransferFunction", base_config_1.TYPE],
			["UserVerificationRequirement", base_config_1.TYPE],
			["VideoColorPrimaries", base_config_1.TYPE],
			["VideoEncoderBitrateMode", base_config_1.TYPE],
			["VideoFacingModeEnum", base_config_1.TYPE],
			["VideoMatrixCoefficients", base_config_1.TYPE],
			["VideoPixelFormat", base_config_1.TYPE],
			["VideoTransferCharacteristics", base_config_1.TYPE],
			["WakeLockType", base_config_1.TYPE],
			["WebGLPowerPreference", base_config_1.TYPE],
			["WebTransportCongestionControl", base_config_1.TYPE],
			["WebTransportErrorSource", base_config_1.TYPE],
			["WorkerType", base_config_1.TYPE],
			["WriteCommandType", base_config_1.TYPE],
			["XMLHttpRequestResponseType", base_config_1.TYPE]
		]
	};
})), require_dom_asynciterable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.dom_asynciterable = void 0;
	let base_config_1 = require_base_config();
	exports.dom_asynciterable = {
		libs: [],
		variables: [
			["FileSystemDirectoryHandleAsyncIterator", base_config_1.TYPE],
			["FileSystemDirectoryHandle", base_config_1.TYPE],
			["ReadableStreamAsyncIterator", base_config_1.TYPE],
			["ReadableStream", base_config_1.TYPE]
		]
	};
})), require_dom_iterable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.dom_iterable = void 0;
	let base_config_1 = require_base_config();
	exports.dom_iterable = {
		libs: [],
		variables: [
			["AudioParam", base_config_1.TYPE],
			["AudioParamMap", base_config_1.TYPE],
			["BaseAudioContext", base_config_1.TYPE],
			["CSSKeyframesRule", base_config_1.TYPE],
			["CSSNumericArray", base_config_1.TYPE],
			["CSSRuleList", base_config_1.TYPE],
			["CSSStyleDeclaration", base_config_1.TYPE],
			["CSSTransformValue", base_config_1.TYPE],
			["CSSUnparsedValue", base_config_1.TYPE],
			["Cache", base_config_1.TYPE],
			["CanvasPath", base_config_1.TYPE],
			["CanvasPathDrawingStyles", base_config_1.TYPE],
			["CookieStoreManager", base_config_1.TYPE],
			["CustomStateSet", base_config_1.TYPE],
			["DOMRectList", base_config_1.TYPE],
			["DOMStringList", base_config_1.TYPE],
			["DOMTokenList", base_config_1.TYPE],
			["DataTransferItemList", base_config_1.TYPE],
			["EventCounts", base_config_1.TYPE],
			["FileList", base_config_1.TYPE],
			["FontFaceSet", base_config_1.TYPE],
			["FormDataIterator", base_config_1.TYPE],
			["FormData", base_config_1.TYPE],
			["HTMLAllCollection", base_config_1.TYPE],
			["HTMLCollectionBase", base_config_1.TYPE],
			["HTMLCollectionOf", base_config_1.TYPE],
			["HTMLFormElement", base_config_1.TYPE],
			["HTMLSelectElement", base_config_1.TYPE],
			["HeadersIterator", base_config_1.TYPE],
			["Headers", base_config_1.TYPE],
			["Highlight", base_config_1.TYPE],
			["HighlightRegistry", base_config_1.TYPE],
			["IDBDatabase", base_config_1.TYPE],
			["IDBObjectStore", base_config_1.TYPE],
			["ImageTrackList", base_config_1.TYPE],
			["MIDIInputMap", base_config_1.TYPE],
			["MIDIOutput", base_config_1.TYPE],
			["MIDIOutputMap", base_config_1.TYPE],
			["MediaKeyStatusMapIterator", base_config_1.TYPE],
			["MediaKeyStatusMap", base_config_1.TYPE],
			["MediaList", base_config_1.TYPE],
			["MessageEvent", base_config_1.TYPE],
			["MimeTypeArray", base_config_1.TYPE],
			["NamedNodeMap", base_config_1.TYPE],
			["Navigator", base_config_1.TYPE],
			["NodeList", base_config_1.TYPE],
			["NodeListOf", base_config_1.TYPE],
			["Plugin", base_config_1.TYPE],
			["PluginArray", base_config_1.TYPE],
			["RTCRtpTransceiver", base_config_1.TYPE],
			["RTCStatsReport", base_config_1.TYPE],
			["SVGLengthList", base_config_1.TYPE],
			["SVGNumberList", base_config_1.TYPE],
			["SVGPointList", base_config_1.TYPE],
			["SVGStringList", base_config_1.TYPE],
			["SVGTransformList", base_config_1.TYPE],
			["SourceBufferList", base_config_1.TYPE],
			["SpeechRecognitionResult", base_config_1.TYPE],
			["SpeechRecognitionResultList", base_config_1.TYPE],
			["StylePropertyMapReadOnlyIterator", base_config_1.TYPE],
			["StylePropertyMapReadOnly", base_config_1.TYPE],
			["StyleSheetList", base_config_1.TYPE],
			["SubtleCrypto", base_config_1.TYPE],
			["TextTrackCueList", base_config_1.TYPE],
			["TextTrackList", base_config_1.TYPE],
			["TouchList", base_config_1.TYPE],
			["URLSearchParamsIterator", base_config_1.TYPE],
			["URLSearchParams", base_config_1.TYPE],
			["ViewTransitionTypeSet", base_config_1.TYPE],
			["WEBGL_draw_buffers", base_config_1.TYPE],
			["WEBGL_multi_draw", base_config_1.TYPE],
			["WebGL2RenderingContextBase", base_config_1.TYPE],
			["WebGL2RenderingContextOverloads", base_config_1.TYPE],
			["WebGLRenderingContextBase", base_config_1.TYPE],
			["WebGLRenderingContextOverloads", base_config_1.TYPE]
		]
	};
})), require_es5 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es5 = void 0;
	let base_config_1 = require_base_config(), decorators_1 = require_decorators(), decorators_legacy_1 = require_decorators_legacy();
	exports.es5 = {
		libs: [decorators_1.decorators, decorators_legacy_1.decorators_legacy],
		variables: [
			["Symbol", base_config_1.TYPE],
			["PropertyKey", base_config_1.TYPE],
			["PropertyDescriptor", base_config_1.TYPE],
			["PropertyDescriptorMap", base_config_1.TYPE],
			["Object", base_config_1.TYPE_VALUE],
			["ObjectConstructor", base_config_1.TYPE],
			["Function", base_config_1.TYPE_VALUE],
			["FunctionConstructor", base_config_1.TYPE],
			["ThisParameterType", base_config_1.TYPE],
			["OmitThisParameter", base_config_1.TYPE],
			["CallableFunction", base_config_1.TYPE],
			["NewableFunction", base_config_1.TYPE],
			["IArguments", base_config_1.TYPE],
			["String", base_config_1.TYPE_VALUE],
			["StringConstructor", base_config_1.TYPE],
			["Boolean", base_config_1.TYPE_VALUE],
			["BooleanConstructor", base_config_1.TYPE],
			["Number", base_config_1.TYPE_VALUE],
			["NumberConstructor", base_config_1.TYPE],
			["TemplateStringsArray", base_config_1.TYPE],
			["ImportMeta", base_config_1.TYPE],
			["ImportCallOptions", base_config_1.TYPE],
			["ImportAssertions", base_config_1.TYPE],
			["ImportAttributes", base_config_1.TYPE],
			["Math", base_config_1.TYPE_VALUE],
			["Date", base_config_1.TYPE_VALUE],
			["DateConstructor", base_config_1.TYPE],
			["RegExpMatchArray", base_config_1.TYPE],
			["RegExpExecArray", base_config_1.TYPE],
			["RegExp", base_config_1.TYPE_VALUE],
			["RegExpConstructor", base_config_1.TYPE],
			["Error", base_config_1.TYPE_VALUE],
			["ErrorConstructor", base_config_1.TYPE],
			["EvalError", base_config_1.TYPE_VALUE],
			["EvalErrorConstructor", base_config_1.TYPE],
			["RangeError", base_config_1.TYPE_VALUE],
			["RangeErrorConstructor", base_config_1.TYPE],
			["ReferenceError", base_config_1.TYPE_VALUE],
			["ReferenceErrorConstructor", base_config_1.TYPE],
			["SyntaxError", base_config_1.TYPE_VALUE],
			["SyntaxErrorConstructor", base_config_1.TYPE],
			["TypeError", base_config_1.TYPE_VALUE],
			["TypeErrorConstructor", base_config_1.TYPE],
			["URIError", base_config_1.TYPE_VALUE],
			["URIErrorConstructor", base_config_1.TYPE],
			["JSON", base_config_1.TYPE_VALUE],
			["ReadonlyArray", base_config_1.TYPE],
			["ConcatArray", base_config_1.TYPE],
			["Array", base_config_1.TYPE_VALUE],
			["ArrayConstructor", base_config_1.TYPE],
			["TypedPropertyDescriptor", base_config_1.TYPE],
			["PromiseConstructorLike", base_config_1.TYPE],
			["PromiseLike", base_config_1.TYPE],
			["Promise", base_config_1.TYPE],
			["Awaited", base_config_1.TYPE],
			["ArrayLike", base_config_1.TYPE],
			["Partial", base_config_1.TYPE],
			["Required", base_config_1.TYPE],
			["Readonly", base_config_1.TYPE],
			["Pick", base_config_1.TYPE],
			["Record", base_config_1.TYPE],
			["Exclude", base_config_1.TYPE],
			["Extract", base_config_1.TYPE],
			["Omit", base_config_1.TYPE],
			["NonNullable", base_config_1.TYPE],
			["Parameters", base_config_1.TYPE],
			["ConstructorParameters", base_config_1.TYPE],
			["ReturnType", base_config_1.TYPE],
			["InstanceType", base_config_1.TYPE],
			["Uppercase", base_config_1.TYPE],
			["Lowercase", base_config_1.TYPE],
			["Capitalize", base_config_1.TYPE],
			["Uncapitalize", base_config_1.TYPE],
			["NoInfer", base_config_1.TYPE],
			["ThisType", base_config_1.TYPE],
			["WeakKeyTypes", base_config_1.TYPE],
			["WeakKey", base_config_1.TYPE],
			["ArrayBuffer", base_config_1.TYPE_VALUE],
			["ArrayBufferTypes", base_config_1.TYPE],
			["ArrayBufferLike", base_config_1.TYPE],
			["ArrayBufferConstructor", base_config_1.TYPE],
			["ArrayBufferView", base_config_1.TYPE],
			["DataView", base_config_1.TYPE_VALUE],
			["DataViewConstructor", base_config_1.TYPE],
			["Int8Array", base_config_1.TYPE_VALUE],
			["Int8ArrayConstructor", base_config_1.TYPE],
			["Uint8Array", base_config_1.TYPE_VALUE],
			["Uint8ArrayConstructor", base_config_1.TYPE],
			["Uint8ClampedArray", base_config_1.TYPE_VALUE],
			["Uint8ClampedArrayConstructor", base_config_1.TYPE],
			["Int16Array", base_config_1.TYPE_VALUE],
			["Int16ArrayConstructor", base_config_1.TYPE],
			["Uint16Array", base_config_1.TYPE_VALUE],
			["Uint16ArrayConstructor", base_config_1.TYPE],
			["Int32Array", base_config_1.TYPE_VALUE],
			["Int32ArrayConstructor", base_config_1.TYPE],
			["Uint32Array", base_config_1.TYPE_VALUE],
			["Uint32ArrayConstructor", base_config_1.TYPE],
			["Float32Array", base_config_1.TYPE_VALUE],
			["Float32ArrayConstructor", base_config_1.TYPE],
			["Float64Array", base_config_1.TYPE_VALUE],
			["Float64ArrayConstructor", base_config_1.TYPE],
			["Intl", base_config_1.TYPE_VALUE]
		]
	};
})), require_es2015_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_collection = void 0;
	let base_config_1 = require_base_config();
	exports.es2015_collection = {
		libs: [],
		variables: [
			["Map", base_config_1.TYPE_VALUE],
			["MapConstructor", base_config_1.TYPE],
			["ReadonlyMap", base_config_1.TYPE],
			["WeakMap", base_config_1.TYPE_VALUE],
			["WeakMapConstructor", base_config_1.TYPE],
			["Set", base_config_1.TYPE_VALUE],
			["SetConstructor", base_config_1.TYPE],
			["ReadonlySet", base_config_1.TYPE],
			["WeakSet", base_config_1.TYPE_VALUE],
			["WeakSetConstructor", base_config_1.TYPE]
		]
	};
})), require_es2015_core = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_core = void 0;
	let base_config_1 = require_base_config();
	exports.es2015_core = {
		libs: [],
		variables: [
			["Array", base_config_1.TYPE],
			["ArrayConstructor", base_config_1.TYPE],
			["DateConstructor", base_config_1.TYPE],
			["Function", base_config_1.TYPE],
			["Math", base_config_1.TYPE],
			["NumberConstructor", base_config_1.TYPE],
			["ObjectConstructor", base_config_1.TYPE],
			["ReadonlyArray", base_config_1.TYPE],
			["RegExp", base_config_1.TYPE],
			["RegExpConstructor", base_config_1.TYPE],
			["String", base_config_1.TYPE],
			["StringConstructor", base_config_1.TYPE],
			["Int8Array", base_config_1.TYPE],
			["Uint8Array", base_config_1.TYPE],
			["Uint8ClampedArray", base_config_1.TYPE],
			["Int16Array", base_config_1.TYPE],
			["Uint16Array", base_config_1.TYPE],
			["Int32Array", base_config_1.TYPE],
			["Uint32Array", base_config_1.TYPE],
			["Float32Array", base_config_1.TYPE],
			["Float64Array", base_config_1.TYPE]
		]
	};
})), require_es2015_symbol = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_symbol = void 0, exports.es2015_symbol = {
		libs: [],
		variables: [["SymbolConstructor", require_base_config().TYPE]]
	};
})), require_es2015_iterable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_iterable = void 0;
	let base_config_1 = require_base_config();
	exports.es2015_iterable = {
		libs: [require_es2015_symbol().es2015_symbol],
		variables: [
			["SymbolConstructor", base_config_1.TYPE],
			["IteratorYieldResult", base_config_1.TYPE],
			["IteratorReturnResult", base_config_1.TYPE],
			["IteratorResult", base_config_1.TYPE],
			["Iterator", base_config_1.TYPE],
			["Iterable", base_config_1.TYPE],
			["IterableIterator", base_config_1.TYPE],
			["IteratorObject", base_config_1.TYPE],
			["BuiltinIteratorReturn", base_config_1.TYPE],
			["ArrayIterator", base_config_1.TYPE],
			["Array", base_config_1.TYPE],
			["ArrayConstructor", base_config_1.TYPE],
			["ReadonlyArray", base_config_1.TYPE],
			["IArguments", base_config_1.TYPE],
			["MapIterator", base_config_1.TYPE],
			["Map", base_config_1.TYPE],
			["ReadonlyMap", base_config_1.TYPE],
			["MapConstructor", base_config_1.TYPE],
			["WeakMap", base_config_1.TYPE],
			["WeakMapConstructor", base_config_1.TYPE],
			["SetIterator", base_config_1.TYPE],
			["Set", base_config_1.TYPE],
			["ReadonlySet", base_config_1.TYPE],
			["SetConstructor", base_config_1.TYPE],
			["WeakSet", base_config_1.TYPE],
			["WeakSetConstructor", base_config_1.TYPE],
			["Promise", base_config_1.TYPE],
			["PromiseConstructor", base_config_1.TYPE],
			["StringIterator", base_config_1.TYPE],
			["String", base_config_1.TYPE],
			["Int8Array", base_config_1.TYPE],
			["Int8ArrayConstructor", base_config_1.TYPE],
			["Uint8Array", base_config_1.TYPE],
			["Uint8ArrayConstructor", base_config_1.TYPE],
			["Uint8ClampedArray", base_config_1.TYPE],
			["Uint8ClampedArrayConstructor", base_config_1.TYPE],
			["Int16Array", base_config_1.TYPE],
			["Int16ArrayConstructor", base_config_1.TYPE],
			["Uint16Array", base_config_1.TYPE],
			["Uint16ArrayConstructor", base_config_1.TYPE],
			["Int32Array", base_config_1.TYPE],
			["Int32ArrayConstructor", base_config_1.TYPE],
			["Uint32Array", base_config_1.TYPE],
			["Uint32ArrayConstructor", base_config_1.TYPE],
			["Float32Array", base_config_1.TYPE],
			["Float32ArrayConstructor", base_config_1.TYPE],
			["Float64Array", base_config_1.TYPE],
			["Float64ArrayConstructor", base_config_1.TYPE]
		]
	};
})), require_es2015_generator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_generator = void 0;
	let base_config_1 = require_base_config();
	exports.es2015_generator = {
		libs: [require_es2015_iterable().es2015_iterable],
		variables: [
			["Generator", base_config_1.TYPE],
			["GeneratorFunction", base_config_1.TYPE],
			["GeneratorFunctionConstructor", base_config_1.TYPE]
		]
	};
})), require_es2015_promise = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_promise = void 0, exports.es2015_promise = {
		libs: [],
		variables: [["PromiseConstructor", require_base_config().TYPE]]
	};
})), require_es2015_proxy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_proxy = void 0;
	let base_config_1 = require_base_config();
	exports.es2015_proxy = {
		libs: [],
		variables: [["ProxyHandler", base_config_1.TYPE], ["ProxyConstructor", base_config_1.TYPE]]
	};
})), require_es2015_reflect = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_reflect = void 0, exports.es2015_reflect = {
		libs: [],
		variables: [["Reflect", require_base_config().TYPE_VALUE]]
	};
})), require_es2015_symbol_wellknown = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015_symbol_wellknown = void 0;
	let base_config_1 = require_base_config();
	exports.es2015_symbol_wellknown = {
		libs: [require_es2015_symbol().es2015_symbol],
		variables: [
			["SymbolConstructor", base_config_1.TYPE],
			["Symbol", base_config_1.TYPE],
			["Array", base_config_1.TYPE],
			["ReadonlyArray", base_config_1.TYPE],
			["Date", base_config_1.TYPE],
			["Map", base_config_1.TYPE],
			["WeakMap", base_config_1.TYPE],
			["Set", base_config_1.TYPE],
			["WeakSet", base_config_1.TYPE],
			["JSON", base_config_1.TYPE],
			["Function", base_config_1.TYPE],
			["GeneratorFunction", base_config_1.TYPE],
			["Math", base_config_1.TYPE],
			["Promise", base_config_1.TYPE],
			["PromiseConstructor", base_config_1.TYPE],
			["RegExp", base_config_1.TYPE],
			["RegExpConstructor", base_config_1.TYPE],
			["String", base_config_1.TYPE],
			["ArrayBuffer", base_config_1.TYPE],
			["DataView", base_config_1.TYPE],
			["Int8Array", base_config_1.TYPE],
			["Uint8Array", base_config_1.TYPE],
			["Uint8ClampedArray", base_config_1.TYPE],
			["Int16Array", base_config_1.TYPE],
			["Uint16Array", base_config_1.TYPE],
			["Int32Array", base_config_1.TYPE],
			["Uint32Array", base_config_1.TYPE],
			["Float32Array", base_config_1.TYPE],
			["Float64Array", base_config_1.TYPE],
			["ArrayConstructor", base_config_1.TYPE],
			["MapConstructor", base_config_1.TYPE],
			["SetConstructor", base_config_1.TYPE],
			["ArrayBufferConstructor", base_config_1.TYPE]
		]
	};
})), require_es6 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es6 = void 0;
	let es5_1 = require_es5(), es2015_collection_1 = require_es2015_collection(), es2015_core_1 = require_es2015_core(), es2015_generator_1 = require_es2015_generator(), es2015_iterable_1 = require_es2015_iterable(), es2015_promise_1 = require_es2015_promise(), es2015_proxy_1 = require_es2015_proxy(), es2015_reflect_1 = require_es2015_reflect(), es2015_symbol_1 = require_es2015_symbol(), es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown();
	exports.es6 = {
		libs: [
			es5_1.es5,
			es2015_core_1.es2015_core,
			es2015_collection_1.es2015_collection,
			es2015_iterable_1.es2015_iterable,
			es2015_generator_1.es2015_generator,
			es2015_promise_1.es2015_promise,
			es2015_proxy_1.es2015_proxy,
			es2015_reflect_1.es2015_reflect,
			es2015_symbol_1.es2015_symbol,
			es2015_symbol_wellknown_1.es2015_symbol_wellknown
		],
		variables: []
	};
})), require_es2015 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2015 = void 0;
	let es5_1 = require_es5(), es2015_collection_1 = require_es2015_collection(), es2015_core_1 = require_es2015_core(), es2015_generator_1 = require_es2015_generator(), es2015_iterable_1 = require_es2015_iterable(), es2015_promise_1 = require_es2015_promise(), es2015_proxy_1 = require_es2015_proxy(), es2015_reflect_1 = require_es2015_reflect(), es2015_symbol_1 = require_es2015_symbol(), es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown();
	exports.es2015 = {
		libs: [
			es5_1.es5,
			es2015_core_1.es2015_core,
			es2015_collection_1.es2015_collection,
			es2015_iterable_1.es2015_iterable,
			es2015_generator_1.es2015_generator,
			es2015_promise_1.es2015_promise,
			es2015_proxy_1.es2015_proxy,
			es2015_reflect_1.es2015_reflect,
			es2015_symbol_1.es2015_symbol,
			es2015_symbol_wellknown_1.es2015_symbol_wellknown
		],
		variables: []
	};
})), require_es2016_array_include = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2016_array_include = void 0;
	let base_config_1 = require_base_config();
	exports.es2016_array_include = {
		libs: [],
		variables: [
			["Array", base_config_1.TYPE],
			["ReadonlyArray", base_config_1.TYPE],
			["Int8Array", base_config_1.TYPE],
			["Uint8Array", base_config_1.TYPE],
			["Uint8ClampedArray", base_config_1.TYPE],
			["Int16Array", base_config_1.TYPE],
			["Uint16Array", base_config_1.TYPE],
			["Int32Array", base_config_1.TYPE],
			["Uint32Array", base_config_1.TYPE],
			["Float32Array", base_config_1.TYPE],
			["Float64Array", base_config_1.TYPE]
		]
	};
})), require_es2016_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2016_intl = void 0, exports.es2016_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_es7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es7 = void 0;
	let es2015_1 = require_es2015(), es2016_array_include_1 = require_es2016_array_include(), es2016_intl_1 = require_es2016_intl();
	exports.es7 = {
		libs: [
			es2015_1.es2015,
			es2016_array_include_1.es2016_array_include,
			es2016_intl_1.es2016_intl
		],
		variables: []
	};
})), require_es2016 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2016 = void 0;
	let es2015_1 = require_es2015(), es2016_array_include_1 = require_es2016_array_include(), es2016_intl_1 = require_es2016_intl();
	exports.es2016 = {
		libs: [
			es2015_1.es2015,
			es2016_array_include_1.es2016_array_include,
			es2016_intl_1.es2016_intl
		],
		variables: []
	};
})), require_scripthost = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.scripthost = void 0;
	let base_config_1 = require_base_config();
	exports.scripthost = {
		libs: [],
		variables: [
			["ActiveXObject", base_config_1.TYPE_VALUE],
			["ITextWriter", base_config_1.TYPE],
			["TextStreamBase", base_config_1.TYPE],
			["TextStreamWriter", base_config_1.TYPE],
			["TextStreamReader", base_config_1.TYPE],
			["SafeArray", base_config_1.TYPE_VALUE],
			["Enumerator", base_config_1.TYPE_VALUE],
			["EnumeratorConstructor", base_config_1.TYPE],
			["VBArray", base_config_1.TYPE_VALUE],
			["VBArrayConstructor", base_config_1.TYPE],
			["VarDate", base_config_1.TYPE_VALUE],
			["DateConstructor", base_config_1.TYPE],
			["Date", base_config_1.TYPE]
		]
	};
})), require_webworker_importscripts = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.webworker_importscripts = void 0, exports.webworker_importscripts = {
		libs: [],
		variables: []
	};
})), require_es2016_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2016_full = void 0;
	let dom_1 = require_dom(), dom_iterable_1 = require_dom_iterable(), es2016_1 = require_es2016(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2016_full = {
		libs: [
			es2016_1.es2016,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable
		],
		variables: []
	};
})), require_es2017_arraybuffer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_arraybuffer = void 0, exports.es2017_arraybuffer = {
		libs: [],
		variables: [["ArrayBufferConstructor", require_base_config().TYPE]]
	};
})), require_es2017_date = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_date = void 0, exports.es2017_date = {
		libs: [],
		variables: [["DateConstructor", require_base_config().TYPE]]
	};
})), require_es2017_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_intl = void 0, exports.es2017_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_es2017_object = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_object = void 0, exports.es2017_object = {
		libs: [],
		variables: [["ObjectConstructor", require_base_config().TYPE]]
	};
})), require_es2017_sharedmemory = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_sharedmemory = void 0;
	let base_config_1 = require_base_config(), es2015_symbol_1 = require_es2015_symbol(), es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown();
	exports.es2017_sharedmemory = {
		libs: [es2015_symbol_1.es2015_symbol, es2015_symbol_wellknown_1.es2015_symbol_wellknown],
		variables: [
			["SharedArrayBuffer", base_config_1.TYPE_VALUE],
			["SharedArrayBufferConstructor", base_config_1.TYPE],
			["ArrayBufferTypes", base_config_1.TYPE],
			["Atomics", base_config_1.TYPE_VALUE]
		]
	};
})), require_es2017_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_string = void 0, exports.es2017_string = {
		libs: [],
		variables: [["String", require_base_config().TYPE]]
	};
})), require_es2017_typedarrays = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_typedarrays = void 0;
	let base_config_1 = require_base_config();
	exports.es2017_typedarrays = {
		libs: [],
		variables: [
			["Int8ArrayConstructor", base_config_1.TYPE],
			["Uint8ArrayConstructor", base_config_1.TYPE],
			["Uint8ClampedArrayConstructor", base_config_1.TYPE],
			["Int16ArrayConstructor", base_config_1.TYPE],
			["Uint16ArrayConstructor", base_config_1.TYPE],
			["Int32ArrayConstructor", base_config_1.TYPE],
			["Uint32ArrayConstructor", base_config_1.TYPE],
			["Float32ArrayConstructor", base_config_1.TYPE],
			["Float64ArrayConstructor", base_config_1.TYPE]
		]
	};
})), require_es2017 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017 = void 0;
	let es2016_1 = require_es2016(), es2017_arraybuffer_1 = require_es2017_arraybuffer(), es2017_date_1 = require_es2017_date(), es2017_intl_1 = require_es2017_intl(), es2017_object_1 = require_es2017_object(), es2017_sharedmemory_1 = require_es2017_sharedmemory(), es2017_string_1 = require_es2017_string(), es2017_typedarrays_1 = require_es2017_typedarrays();
	exports.es2017 = {
		libs: [
			es2016_1.es2016,
			es2017_arraybuffer_1.es2017_arraybuffer,
			es2017_date_1.es2017_date,
			es2017_intl_1.es2017_intl,
			es2017_object_1.es2017_object,
			es2017_sharedmemory_1.es2017_sharedmemory,
			es2017_string_1.es2017_string,
			es2017_typedarrays_1.es2017_typedarrays
		],
		variables: []
	};
})), require_es2017_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2017_full = void 0;
	let dom_1 = require_dom(), dom_iterable_1 = require_dom_iterable(), es2017_1 = require_es2017(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2017_full = {
		libs: [
			es2017_1.es2017,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable
		],
		variables: []
	};
})), require_es2018_asynciterable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2018_asynciterable = void 0;
	let base_config_1 = require_base_config(), es2015_iterable_1 = require_es2015_iterable();
	exports.es2018_asynciterable = {
		libs: [require_es2015_symbol().es2015_symbol, es2015_iterable_1.es2015_iterable],
		variables: [
			["SymbolConstructor", base_config_1.TYPE],
			["AsyncIterator", base_config_1.TYPE],
			["AsyncIterable", base_config_1.TYPE],
			["AsyncIterableIterator", base_config_1.TYPE],
			["AsyncIteratorObject", base_config_1.TYPE]
		]
	};
})), require_es2018_asyncgenerator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2018_asyncgenerator = void 0;
	let base_config_1 = require_base_config();
	exports.es2018_asyncgenerator = {
		libs: [require_es2018_asynciterable().es2018_asynciterable],
		variables: [
			["AsyncGenerator", base_config_1.TYPE],
			["AsyncGeneratorFunction", base_config_1.TYPE],
			["AsyncGeneratorFunctionConstructor", base_config_1.TYPE]
		]
	};
})), require_es2018_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2018_intl = void 0, exports.es2018_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_es2018_promise = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2018_promise = void 0, exports.es2018_promise = {
		libs: [],
		variables: [["Promise", require_base_config().TYPE]]
	};
})), require_es2018_regexp = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2018_regexp = void 0;
	let base_config_1 = require_base_config();
	exports.es2018_regexp = {
		libs: [],
		variables: [
			["RegExpMatchArray", base_config_1.TYPE],
			["RegExpExecArray", base_config_1.TYPE],
			["RegExp", base_config_1.TYPE]
		]
	};
})), require_es2018 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2018 = void 0;
	let es2017_1 = require_es2017(), es2018_asyncgenerator_1 = require_es2018_asyncgenerator(), es2018_asynciterable_1 = require_es2018_asynciterable(), es2018_intl_1 = require_es2018_intl(), es2018_promise_1 = require_es2018_promise(), es2018_regexp_1 = require_es2018_regexp();
	exports.es2018 = {
		libs: [
			es2017_1.es2017,
			es2018_asynciterable_1.es2018_asynciterable,
			es2018_asyncgenerator_1.es2018_asyncgenerator,
			es2018_promise_1.es2018_promise,
			es2018_regexp_1.es2018_regexp,
			es2018_intl_1.es2018_intl
		],
		variables: []
	};
})), require_es2018_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2018_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es2018_1 = require_es2018(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2018_full = {
		libs: [
			es2018_1.es2018,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_es2019_array = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2019_array = void 0;
	let base_config_1 = require_base_config();
	exports.es2019_array = {
		libs: [],
		variables: [
			["FlatArray", base_config_1.TYPE],
			["ReadonlyArray", base_config_1.TYPE],
			["Array", base_config_1.TYPE]
		]
	};
})), require_es2019_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2019_intl = void 0, exports.es2019_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_es2019_object = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2019_object = void 0;
	let base_config_1 = require_base_config();
	exports.es2019_object = {
		libs: [require_es2015_iterable().es2015_iterable],
		variables: [["ObjectConstructor", base_config_1.TYPE]]
	};
})), require_es2019_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2019_string = void 0, exports.es2019_string = {
		libs: [],
		variables: [["String", require_base_config().TYPE]]
	};
})), require_es2019_symbol = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2019_symbol = void 0, exports.es2019_symbol = {
		libs: [],
		variables: [["Symbol", require_base_config().TYPE]]
	};
})), require_es2019 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2019 = void 0;
	let es2018_1 = require_es2018(), es2019_array_1 = require_es2019_array(), es2019_intl_1 = require_es2019_intl(), es2019_object_1 = require_es2019_object(), es2019_string_1 = require_es2019_string(), es2019_symbol_1 = require_es2019_symbol();
	exports.es2019 = {
		libs: [
			es2018_1.es2018,
			es2019_array_1.es2019_array,
			es2019_object_1.es2019_object,
			es2019_string_1.es2019_string,
			es2019_symbol_1.es2019_symbol,
			es2019_intl_1.es2019_intl
		],
		variables: []
	};
})), require_es2019_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2019_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es2019_1 = require_es2019(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2019_full = {
		libs: [
			es2019_1.es2019,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_es2020_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_intl = void 0;
	let base_config_1 = require_base_config();
	exports.es2020_intl = {
		libs: [require_es2018_intl().es2018_intl],
		variables: [["Intl", base_config_1.TYPE_VALUE]]
	};
})), require_es2020_bigint = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_bigint = void 0;
	let base_config_1 = require_base_config();
	exports.es2020_bigint = {
		libs: [require_es2020_intl().es2020_intl],
		variables: [
			["BigIntToLocaleStringOptions", base_config_1.TYPE],
			["BigInt", base_config_1.TYPE_VALUE],
			["BigIntConstructor", base_config_1.TYPE],
			["BigInt64Array", base_config_1.TYPE_VALUE],
			["BigInt64ArrayConstructor", base_config_1.TYPE],
			["BigUint64Array", base_config_1.TYPE_VALUE],
			["BigUint64ArrayConstructor", base_config_1.TYPE],
			["DataView", base_config_1.TYPE],
			["Intl", base_config_1.TYPE_VALUE]
		]
	};
})), require_es2020_date = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_date = void 0;
	let base_config_1 = require_base_config();
	exports.es2020_date = {
		libs: [require_es2020_intl().es2020_intl],
		variables: [["Date", base_config_1.TYPE]]
	};
})), require_es2020_number = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_number = void 0;
	let base_config_1 = require_base_config();
	exports.es2020_number = {
		libs: [require_es2020_intl().es2020_intl],
		variables: [["Number", base_config_1.TYPE]]
	};
})), require_es2020_promise = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_promise = void 0;
	let base_config_1 = require_base_config();
	exports.es2020_promise = {
		libs: [],
		variables: [
			["PromiseFulfilledResult", base_config_1.TYPE],
			["PromiseRejectedResult", base_config_1.TYPE],
			["PromiseSettledResult", base_config_1.TYPE],
			["PromiseConstructor", base_config_1.TYPE]
		]
	};
})), require_es2020_sharedmemory = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_sharedmemory = void 0;
	let base_config_1 = require_base_config();
	exports.es2020_sharedmemory = {
		libs: [require_es2020_bigint().es2020_bigint],
		variables: [["Atomics", base_config_1.TYPE]]
	};
})), require_es2020_symbol_wellknown = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_symbol_wellknown = void 0;
	let base_config_1 = require_base_config(), es2015_iterable_1 = require_es2015_iterable(), es2015_symbol_1 = require_es2015_symbol();
	exports.es2020_symbol_wellknown = {
		libs: [es2015_iterable_1.es2015_iterable, es2015_symbol_1.es2015_symbol],
		variables: [
			["SymbolConstructor", base_config_1.TYPE],
			["RegExpStringIterator", base_config_1.TYPE],
			["RegExp", base_config_1.TYPE]
		]
	};
})), require_es2020_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_string = void 0;
	let base_config_1 = require_base_config(), es2015_iterable_1 = require_es2015_iterable(), es2020_intl_1 = require_es2020_intl(), es2020_symbol_wellknown_1 = require_es2020_symbol_wellknown();
	exports.es2020_string = {
		libs: [
			es2015_iterable_1.es2015_iterable,
			es2020_intl_1.es2020_intl,
			es2020_symbol_wellknown_1.es2020_symbol_wellknown
		],
		variables: [["String", base_config_1.TYPE]]
	};
})), require_es2020 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020 = void 0;
	let es2019_1 = require_es2019(), es2020_bigint_1 = require_es2020_bigint(), es2020_date_1 = require_es2020_date(), es2020_intl_1 = require_es2020_intl(), es2020_number_1 = require_es2020_number(), es2020_promise_1 = require_es2020_promise(), es2020_sharedmemory_1 = require_es2020_sharedmemory(), es2020_string_1 = require_es2020_string(), es2020_symbol_wellknown_1 = require_es2020_symbol_wellknown();
	exports.es2020 = {
		libs: [
			es2019_1.es2019,
			es2020_bigint_1.es2020_bigint,
			es2020_date_1.es2020_date,
			es2020_number_1.es2020_number,
			es2020_promise_1.es2020_promise,
			es2020_sharedmemory_1.es2020_sharedmemory,
			es2020_string_1.es2020_string,
			es2020_symbol_wellknown_1.es2020_symbol_wellknown,
			es2020_intl_1.es2020_intl
		],
		variables: []
	};
})), require_es2020_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2020_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es2020_1 = require_es2020(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2020_full = {
		libs: [
			es2020_1.es2020,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_es2021_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2021_intl = void 0, exports.es2021_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_es2021_promise = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2021_promise = void 0;
	let base_config_1 = require_base_config();
	exports.es2021_promise = {
		libs: [],
		variables: [
			["AggregateError", base_config_1.TYPE_VALUE],
			["AggregateErrorConstructor", base_config_1.TYPE],
			["PromiseConstructor", base_config_1.TYPE]
		]
	};
})), require_es2021_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2021_string = void 0, exports.es2021_string = {
		libs: [],
		variables: [["String", require_base_config().TYPE]]
	};
})), require_es2021_weakref = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2021_weakref = void 0;
	let base_config_1 = require_base_config();
	exports.es2021_weakref = {
		libs: [require_es2015_symbol_wellknown().es2015_symbol_wellknown],
		variables: [
			["WeakRef", base_config_1.TYPE_VALUE],
			["WeakRefConstructor", base_config_1.TYPE],
			["FinalizationRegistry", base_config_1.TYPE_VALUE],
			["FinalizationRegistryConstructor", base_config_1.TYPE]
		]
	};
})), require_es2021 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2021 = void 0;
	let es2020_1 = require_es2020(), es2021_intl_1 = require_es2021_intl(), es2021_promise_1 = require_es2021_promise(), es2021_string_1 = require_es2021_string(), es2021_weakref_1 = require_es2021_weakref();
	exports.es2021 = {
		libs: [
			es2020_1.es2020,
			es2021_promise_1.es2021_promise,
			es2021_string_1.es2021_string,
			es2021_weakref_1.es2021_weakref,
			es2021_intl_1.es2021_intl
		],
		variables: []
	};
})), require_es2021_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2021_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es2021_1 = require_es2021(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2021_full = {
		libs: [
			es2021_1.es2021,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_es2022_array = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022_array = void 0;
	let base_config_1 = require_base_config();
	exports.es2022_array = {
		libs: [],
		variables: [
			["Array", base_config_1.TYPE],
			["ReadonlyArray", base_config_1.TYPE],
			["Int8Array", base_config_1.TYPE],
			["Uint8Array", base_config_1.TYPE],
			["Uint8ClampedArray", base_config_1.TYPE],
			["Int16Array", base_config_1.TYPE],
			["Uint16Array", base_config_1.TYPE],
			["Int32Array", base_config_1.TYPE],
			["Uint32Array", base_config_1.TYPE],
			["Float32Array", base_config_1.TYPE],
			["Float64Array", base_config_1.TYPE],
			["BigInt64Array", base_config_1.TYPE],
			["BigUint64Array", base_config_1.TYPE]
		]
	};
})), require_es2022_error = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022_error = void 0;
	let base_config_1 = require_base_config();
	exports.es2022_error = {
		libs: [require_es2021_promise().es2021_promise],
		variables: [
			["ErrorOptions", base_config_1.TYPE],
			["Error", base_config_1.TYPE],
			["ErrorConstructor", base_config_1.TYPE],
			["EvalErrorConstructor", base_config_1.TYPE],
			["RangeErrorConstructor", base_config_1.TYPE],
			["ReferenceErrorConstructor", base_config_1.TYPE],
			["SyntaxErrorConstructor", base_config_1.TYPE],
			["TypeErrorConstructor", base_config_1.TYPE],
			["URIErrorConstructor", base_config_1.TYPE],
			["AggregateErrorConstructor", base_config_1.TYPE]
		]
	};
})), require_es2022_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022_intl = void 0, exports.es2022_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_es2022_object = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022_object = void 0, exports.es2022_object = {
		libs: [],
		variables: [["ObjectConstructor", require_base_config().TYPE]]
	};
})), require_es2022_regexp = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022_regexp = void 0;
	let base_config_1 = require_base_config();
	exports.es2022_regexp = {
		libs: [],
		variables: [
			["RegExpMatchArray", base_config_1.TYPE],
			["RegExpExecArray", base_config_1.TYPE],
			["RegExpIndicesArray", base_config_1.TYPE],
			["RegExp", base_config_1.TYPE]
		]
	};
})), require_es2022_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022_string = void 0, exports.es2022_string = {
		libs: [],
		variables: [["String", require_base_config().TYPE]]
	};
})), require_es2022 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022 = void 0;
	let es2021_1 = require_es2021(), es2022_array_1 = require_es2022_array(), es2022_error_1 = require_es2022_error(), es2022_intl_1 = require_es2022_intl(), es2022_object_1 = require_es2022_object(), es2022_regexp_1 = require_es2022_regexp(), es2022_string_1 = require_es2022_string();
	exports.es2022 = {
		libs: [
			es2021_1.es2021,
			es2022_array_1.es2022_array,
			es2022_error_1.es2022_error,
			es2022_intl_1.es2022_intl,
			es2022_object_1.es2022_object,
			es2022_regexp_1.es2022_regexp,
			es2022_string_1.es2022_string
		],
		variables: []
	};
})), require_es2022_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2022_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es2022_1 = require_es2022(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2022_full = {
		libs: [
			es2022_1.es2022,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_es2023_array = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2023_array = void 0;
	let base_config_1 = require_base_config();
	exports.es2023_array = {
		libs: [],
		variables: [
			["Array", base_config_1.TYPE],
			["ReadonlyArray", base_config_1.TYPE],
			["Int8Array", base_config_1.TYPE],
			["Uint8Array", base_config_1.TYPE],
			["Uint8ClampedArray", base_config_1.TYPE],
			["Int16Array", base_config_1.TYPE],
			["Uint16Array", base_config_1.TYPE],
			["Int32Array", base_config_1.TYPE],
			["Uint32Array", base_config_1.TYPE],
			["Float32Array", base_config_1.TYPE],
			["Float64Array", base_config_1.TYPE],
			["BigInt64Array", base_config_1.TYPE],
			["BigUint64Array", base_config_1.TYPE]
		]
	};
})), require_es2023_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2023_collection = void 0, exports.es2023_collection = {
		libs: [],
		variables: [["WeakKeyTypes", require_base_config().TYPE]]
	};
})), require_es2023_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2023_intl = void 0, exports.es2023_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_es2023 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2023 = void 0;
	let es2022_1 = require_es2022(), es2023_array_1 = require_es2023_array(), es2023_collection_1 = require_es2023_collection(), es2023_intl_1 = require_es2023_intl();
	exports.es2023 = {
		libs: [
			es2022_1.es2022,
			es2023_array_1.es2023_array,
			es2023_collection_1.es2023_collection,
			es2023_intl_1.es2023_intl
		],
		variables: []
	};
})), require_es2023_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2023_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es2023_1 = require_es2023(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2023_full = {
		libs: [
			es2023_1.es2023,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_es2024_arraybuffer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_arraybuffer = void 0;
	let base_config_1 = require_base_config();
	exports.es2024_arraybuffer = {
		libs: [],
		variables: [["ArrayBuffer", base_config_1.TYPE], ["ArrayBufferConstructor", base_config_1.TYPE]]
	};
})), require_es2024_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_collection = void 0, exports.es2024_collection = {
		libs: [],
		variables: [["MapConstructor", require_base_config().TYPE]]
	};
})), require_es2024_object = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_object = void 0, exports.es2024_object = {
		libs: [],
		variables: [["ObjectConstructor", require_base_config().TYPE]]
	};
})), require_es2024_promise = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_promise = void 0;
	let base_config_1 = require_base_config();
	exports.es2024_promise = {
		libs: [],
		variables: [["PromiseWithResolvers", base_config_1.TYPE], ["PromiseConstructor", base_config_1.TYPE]]
	};
})), require_es2024_regexp = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_regexp = void 0, exports.es2024_regexp = {
		libs: [],
		variables: [["RegExp", require_base_config().TYPE]]
	};
})), require_es2024_sharedmemory = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_sharedmemory = void 0;
	let base_config_1 = require_base_config();
	exports.es2024_sharedmemory = {
		libs: [require_es2020_bigint().es2020_bigint],
		variables: [
			["Atomics", base_config_1.TYPE],
			["SharedArrayBuffer", base_config_1.TYPE],
			["SharedArrayBufferConstructor", base_config_1.TYPE]
		]
	};
})), require_es2024_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_string = void 0, exports.es2024_string = {
		libs: [],
		variables: [["String", require_base_config().TYPE]]
	};
})), require_es2024 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024 = void 0;
	let es2023_1 = require_es2023(), es2024_arraybuffer_1 = require_es2024_arraybuffer(), es2024_collection_1 = require_es2024_collection(), es2024_object_1 = require_es2024_object(), es2024_promise_1 = require_es2024_promise(), es2024_regexp_1 = require_es2024_regexp(), es2024_sharedmemory_1 = require_es2024_sharedmemory(), es2024_string_1 = require_es2024_string();
	exports.es2024 = {
		libs: [
			es2023_1.es2023,
			es2024_arraybuffer_1.es2024_arraybuffer,
			es2024_collection_1.es2024_collection,
			es2024_object_1.es2024_object,
			es2024_promise_1.es2024_promise,
			es2024_regexp_1.es2024_regexp,
			es2024_sharedmemory_1.es2024_sharedmemory,
			es2024_string_1.es2024_string
		],
		variables: []
	};
})), require_es2024_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.es2024_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es2024_1 = require_es2024(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.es2024_full = {
		libs: [
			es2024_1.es2024,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_esnext_array = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_array = void 0, exports.esnext_array = {
		libs: [],
		variables: [["ArrayConstructor", require_base_config().TYPE]]
	};
})), require_esnext_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_collection = void 0;
	let base_config_1 = require_base_config();
	exports.esnext_collection = {
		libs: [require_es2024_collection().es2024_collection],
		variables: [
			["ReadonlySetLike", base_config_1.TYPE],
			["Set", base_config_1.TYPE],
			["ReadonlySet", base_config_1.TYPE]
		]
	};
})), require_esnext_decorators = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_decorators = void 0;
	let base_config_1 = require_base_config(), decorators_1 = require_decorators();
	exports.esnext_decorators = {
		libs: [require_es2015_symbol().es2015_symbol, decorators_1.decorators],
		variables: [["SymbolConstructor", base_config_1.TYPE], ["Function", base_config_1.TYPE]]
	};
})), require_esnext_disposable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_disposable = void 0;
	let base_config_1 = require_base_config(), es2015_iterable_1 = require_es2015_iterable(), es2015_symbol_1 = require_es2015_symbol(), es2018_asynciterable_1 = require_es2018_asynciterable();
	exports.esnext_disposable = {
		libs: [
			es2015_symbol_1.es2015_symbol,
			es2015_iterable_1.es2015_iterable,
			es2018_asynciterable_1.es2018_asynciterable
		],
		variables: [
			["SymbolConstructor", base_config_1.TYPE],
			["Disposable", base_config_1.TYPE],
			["AsyncDisposable", base_config_1.TYPE],
			["SuppressedError", base_config_1.TYPE_VALUE],
			["SuppressedErrorConstructor", base_config_1.TYPE],
			["DisposableStack", base_config_1.TYPE_VALUE],
			["DisposableStackConstructor", base_config_1.TYPE],
			["AsyncDisposableStack", base_config_1.TYPE_VALUE],
			["AsyncDisposableStackConstructor", base_config_1.TYPE],
			["IteratorObject", base_config_1.TYPE],
			["AsyncIteratorObject", base_config_1.TYPE]
		]
	};
})), require_esnext_error = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_error = void 0, exports.esnext_error = {
		libs: [],
		variables: [["ErrorConstructor", require_base_config().TYPE]]
	};
})), require_esnext_float16 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_float16 = void 0;
	let base_config_1 = require_base_config(), es2015_iterable_1 = require_es2015_iterable();
	exports.esnext_float16 = {
		libs: [require_es2015_symbol().es2015_symbol, es2015_iterable_1.es2015_iterable],
		variables: [
			["Float16Array", base_config_1.TYPE_VALUE],
			["Float16ArrayConstructor", base_config_1.TYPE],
			["Math", base_config_1.TYPE],
			["DataView", base_config_1.TYPE]
		]
	};
})), require_esnext_intl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_intl = void 0, exports.esnext_intl = {
		libs: [],
		variables: [["Intl", require_base_config().TYPE_VALUE]]
	};
})), require_esnext_iterator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_iterator = void 0;
	let base_config_1 = require_base_config();
	exports.esnext_iterator = {
		libs: [require_es2015_iterable().es2015_iterable],
		variables: [["Iterator", base_config_1.TYPE_VALUE], ["IteratorObjectConstructor", base_config_1.TYPE]]
	};
})), require_esnext_promise = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_promise = void 0, exports.esnext_promise = {
		libs: [],
		variables: [["PromiseConstructor", require_base_config().TYPE]]
	};
})), require_esnext_sharedmemory = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_sharedmemory = void 0, exports.esnext_sharedmemory = {
		libs: [],
		variables: [["Atomics", require_base_config().TYPE]]
	};
})), require_esnext = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext = void 0;
	let es2024_1 = require_es2024(), esnext_array_1 = require_esnext_array(), esnext_collection_1 = require_esnext_collection(), esnext_decorators_1 = require_esnext_decorators(), esnext_disposable_1 = require_esnext_disposable(), esnext_error_1 = require_esnext_error(), esnext_float16_1 = require_esnext_float16(), esnext_intl_1 = require_esnext_intl(), esnext_iterator_1 = require_esnext_iterator(), esnext_promise_1 = require_esnext_promise(), esnext_sharedmemory_1 = require_esnext_sharedmemory();
	exports.esnext = {
		libs: [
			es2024_1.es2024,
			esnext_intl_1.esnext_intl,
			esnext_decorators_1.esnext_decorators,
			esnext_disposable_1.esnext_disposable,
			esnext_collection_1.esnext_collection,
			esnext_array_1.esnext_array,
			esnext_iterator_1.esnext_iterator,
			esnext_promise_1.esnext_promise,
			esnext_float16_1.esnext_float16,
			esnext_error_1.esnext_error,
			esnext_sharedmemory_1.esnext_sharedmemory
		],
		variables: []
	};
})), require_esnext_asynciterable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_asynciterable = void 0;
	let base_config_1 = require_base_config(), es2015_iterable_1 = require_es2015_iterable();
	exports.esnext_asynciterable = {
		libs: [require_es2015_symbol().es2015_symbol, es2015_iterable_1.es2015_iterable],
		variables: [
			["SymbolConstructor", base_config_1.TYPE],
			["AsyncIterator", base_config_1.TYPE],
			["AsyncIterable", base_config_1.TYPE],
			["AsyncIterableIterator", base_config_1.TYPE],
			["AsyncIteratorObject", base_config_1.TYPE]
		]
	};
})), require_esnext_bigint = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_bigint = void 0;
	let base_config_1 = require_base_config();
	exports.esnext_bigint = {
		libs: [require_es2020_intl().es2020_intl],
		variables: [
			["BigIntToLocaleStringOptions", base_config_1.TYPE],
			["BigInt", base_config_1.TYPE_VALUE],
			["BigIntConstructor", base_config_1.TYPE],
			["BigInt64Array", base_config_1.TYPE_VALUE],
			["BigInt64ArrayConstructor", base_config_1.TYPE],
			["BigUint64Array", base_config_1.TYPE_VALUE],
			["BigUint64ArrayConstructor", base_config_1.TYPE],
			["DataView", base_config_1.TYPE],
			["Intl", base_config_1.TYPE_VALUE]
		]
	};
})), require_esnext_full = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_full = void 0;
	let dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), esnext_1 = require_esnext(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.esnext_full = {
		libs: [
			esnext_1.esnext,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost,
			dom_iterable_1.dom_iterable,
			dom_asynciterable_1.dom_asynciterable
		],
		variables: []
	};
})), require_esnext_object = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_object = void 0, exports.esnext_object = {
		libs: [],
		variables: [["ObjectConstructor", require_base_config().TYPE]]
	};
})), require_esnext_regexp = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_regexp = void 0, exports.esnext_regexp = {
		libs: [],
		variables: [["RegExp", require_base_config().TYPE]]
	};
})), require_esnext_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_string = void 0, exports.esnext_string = {
		libs: [],
		variables: [["String", require_base_config().TYPE]]
	};
})), require_esnext_symbol = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_symbol = void 0, exports.esnext_symbol = {
		libs: [],
		variables: [["Symbol", require_base_config().TYPE]]
	};
})), require_esnext_weakref = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.esnext_weakref = void 0;
	let base_config_1 = require_base_config();
	exports.esnext_weakref = {
		libs: [require_es2015_symbol_wellknown().es2015_symbol_wellknown],
		variables: [
			["WeakRef", base_config_1.TYPE_VALUE],
			["WeakRefConstructor", base_config_1.TYPE],
			["FinalizationRegistry", base_config_1.TYPE_VALUE],
			["FinalizationRegistryConstructor", base_config_1.TYPE]
		]
	};
})), require_lib$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.lib = void 0;
	let dom_1 = require_dom(), es5_1 = require_es5(), scripthost_1 = require_scripthost(), webworker_importscripts_1 = require_webworker_importscripts();
	exports.lib = {
		libs: [
			es5_1.es5,
			dom_1.dom,
			webworker_importscripts_1.webworker_importscripts,
			scripthost_1.scripthost
		],
		variables: []
	};
})), require_webworker = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.webworker = void 0;
	let base_config_1 = require_base_config();
	exports.webworker = {
		libs: [],
		variables: [
			["AddEventListenerOptions", base_config_1.TYPE],
			["AesCbcParams", base_config_1.TYPE],
			["AesCtrParams", base_config_1.TYPE],
			["AesDerivedKeyParams", base_config_1.TYPE],
			["AesGcmParams", base_config_1.TYPE],
			["AesKeyAlgorithm", base_config_1.TYPE],
			["AesKeyGenParams", base_config_1.TYPE],
			["Algorithm", base_config_1.TYPE],
			["AudioConfiguration", base_config_1.TYPE],
			["AudioDataCopyToOptions", base_config_1.TYPE],
			["AudioDataInit", base_config_1.TYPE],
			["AudioDecoderConfig", base_config_1.TYPE],
			["AudioDecoderInit", base_config_1.TYPE],
			["AudioDecoderSupport", base_config_1.TYPE],
			["AudioEncoderConfig", base_config_1.TYPE],
			["AudioEncoderInit", base_config_1.TYPE],
			["AudioEncoderSupport", base_config_1.TYPE],
			["AvcEncoderConfig", base_config_1.TYPE],
			["BlobPropertyBag", base_config_1.TYPE],
			["CSSMatrixComponentOptions", base_config_1.TYPE],
			["CSSNumericType", base_config_1.TYPE],
			["CacheQueryOptions", base_config_1.TYPE],
			["ClientQueryOptions", base_config_1.TYPE],
			["CloseEventInit", base_config_1.TYPE],
			["CookieInit", base_config_1.TYPE],
			["CookieListItem", base_config_1.TYPE],
			["CookieStoreDeleteOptions", base_config_1.TYPE],
			["CookieStoreGetOptions", base_config_1.TYPE],
			["CryptoKeyPair", base_config_1.TYPE],
			["CustomEventInit", base_config_1.TYPE],
			["DOMMatrix2DInit", base_config_1.TYPE],
			["DOMMatrixInit", base_config_1.TYPE],
			["DOMPointInit", base_config_1.TYPE],
			["DOMQuadInit", base_config_1.TYPE],
			["DOMRectInit", base_config_1.TYPE],
			["EcKeyGenParams", base_config_1.TYPE],
			["EcKeyImportParams", base_config_1.TYPE],
			["EcdhKeyDeriveParams", base_config_1.TYPE],
			["EcdsaParams", base_config_1.TYPE],
			["EncodedAudioChunkInit", base_config_1.TYPE],
			["EncodedAudioChunkMetadata", base_config_1.TYPE],
			["EncodedVideoChunkInit", base_config_1.TYPE],
			["EncodedVideoChunkMetadata", base_config_1.TYPE],
			["ErrorEventInit", base_config_1.TYPE],
			["EventInit", base_config_1.TYPE],
			["EventListenerOptions", base_config_1.TYPE],
			["EventSourceInit", base_config_1.TYPE],
			["ExtendableCookieChangeEventInit", base_config_1.TYPE],
			["ExtendableEventInit", base_config_1.TYPE],
			["ExtendableMessageEventInit", base_config_1.TYPE],
			["FetchEventInit", base_config_1.TYPE],
			["FilePropertyBag", base_config_1.TYPE],
			["FileSystemCreateWritableOptions", base_config_1.TYPE],
			["FileSystemGetDirectoryOptions", base_config_1.TYPE],
			["FileSystemGetFileOptions", base_config_1.TYPE],
			["FileSystemReadWriteOptions", base_config_1.TYPE],
			["FileSystemRemoveOptions", base_config_1.TYPE],
			["FontFaceDescriptors", base_config_1.TYPE],
			["FontFaceSetLoadEventInit", base_config_1.TYPE],
			["GetNotificationOptions", base_config_1.TYPE],
			["HkdfParams", base_config_1.TYPE],
			["HmacImportParams", base_config_1.TYPE],
			["HmacKeyGenParams", base_config_1.TYPE],
			["IDBDatabaseInfo", base_config_1.TYPE],
			["IDBIndexParameters", base_config_1.TYPE],
			["IDBObjectStoreParameters", base_config_1.TYPE],
			["IDBTransactionOptions", base_config_1.TYPE],
			["IDBVersionChangeEventInit", base_config_1.TYPE],
			["ImageBitmapOptions", base_config_1.TYPE],
			["ImageBitmapRenderingContextSettings", base_config_1.TYPE],
			["ImageDataSettings", base_config_1.TYPE],
			["ImageDecodeOptions", base_config_1.TYPE],
			["ImageDecodeResult", base_config_1.TYPE],
			["ImageDecoderInit", base_config_1.TYPE],
			["ImageEncodeOptions", base_config_1.TYPE],
			["JsonWebKey", base_config_1.TYPE],
			["KeyAlgorithm", base_config_1.TYPE],
			["KeySystemTrackConfiguration", base_config_1.TYPE],
			["LockInfo", base_config_1.TYPE],
			["LockManagerSnapshot", base_config_1.TYPE],
			["LockOptions", base_config_1.TYPE],
			["MediaCapabilitiesDecodingInfo", base_config_1.TYPE],
			["MediaCapabilitiesEncodingInfo", base_config_1.TYPE],
			["MediaCapabilitiesInfo", base_config_1.TYPE],
			["MediaCapabilitiesKeySystemConfiguration", base_config_1.TYPE],
			["MediaConfiguration", base_config_1.TYPE],
			["MediaDecodingConfiguration", base_config_1.TYPE],
			["MediaEncodingConfiguration", base_config_1.TYPE],
			["MediaStreamTrackProcessorInit", base_config_1.TYPE],
			["MessageEventInit", base_config_1.TYPE],
			["MultiCacheQueryOptions", base_config_1.TYPE],
			["NavigationPreloadState", base_config_1.TYPE],
			["NotificationEventInit", base_config_1.TYPE],
			["NotificationOptions", base_config_1.TYPE],
			["OpusEncoderConfig", base_config_1.TYPE],
			["Pbkdf2Params", base_config_1.TYPE],
			["PerformanceMarkOptions", base_config_1.TYPE],
			["PerformanceMeasureOptions", base_config_1.TYPE],
			["PerformanceObserverInit", base_config_1.TYPE],
			["PermissionDescriptor", base_config_1.TYPE],
			["PlaneLayout", base_config_1.TYPE],
			["ProgressEventInit", base_config_1.TYPE],
			["PromiseRejectionEventInit", base_config_1.TYPE],
			["PushEventInit", base_config_1.TYPE],
			["PushSubscriptionChangeEventInit", base_config_1.TYPE],
			["PushSubscriptionJSON", base_config_1.TYPE],
			["PushSubscriptionOptionsInit", base_config_1.TYPE],
			["QueuingStrategy", base_config_1.TYPE],
			["QueuingStrategyInit", base_config_1.TYPE],
			["RTCEncodedAudioFrameMetadata", base_config_1.TYPE],
			["RTCEncodedFrameMetadata", base_config_1.TYPE],
			["RTCEncodedVideoFrameMetadata", base_config_1.TYPE],
			["ReadableStreamGetReaderOptions", base_config_1.TYPE],
			["ReadableStreamIteratorOptions", base_config_1.TYPE],
			["ReadableStreamReadDoneResult", base_config_1.TYPE],
			["ReadableStreamReadValueResult", base_config_1.TYPE],
			["ReadableWritablePair", base_config_1.TYPE],
			["RegistrationOptions", base_config_1.TYPE],
			["ReportingObserverOptions", base_config_1.TYPE],
			["RequestInit", base_config_1.TYPE],
			["ResponseInit", base_config_1.TYPE],
			["RsaHashedImportParams", base_config_1.TYPE],
			["RsaHashedKeyGenParams", base_config_1.TYPE],
			["RsaKeyGenParams", base_config_1.TYPE],
			["RsaOaepParams", base_config_1.TYPE],
			["RsaOtherPrimesInfo", base_config_1.TYPE],
			["RsaPssParams", base_config_1.TYPE],
			["SecurityPolicyViolationEventInit", base_config_1.TYPE],
			["StorageEstimate", base_config_1.TYPE],
			["StreamPipeOptions", base_config_1.TYPE],
			["StructuredSerializeOptions", base_config_1.TYPE],
			["TextDecodeOptions", base_config_1.TYPE],
			["TextDecoderOptions", base_config_1.TYPE],
			["TextEncoderEncodeIntoResult", base_config_1.TYPE],
			["Transformer", base_config_1.TYPE],
			["UnderlyingByteSource", base_config_1.TYPE],
			["UnderlyingDefaultSource", base_config_1.TYPE],
			["UnderlyingSink", base_config_1.TYPE],
			["UnderlyingSource", base_config_1.TYPE],
			["VideoColorSpaceInit", base_config_1.TYPE],
			["VideoConfiguration", base_config_1.TYPE],
			["VideoDecoderConfig", base_config_1.TYPE],
			["VideoDecoderInit", base_config_1.TYPE],
			["VideoDecoderSupport", base_config_1.TYPE],
			["VideoEncoderConfig", base_config_1.TYPE],
			["VideoEncoderEncodeOptions", base_config_1.TYPE],
			["VideoEncoderEncodeOptionsForAvc", base_config_1.TYPE],
			["VideoEncoderInit", base_config_1.TYPE],
			["VideoEncoderSupport", base_config_1.TYPE],
			["VideoFrameBufferInit", base_config_1.TYPE],
			["VideoFrameCopyToOptions", base_config_1.TYPE],
			["VideoFrameInit", base_config_1.TYPE],
			["WebGLContextAttributes", base_config_1.TYPE],
			["WebGLContextEventInit", base_config_1.TYPE],
			["WebTransportCloseInfo", base_config_1.TYPE],
			["WebTransportErrorOptions", base_config_1.TYPE],
			["WebTransportHash", base_config_1.TYPE],
			["WebTransportOptions", base_config_1.TYPE],
			["WebTransportSendOptions", base_config_1.TYPE],
			["WebTransportSendStreamOptions", base_config_1.TYPE],
			["WorkerOptions", base_config_1.TYPE],
			["WriteParams", base_config_1.TYPE],
			["ANGLE_instanced_arrays", base_config_1.TYPE],
			["AbortController", base_config_1.TYPE_VALUE],
			["AbortSignalEventMap", base_config_1.TYPE],
			["AbortSignal", base_config_1.TYPE_VALUE],
			["AbstractWorkerEventMap", base_config_1.TYPE],
			["AbstractWorker", base_config_1.TYPE],
			["AnimationFrameProvider", base_config_1.TYPE],
			["AudioData", base_config_1.TYPE_VALUE],
			["AudioDecoderEventMap", base_config_1.TYPE],
			["AudioDecoder", base_config_1.TYPE_VALUE],
			["AudioEncoderEventMap", base_config_1.TYPE],
			["AudioEncoder", base_config_1.TYPE_VALUE],
			["Blob", base_config_1.TYPE_VALUE],
			["Body", base_config_1.TYPE],
			["BroadcastChannelEventMap", base_config_1.TYPE],
			["BroadcastChannel", base_config_1.TYPE_VALUE],
			["ByteLengthQueuingStrategy", base_config_1.TYPE_VALUE],
			["CSSImageValue", base_config_1.TYPE_VALUE],
			["CSSKeywordValue", base_config_1.TYPE_VALUE],
			["CSSMathClamp", base_config_1.TYPE_VALUE],
			["CSSMathInvert", base_config_1.TYPE_VALUE],
			["CSSMathMax", base_config_1.TYPE_VALUE],
			["CSSMathMin", base_config_1.TYPE_VALUE],
			["CSSMathNegate", base_config_1.TYPE_VALUE],
			["CSSMathProduct", base_config_1.TYPE_VALUE],
			["CSSMathSum", base_config_1.TYPE_VALUE],
			["CSSMathValue", base_config_1.TYPE_VALUE],
			["CSSMatrixComponent", base_config_1.TYPE_VALUE],
			["CSSNumericArray", base_config_1.TYPE_VALUE],
			["CSSNumericValue", base_config_1.TYPE_VALUE],
			["CSSPerspective", base_config_1.TYPE_VALUE],
			["CSSRotate", base_config_1.TYPE_VALUE],
			["CSSScale", base_config_1.TYPE_VALUE],
			["CSSSkew", base_config_1.TYPE_VALUE],
			["CSSSkewX", base_config_1.TYPE_VALUE],
			["CSSSkewY", base_config_1.TYPE_VALUE],
			["CSSStyleValue", base_config_1.TYPE_VALUE],
			["CSSTransformComponent", base_config_1.TYPE_VALUE],
			["CSSTransformValue", base_config_1.TYPE_VALUE],
			["CSSTranslate", base_config_1.TYPE_VALUE],
			["CSSUnitValue", base_config_1.TYPE_VALUE],
			["CSSUnparsedValue", base_config_1.TYPE_VALUE],
			["CSSVariableReferenceValue", base_config_1.TYPE_VALUE],
			["Cache", base_config_1.TYPE_VALUE],
			["CacheStorage", base_config_1.TYPE_VALUE],
			["CanvasCompositing", base_config_1.TYPE],
			["CanvasDrawImage", base_config_1.TYPE],
			["CanvasDrawPath", base_config_1.TYPE],
			["CanvasFillStrokeStyles", base_config_1.TYPE],
			["CanvasFilters", base_config_1.TYPE],
			["CanvasGradient", base_config_1.TYPE_VALUE],
			["CanvasImageData", base_config_1.TYPE],
			["CanvasImageSmoothing", base_config_1.TYPE],
			["CanvasPath", base_config_1.TYPE],
			["CanvasPathDrawingStyles", base_config_1.TYPE],
			["CanvasPattern", base_config_1.TYPE_VALUE],
			["CanvasRect", base_config_1.TYPE],
			["CanvasShadowStyles", base_config_1.TYPE],
			["CanvasState", base_config_1.TYPE],
			["CanvasText", base_config_1.TYPE],
			["CanvasTextDrawingStyles", base_config_1.TYPE],
			["CanvasTransform", base_config_1.TYPE],
			["Client", base_config_1.TYPE_VALUE],
			["Clients", base_config_1.TYPE_VALUE],
			["CloseEvent", base_config_1.TYPE_VALUE],
			["CompressionStream", base_config_1.TYPE_VALUE],
			["CookieStore", base_config_1.TYPE_VALUE],
			["CookieStoreManager", base_config_1.TYPE_VALUE],
			["CountQueuingStrategy", base_config_1.TYPE_VALUE],
			["Crypto", base_config_1.TYPE_VALUE],
			["CryptoKey", base_config_1.TYPE_VALUE],
			["CustomEvent", base_config_1.TYPE_VALUE],
			["DOMException", base_config_1.TYPE_VALUE],
			["DOMMatrix", base_config_1.TYPE_VALUE],
			["DOMMatrixReadOnly", base_config_1.TYPE_VALUE],
			["DOMPoint", base_config_1.TYPE_VALUE],
			["DOMPointReadOnly", base_config_1.TYPE_VALUE],
			["DOMQuad", base_config_1.TYPE_VALUE],
			["DOMRect", base_config_1.TYPE_VALUE],
			["DOMRectReadOnly", base_config_1.TYPE_VALUE],
			["DOMStringList", base_config_1.TYPE_VALUE],
			["DecompressionStream", base_config_1.TYPE_VALUE],
			["DedicatedWorkerGlobalScopeEventMap", base_config_1.TYPE],
			["DedicatedWorkerGlobalScope", base_config_1.TYPE_VALUE],
			["EXT_blend_minmax", base_config_1.TYPE],
			["EXT_color_buffer_float", base_config_1.TYPE],
			["EXT_color_buffer_half_float", base_config_1.TYPE],
			["EXT_float_blend", base_config_1.TYPE],
			["EXT_frag_depth", base_config_1.TYPE],
			["EXT_sRGB", base_config_1.TYPE],
			["EXT_shader_texture_lod", base_config_1.TYPE],
			["EXT_texture_compression_bptc", base_config_1.TYPE],
			["EXT_texture_compression_rgtc", base_config_1.TYPE],
			["EXT_texture_filter_anisotropic", base_config_1.TYPE],
			["EXT_texture_norm16", base_config_1.TYPE],
			["EncodedAudioChunk", base_config_1.TYPE_VALUE],
			["EncodedVideoChunk", base_config_1.TYPE_VALUE],
			["ErrorEvent", base_config_1.TYPE_VALUE],
			["Event", base_config_1.TYPE_VALUE],
			["EventListener", base_config_1.TYPE],
			["EventListenerObject", base_config_1.TYPE],
			["EventSourceEventMap", base_config_1.TYPE],
			["EventSource", base_config_1.TYPE_VALUE],
			["EventTarget", base_config_1.TYPE_VALUE],
			["ExtendableCookieChangeEvent", base_config_1.TYPE_VALUE],
			["ExtendableEvent", base_config_1.TYPE_VALUE],
			["ExtendableMessageEvent", base_config_1.TYPE_VALUE],
			["FetchEvent", base_config_1.TYPE_VALUE],
			["File", base_config_1.TYPE_VALUE],
			["FileList", base_config_1.TYPE_VALUE],
			["FileReaderEventMap", base_config_1.TYPE],
			["FileReader", base_config_1.TYPE_VALUE],
			["FileReaderSync", base_config_1.TYPE_VALUE],
			["FileSystemDirectoryHandle", base_config_1.TYPE_VALUE],
			["FileSystemFileHandle", base_config_1.TYPE_VALUE],
			["FileSystemHandle", base_config_1.TYPE_VALUE],
			["FileSystemSyncAccessHandle", base_config_1.TYPE_VALUE],
			["FileSystemWritableFileStream", base_config_1.TYPE_VALUE],
			["FontFace", base_config_1.TYPE_VALUE],
			["FontFaceSetEventMap", base_config_1.TYPE],
			["FontFaceSet", base_config_1.TYPE_VALUE],
			["FontFaceSetLoadEvent", base_config_1.TYPE_VALUE],
			["FontFaceSource", base_config_1.TYPE],
			["FormData", base_config_1.TYPE_VALUE],
			["GPUError", base_config_1.TYPE],
			["GenericTransformStream", base_config_1.TYPE],
			["Headers", base_config_1.TYPE_VALUE],
			["IDBCursor", base_config_1.TYPE_VALUE],
			["IDBCursorWithValue", base_config_1.TYPE_VALUE],
			["IDBDatabaseEventMap", base_config_1.TYPE],
			["IDBDatabase", base_config_1.TYPE_VALUE],
			["IDBFactory", base_config_1.TYPE_VALUE],
			["IDBIndex", base_config_1.TYPE_VALUE],
			["IDBKeyRange", base_config_1.TYPE_VALUE],
			["IDBObjectStore", base_config_1.TYPE_VALUE],
			["IDBOpenDBRequestEventMap", base_config_1.TYPE],
			["IDBOpenDBRequest", base_config_1.TYPE_VALUE],
			["IDBRequestEventMap", base_config_1.TYPE],
			["IDBRequest", base_config_1.TYPE_VALUE],
			["IDBTransactionEventMap", base_config_1.TYPE],
			["IDBTransaction", base_config_1.TYPE_VALUE],
			["IDBVersionChangeEvent", base_config_1.TYPE_VALUE],
			["ImageBitmap", base_config_1.TYPE_VALUE],
			["ImageBitmapRenderingContext", base_config_1.TYPE_VALUE],
			["ImageData", base_config_1.TYPE_VALUE],
			["ImageDecoder", base_config_1.TYPE_VALUE],
			["ImageTrack", base_config_1.TYPE_VALUE],
			["ImageTrackList", base_config_1.TYPE_VALUE],
			["ImportMeta", base_config_1.TYPE],
			["KHR_parallel_shader_compile", base_config_1.TYPE],
			["Lock", base_config_1.TYPE_VALUE],
			["LockManager", base_config_1.TYPE_VALUE],
			["MediaCapabilities", base_config_1.TYPE_VALUE],
			["MediaSourceHandle", base_config_1.TYPE_VALUE],
			["MediaStreamTrackProcessor", base_config_1.TYPE_VALUE],
			["MessageChannel", base_config_1.TYPE_VALUE],
			["MessageEvent", base_config_1.TYPE_VALUE],
			["MessageEventTargetEventMap", base_config_1.TYPE],
			["MessageEventTarget", base_config_1.TYPE],
			["MessagePortEventMap", base_config_1.TYPE],
			["MessagePort", base_config_1.TYPE_VALUE],
			["NavigationPreloadManager", base_config_1.TYPE_VALUE],
			["NavigatorBadge", base_config_1.TYPE],
			["NavigatorConcurrentHardware", base_config_1.TYPE],
			["NavigatorID", base_config_1.TYPE],
			["NavigatorLanguage", base_config_1.TYPE],
			["NavigatorLocks", base_config_1.TYPE],
			["NavigatorOnLine", base_config_1.TYPE],
			["NavigatorStorage", base_config_1.TYPE],
			["NotificationEventMap", base_config_1.TYPE],
			["Notification", base_config_1.TYPE_VALUE],
			["NotificationEvent", base_config_1.TYPE_VALUE],
			["OES_draw_buffers_indexed", base_config_1.TYPE],
			["OES_element_index_uint", base_config_1.TYPE],
			["OES_fbo_render_mipmap", base_config_1.TYPE],
			["OES_standard_derivatives", base_config_1.TYPE],
			["OES_texture_float", base_config_1.TYPE],
			["OES_texture_float_linear", base_config_1.TYPE],
			["OES_texture_half_float", base_config_1.TYPE],
			["OES_texture_half_float_linear", base_config_1.TYPE],
			["OES_vertex_array_object", base_config_1.TYPE],
			["OVR_multiview2", base_config_1.TYPE],
			["OffscreenCanvasEventMap", base_config_1.TYPE],
			["OffscreenCanvas", base_config_1.TYPE_VALUE],
			["OffscreenCanvasRenderingContext2D", base_config_1.TYPE_VALUE],
			["Path2D", base_config_1.TYPE_VALUE],
			["PerformanceEventMap", base_config_1.TYPE],
			["Performance", base_config_1.TYPE_VALUE],
			["PerformanceEntry", base_config_1.TYPE_VALUE],
			["PerformanceMark", base_config_1.TYPE_VALUE],
			["PerformanceMeasure", base_config_1.TYPE_VALUE],
			["PerformanceObserver", base_config_1.TYPE_VALUE],
			["PerformanceObserverEntryList", base_config_1.TYPE_VALUE],
			["PerformanceResourceTiming", base_config_1.TYPE_VALUE],
			["PerformanceServerTiming", base_config_1.TYPE_VALUE],
			["PermissionStatusEventMap", base_config_1.TYPE],
			["PermissionStatus", base_config_1.TYPE_VALUE],
			["Permissions", base_config_1.TYPE_VALUE],
			["ProgressEvent", base_config_1.TYPE_VALUE],
			["PromiseRejectionEvent", base_config_1.TYPE_VALUE],
			["PushEvent", base_config_1.TYPE_VALUE],
			["PushManager", base_config_1.TYPE_VALUE],
			["PushMessageData", base_config_1.TYPE_VALUE],
			["PushSubscription", base_config_1.TYPE_VALUE],
			["PushSubscriptionChangeEvent", base_config_1.TYPE_VALUE],
			["PushSubscriptionOptions", base_config_1.TYPE_VALUE],
			["RTCDataChannelEventMap", base_config_1.TYPE],
			["RTCDataChannel", base_config_1.TYPE_VALUE],
			["RTCEncodedAudioFrame", base_config_1.TYPE_VALUE],
			["RTCEncodedVideoFrame", base_config_1.TYPE_VALUE],
			["RTCRtpScriptTransformer", base_config_1.TYPE_VALUE],
			["RTCTransformEvent", base_config_1.TYPE_VALUE],
			["ReadableByteStreamController", base_config_1.TYPE_VALUE],
			["ReadableStream", base_config_1.TYPE_VALUE],
			["ReadableStreamBYOBReader", base_config_1.TYPE_VALUE],
			["ReadableStreamBYOBRequest", base_config_1.TYPE_VALUE],
			["ReadableStreamDefaultController", base_config_1.TYPE_VALUE],
			["ReadableStreamDefaultReader", base_config_1.TYPE_VALUE],
			["ReadableStreamGenericReader", base_config_1.TYPE],
			["Report", base_config_1.TYPE_VALUE],
			["ReportBody", base_config_1.TYPE_VALUE],
			["ReportingObserver", base_config_1.TYPE_VALUE],
			["Request", base_config_1.TYPE_VALUE],
			["Response", base_config_1.TYPE_VALUE],
			["SecurityPolicyViolationEvent", base_config_1.TYPE_VALUE],
			["ServiceWorkerEventMap", base_config_1.TYPE],
			["ServiceWorker", base_config_1.TYPE_VALUE],
			["ServiceWorkerContainerEventMap", base_config_1.TYPE],
			["ServiceWorkerContainer", base_config_1.TYPE_VALUE],
			["ServiceWorkerGlobalScopeEventMap", base_config_1.TYPE],
			["ServiceWorkerGlobalScope", base_config_1.TYPE_VALUE],
			["ServiceWorkerRegistrationEventMap", base_config_1.TYPE],
			["ServiceWorkerRegistration", base_config_1.TYPE_VALUE],
			["SharedWorkerGlobalScopeEventMap", base_config_1.TYPE],
			["SharedWorkerGlobalScope", base_config_1.TYPE_VALUE],
			["StorageManager", base_config_1.TYPE_VALUE],
			["StylePropertyMapReadOnly", base_config_1.TYPE_VALUE],
			["SubtleCrypto", base_config_1.TYPE_VALUE],
			["TextDecoder", base_config_1.TYPE_VALUE],
			["TextDecoderCommon", base_config_1.TYPE],
			["TextDecoderStream", base_config_1.TYPE_VALUE],
			["TextEncoder", base_config_1.TYPE_VALUE],
			["TextEncoderCommon", base_config_1.TYPE],
			["TextEncoderStream", base_config_1.TYPE_VALUE],
			["TextMetrics", base_config_1.TYPE_VALUE],
			["TransformStream", base_config_1.TYPE_VALUE],
			["TransformStreamDefaultController", base_config_1.TYPE_VALUE],
			["URL", base_config_1.TYPE_VALUE],
			["URLSearchParams", base_config_1.TYPE_VALUE],
			["VideoColorSpace", base_config_1.TYPE_VALUE],
			["VideoDecoderEventMap", base_config_1.TYPE],
			["VideoDecoder", base_config_1.TYPE_VALUE],
			["VideoEncoderEventMap", base_config_1.TYPE],
			["VideoEncoder", base_config_1.TYPE_VALUE],
			["VideoFrame", base_config_1.TYPE_VALUE],
			["WEBGL_color_buffer_float", base_config_1.TYPE],
			["WEBGL_compressed_texture_astc", base_config_1.TYPE],
			["WEBGL_compressed_texture_etc", base_config_1.TYPE],
			["WEBGL_compressed_texture_etc1", base_config_1.TYPE],
			["WEBGL_compressed_texture_pvrtc", base_config_1.TYPE],
			["WEBGL_compressed_texture_s3tc", base_config_1.TYPE],
			["WEBGL_compressed_texture_s3tc_srgb", base_config_1.TYPE],
			["WEBGL_debug_renderer_info", base_config_1.TYPE],
			["WEBGL_debug_shaders", base_config_1.TYPE],
			["WEBGL_depth_texture", base_config_1.TYPE],
			["WEBGL_draw_buffers", base_config_1.TYPE],
			["WEBGL_lose_context", base_config_1.TYPE],
			["WEBGL_multi_draw", base_config_1.TYPE],
			["WebGL2RenderingContext", base_config_1.TYPE_VALUE],
			["WebGL2RenderingContextBase", base_config_1.TYPE],
			["WebGL2RenderingContextOverloads", base_config_1.TYPE],
			["WebGLActiveInfo", base_config_1.TYPE_VALUE],
			["WebGLBuffer", base_config_1.TYPE_VALUE],
			["WebGLContextEvent", base_config_1.TYPE_VALUE],
			["WebGLFramebuffer", base_config_1.TYPE_VALUE],
			["WebGLProgram", base_config_1.TYPE_VALUE],
			["WebGLQuery", base_config_1.TYPE_VALUE],
			["WebGLRenderbuffer", base_config_1.TYPE_VALUE],
			["WebGLRenderingContext", base_config_1.TYPE_VALUE],
			["WebGLRenderingContextBase", base_config_1.TYPE],
			["WebGLRenderingContextOverloads", base_config_1.TYPE],
			["WebGLSampler", base_config_1.TYPE_VALUE],
			["WebGLShader", base_config_1.TYPE_VALUE],
			["WebGLShaderPrecisionFormat", base_config_1.TYPE_VALUE],
			["WebGLSync", base_config_1.TYPE_VALUE],
			["WebGLTexture", base_config_1.TYPE_VALUE],
			["WebGLTransformFeedback", base_config_1.TYPE_VALUE],
			["WebGLUniformLocation", base_config_1.TYPE_VALUE],
			["WebGLVertexArrayObject", base_config_1.TYPE_VALUE],
			["WebGLVertexArrayObjectOES", base_config_1.TYPE],
			["WebSocketEventMap", base_config_1.TYPE],
			["WebSocket", base_config_1.TYPE_VALUE],
			["WebTransport", base_config_1.TYPE_VALUE],
			["WebTransportBidirectionalStream", base_config_1.TYPE_VALUE],
			["WebTransportDatagramDuplexStream", base_config_1.TYPE_VALUE],
			["WebTransportError", base_config_1.TYPE_VALUE],
			["WindowClient", base_config_1.TYPE_VALUE],
			["WindowOrWorkerGlobalScope", base_config_1.TYPE],
			["WorkerEventMap", base_config_1.TYPE],
			["Worker", base_config_1.TYPE_VALUE],
			["WorkerGlobalScopeEventMap", base_config_1.TYPE],
			["WorkerGlobalScope", base_config_1.TYPE_VALUE],
			["WorkerLocation", base_config_1.TYPE_VALUE],
			["WorkerNavigator", base_config_1.TYPE_VALUE],
			["WritableStream", base_config_1.TYPE_VALUE],
			["WritableStreamDefaultController", base_config_1.TYPE_VALUE],
			["WritableStreamDefaultWriter", base_config_1.TYPE_VALUE],
			["XMLHttpRequestEventMap", base_config_1.TYPE],
			["XMLHttpRequest", base_config_1.TYPE_VALUE],
			["XMLHttpRequestEventTargetEventMap", base_config_1.TYPE],
			["XMLHttpRequestEventTarget", base_config_1.TYPE_VALUE],
			["XMLHttpRequestUpload", base_config_1.TYPE_VALUE],
			["WebAssembly", base_config_1.TYPE_VALUE],
			["Console", base_config_1.TYPE],
			["AudioDataOutputCallback", base_config_1.TYPE],
			["EncodedAudioChunkOutputCallback", base_config_1.TYPE],
			["EncodedVideoChunkOutputCallback", base_config_1.TYPE],
			["FrameRequestCallback", base_config_1.TYPE],
			["LockGrantedCallback", base_config_1.TYPE],
			["OnErrorEventHandlerNonNull", base_config_1.TYPE],
			["PerformanceObserverCallback", base_config_1.TYPE],
			["QueuingStrategySize", base_config_1.TYPE],
			["ReportingObserverCallback", base_config_1.TYPE],
			["TransformerFlushCallback", base_config_1.TYPE],
			["TransformerStartCallback", base_config_1.TYPE],
			["TransformerTransformCallback", base_config_1.TYPE],
			["UnderlyingSinkAbortCallback", base_config_1.TYPE],
			["UnderlyingSinkCloseCallback", base_config_1.TYPE],
			["UnderlyingSinkStartCallback", base_config_1.TYPE],
			["UnderlyingSinkWriteCallback", base_config_1.TYPE],
			["UnderlyingSourceCancelCallback", base_config_1.TYPE],
			["UnderlyingSourcePullCallback", base_config_1.TYPE],
			["UnderlyingSourceStartCallback", base_config_1.TYPE],
			["VideoFrameOutputCallback", base_config_1.TYPE],
			["VoidFunction", base_config_1.TYPE],
			["WebCodecsErrorCallback", base_config_1.TYPE],
			["AlgorithmIdentifier", base_config_1.TYPE],
			["AllowSharedBufferSource", base_config_1.TYPE],
			["BigInteger", base_config_1.TYPE],
			["BlobPart", base_config_1.TYPE],
			["BodyInit", base_config_1.TYPE],
			["BufferSource", base_config_1.TYPE],
			["CSSKeywordish", base_config_1.TYPE],
			["CSSNumberish", base_config_1.TYPE],
			["CSSPerspectiveValue", base_config_1.TYPE],
			["CSSUnparsedSegment", base_config_1.TYPE],
			["CanvasImageSource", base_config_1.TYPE],
			["CookieList", base_config_1.TYPE],
			["DOMHighResTimeStamp", base_config_1.TYPE],
			["EpochTimeStamp", base_config_1.TYPE],
			["EventListenerOrEventListenerObject", base_config_1.TYPE],
			["FileSystemWriteChunkType", base_config_1.TYPE],
			["Float32List", base_config_1.TYPE],
			["FormDataEntryValue", base_config_1.TYPE],
			["GLbitfield", base_config_1.TYPE],
			["GLboolean", base_config_1.TYPE],
			["GLclampf", base_config_1.TYPE],
			["GLenum", base_config_1.TYPE],
			["GLfloat", base_config_1.TYPE],
			["GLint", base_config_1.TYPE],
			["GLint64", base_config_1.TYPE],
			["GLintptr", base_config_1.TYPE],
			["GLsizei", base_config_1.TYPE],
			["GLsizeiptr", base_config_1.TYPE],
			["GLuint", base_config_1.TYPE],
			["GLuint64", base_config_1.TYPE],
			["HashAlgorithmIdentifier", base_config_1.TYPE],
			["HeadersInit", base_config_1.TYPE],
			["IDBValidKey", base_config_1.TYPE],
			["ImageBitmapSource", base_config_1.TYPE],
			["ImageBufferSource", base_config_1.TYPE],
			["ImageDataArray", base_config_1.TYPE],
			["Int32List", base_config_1.TYPE],
			["MessageEventSource", base_config_1.TYPE],
			["NamedCurve", base_config_1.TYPE],
			["OffscreenRenderingContext", base_config_1.TYPE],
			["OnErrorEventHandler", base_config_1.TYPE],
			["PerformanceEntryList", base_config_1.TYPE],
			["PushMessageDataInit", base_config_1.TYPE],
			["ReadableStreamController", base_config_1.TYPE],
			["ReadableStreamReadResult", base_config_1.TYPE],
			["ReadableStreamReader", base_config_1.TYPE],
			["ReportList", base_config_1.TYPE],
			["RequestInfo", base_config_1.TYPE],
			["TexImageSource", base_config_1.TYPE],
			["TimerHandler", base_config_1.TYPE],
			["Transferable", base_config_1.TYPE],
			["Uint32List", base_config_1.TYPE],
			["XMLHttpRequestBodyInit", base_config_1.TYPE],
			["AlphaOption", base_config_1.TYPE],
			["AudioSampleFormat", base_config_1.TYPE],
			["AvcBitstreamFormat", base_config_1.TYPE],
			["BinaryType", base_config_1.TYPE],
			["BitrateMode", base_config_1.TYPE],
			["CSSMathOperator", base_config_1.TYPE],
			["CSSNumericBaseType", base_config_1.TYPE],
			["CanvasDirection", base_config_1.TYPE],
			["CanvasFillRule", base_config_1.TYPE],
			["CanvasFontKerning", base_config_1.TYPE],
			["CanvasFontStretch", base_config_1.TYPE],
			["CanvasFontVariantCaps", base_config_1.TYPE],
			["CanvasLineCap", base_config_1.TYPE],
			["CanvasLineJoin", base_config_1.TYPE],
			["CanvasTextAlign", base_config_1.TYPE],
			["CanvasTextBaseline", base_config_1.TYPE],
			["CanvasTextRendering", base_config_1.TYPE],
			["ClientTypes", base_config_1.TYPE],
			["CodecState", base_config_1.TYPE],
			["ColorGamut", base_config_1.TYPE],
			["ColorSpaceConversion", base_config_1.TYPE],
			["CompressionFormat", base_config_1.TYPE],
			["CookieSameSite", base_config_1.TYPE],
			["DocumentVisibilityState", base_config_1.TYPE],
			["EncodedAudioChunkType", base_config_1.TYPE],
			["EncodedVideoChunkType", base_config_1.TYPE],
			["EndingType", base_config_1.TYPE],
			["FileSystemHandleKind", base_config_1.TYPE],
			["FontDisplay", base_config_1.TYPE],
			["FontFaceLoadStatus", base_config_1.TYPE],
			["FontFaceSetLoadStatus", base_config_1.TYPE],
			["FrameType", base_config_1.TYPE],
			["GlobalCompositeOperation", base_config_1.TYPE],
			["HardwareAcceleration", base_config_1.TYPE],
			["HdrMetadataType", base_config_1.TYPE],
			["IDBCursorDirection", base_config_1.TYPE],
			["IDBRequestReadyState", base_config_1.TYPE],
			["IDBTransactionDurability", base_config_1.TYPE],
			["IDBTransactionMode", base_config_1.TYPE],
			["ImageOrientation", base_config_1.TYPE],
			["ImageSmoothingQuality", base_config_1.TYPE],
			["KeyFormat", base_config_1.TYPE],
			["KeyType", base_config_1.TYPE],
			["KeyUsage", base_config_1.TYPE],
			["LatencyMode", base_config_1.TYPE],
			["LockMode", base_config_1.TYPE],
			["MediaDecodingType", base_config_1.TYPE],
			["MediaEncodingType", base_config_1.TYPE],
			["MediaKeysRequirement", base_config_1.TYPE],
			["NotificationDirection", base_config_1.TYPE],
			["NotificationPermission", base_config_1.TYPE],
			["OffscreenRenderingContextId", base_config_1.TYPE],
			["OpusBitstreamFormat", base_config_1.TYPE],
			["PermissionName", base_config_1.TYPE],
			["PermissionState", base_config_1.TYPE],
			["PredefinedColorSpace", base_config_1.TYPE],
			["PremultiplyAlpha", base_config_1.TYPE],
			["PushEncryptionKeyName", base_config_1.TYPE],
			["RTCDataChannelState", base_config_1.TYPE],
			["RTCEncodedVideoFrameType", base_config_1.TYPE],
			["ReadableStreamReaderMode", base_config_1.TYPE],
			["ReadableStreamType", base_config_1.TYPE],
			["ReferrerPolicy", base_config_1.TYPE],
			["RequestCache", base_config_1.TYPE],
			["RequestCredentials", base_config_1.TYPE],
			["RequestDestination", base_config_1.TYPE],
			["RequestMode", base_config_1.TYPE],
			["RequestPriority", base_config_1.TYPE],
			["RequestRedirect", base_config_1.TYPE],
			["ResizeQuality", base_config_1.TYPE],
			["ResponseType", base_config_1.TYPE],
			["SecurityPolicyViolationEventDisposition", base_config_1.TYPE],
			["ServiceWorkerState", base_config_1.TYPE],
			["ServiceWorkerUpdateViaCache", base_config_1.TYPE],
			["TransferFunction", base_config_1.TYPE],
			["VideoColorPrimaries", base_config_1.TYPE],
			["VideoEncoderBitrateMode", base_config_1.TYPE],
			["VideoMatrixCoefficients", base_config_1.TYPE],
			["VideoPixelFormat", base_config_1.TYPE],
			["VideoTransferCharacteristics", base_config_1.TYPE],
			["WebGLPowerPreference", base_config_1.TYPE],
			["WebTransportCongestionControl", base_config_1.TYPE],
			["WebTransportErrorSource", base_config_1.TYPE],
			["WorkerType", base_config_1.TYPE],
			["WriteCommandType", base_config_1.TYPE],
			["XMLHttpRequestResponseType", base_config_1.TYPE]
		]
	};
})), require_webworker_asynciterable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.webworker_asynciterable = void 0;
	let base_config_1 = require_base_config();
	exports.webworker_asynciterable = {
		libs: [],
		variables: [
			["FileSystemDirectoryHandleAsyncIterator", base_config_1.TYPE],
			["FileSystemDirectoryHandle", base_config_1.TYPE],
			["ReadableStreamAsyncIterator", base_config_1.TYPE],
			["ReadableStream", base_config_1.TYPE]
		]
	};
})), require_webworker_iterable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.webworker_iterable = void 0;
	let base_config_1 = require_base_config();
	exports.webworker_iterable = {
		libs: [],
		variables: [
			["CSSNumericArray", base_config_1.TYPE],
			["CSSTransformValue", base_config_1.TYPE],
			["CSSUnparsedValue", base_config_1.TYPE],
			["Cache", base_config_1.TYPE],
			["CanvasPath", base_config_1.TYPE],
			["CanvasPathDrawingStyles", base_config_1.TYPE],
			["CookieStoreManager", base_config_1.TYPE],
			["DOMStringList", base_config_1.TYPE],
			["FileList", base_config_1.TYPE],
			["FontFaceSet", base_config_1.TYPE],
			["FormDataIterator", base_config_1.TYPE],
			["FormData", base_config_1.TYPE],
			["HeadersIterator", base_config_1.TYPE],
			["Headers", base_config_1.TYPE],
			["IDBDatabase", base_config_1.TYPE],
			["IDBObjectStore", base_config_1.TYPE],
			["ImageTrackList", base_config_1.TYPE],
			["MessageEvent", base_config_1.TYPE],
			["StylePropertyMapReadOnlyIterator", base_config_1.TYPE],
			["StylePropertyMapReadOnly", base_config_1.TYPE],
			["SubtleCrypto", base_config_1.TYPE],
			["URLSearchParamsIterator", base_config_1.TYPE],
			["URLSearchParams", base_config_1.TYPE],
			["WEBGL_draw_buffers", base_config_1.TYPE],
			["WEBGL_multi_draw", base_config_1.TYPE],
			["WebGL2RenderingContextBase", base_config_1.TYPE],
			["WebGL2RenderingContextOverloads", base_config_1.TYPE],
			["WebGLRenderingContextBase", base_config_1.TYPE],
			["WebGLRenderingContextOverloads", base_config_1.TYPE]
		]
	};
})), require_lib = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.lib = void 0;
	let decorators_1 = require_decorators(), decorators_legacy_1 = require_decorators_legacy(), dom_1 = require_dom(), dom_asynciterable_1 = require_dom_asynciterable(), dom_iterable_1 = require_dom_iterable(), es5_1 = require_es5(), es6_1 = require_es6(), es7_1 = require_es7(), es2015_1 = require_es2015(), es2015_collection_1 = require_es2015_collection(), es2015_core_1 = require_es2015_core(), es2015_generator_1 = require_es2015_generator(), es2015_iterable_1 = require_es2015_iterable(), es2015_promise_1 = require_es2015_promise(), es2015_proxy_1 = require_es2015_proxy(), es2015_reflect_1 = require_es2015_reflect(), es2015_symbol_1 = require_es2015_symbol(), es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown(), es2016_1 = require_es2016(), es2016_array_include_1 = require_es2016_array_include(), es2016_full_1 = require_es2016_full(), es2016_intl_1 = require_es2016_intl(), es2017_1 = require_es2017(), es2017_arraybuffer_1 = require_es2017_arraybuffer(), es2017_date_1 = require_es2017_date(), es2017_full_1 = require_es2017_full(), es2017_intl_1 = require_es2017_intl(), es2017_object_1 = require_es2017_object(), es2017_sharedmemory_1 = require_es2017_sharedmemory(), es2017_string_1 = require_es2017_string(), es2017_typedarrays_1 = require_es2017_typedarrays(), es2018_1 = require_es2018(), es2018_asyncgenerator_1 = require_es2018_asyncgenerator(), es2018_asynciterable_1 = require_es2018_asynciterable(), es2018_full_1 = require_es2018_full(), es2018_intl_1 = require_es2018_intl(), es2018_promise_1 = require_es2018_promise(), es2018_regexp_1 = require_es2018_regexp(), es2019_1 = require_es2019(), es2019_array_1 = require_es2019_array(), es2019_full_1 = require_es2019_full(), es2019_intl_1 = require_es2019_intl(), es2019_object_1 = require_es2019_object(), es2019_string_1 = require_es2019_string(), es2019_symbol_1 = require_es2019_symbol(), es2020_1 = require_es2020(), es2020_bigint_1 = require_es2020_bigint(), es2020_date_1 = require_es2020_date(), es2020_full_1 = require_es2020_full(), es2020_intl_1 = require_es2020_intl(), es2020_number_1 = require_es2020_number(), es2020_promise_1 = require_es2020_promise(), es2020_sharedmemory_1 = require_es2020_sharedmemory(), es2020_string_1 = require_es2020_string(), es2020_symbol_wellknown_1 = require_es2020_symbol_wellknown(), es2021_1 = require_es2021(), es2021_full_1 = require_es2021_full(), es2021_intl_1 = require_es2021_intl(), es2021_promise_1 = require_es2021_promise(), es2021_string_1 = require_es2021_string(), es2021_weakref_1 = require_es2021_weakref(), es2022_1 = require_es2022(), es2022_array_1 = require_es2022_array(), es2022_error_1 = require_es2022_error(), es2022_full_1 = require_es2022_full(), es2022_intl_1 = require_es2022_intl(), es2022_object_1 = require_es2022_object(), es2022_regexp_1 = require_es2022_regexp(), es2022_string_1 = require_es2022_string(), es2023_1 = require_es2023(), es2023_array_1 = require_es2023_array(), es2023_collection_1 = require_es2023_collection(), es2023_full_1 = require_es2023_full(), es2023_intl_1 = require_es2023_intl(), es2024_1 = require_es2024(), es2024_arraybuffer_1 = require_es2024_arraybuffer(), es2024_collection_1 = require_es2024_collection(), es2024_full_1 = require_es2024_full(), es2024_object_1 = require_es2024_object(), es2024_promise_1 = require_es2024_promise(), es2024_regexp_1 = require_es2024_regexp(), es2024_sharedmemory_1 = require_es2024_sharedmemory(), es2024_string_1 = require_es2024_string(), esnext_1 = require_esnext(), esnext_array_1 = require_esnext_array(), esnext_asynciterable_1 = require_esnext_asynciterable(), esnext_bigint_1 = require_esnext_bigint(), esnext_collection_1 = require_esnext_collection(), esnext_decorators_1 = require_esnext_decorators(), esnext_disposable_1 = require_esnext_disposable(), esnext_error_1 = require_esnext_error(), esnext_float16_1 = require_esnext_float16(), esnext_full_1 = require_esnext_full(), esnext_intl_1 = require_esnext_intl(), esnext_iterator_1 = require_esnext_iterator(), esnext_object_1 = require_esnext_object(), esnext_promise_1 = require_esnext_promise(), esnext_regexp_1 = require_esnext_regexp(), esnext_sharedmemory_1 = require_esnext_sharedmemory(), esnext_string_1 = require_esnext_string(), esnext_symbol_1 = require_esnext_symbol(), esnext_weakref_1 = require_esnext_weakref(), lib_1 = require_lib$1(), scripthost_1 = require_scripthost(), webworker_1 = require_webworker(), webworker_asynciterable_1 = require_webworker_asynciterable(), webworker_importscripts_1 = require_webworker_importscripts(), webworker_iterable_1 = require_webworker_iterable();
	exports.lib = new Map([
		["es5", es5_1.es5],
		["es6", es6_1.es6],
		["es2015", es2015_1.es2015],
		["es7", es7_1.es7],
		["es2016", es2016_1.es2016],
		["es2017", es2017_1.es2017],
		["es2018", es2018_1.es2018],
		["es2019", es2019_1.es2019],
		["es2020", es2020_1.es2020],
		["es2021", es2021_1.es2021],
		["es2022", es2022_1.es2022],
		["es2023", es2023_1.es2023],
		["es2024", es2024_1.es2024],
		["esnext", esnext_1.esnext],
		["dom", dom_1.dom],
		["dom.iterable", dom_iterable_1.dom_iterable],
		["dom.asynciterable", dom_asynciterable_1.dom_asynciterable],
		["webworker", webworker_1.webworker],
		["webworker.importscripts", webworker_importscripts_1.webworker_importscripts],
		["webworker.iterable", webworker_iterable_1.webworker_iterable],
		["webworker.asynciterable", webworker_asynciterable_1.webworker_asynciterable],
		["scripthost", scripthost_1.scripthost],
		["es2015.core", es2015_core_1.es2015_core],
		["es2015.collection", es2015_collection_1.es2015_collection],
		["es2015.generator", es2015_generator_1.es2015_generator],
		["es2015.iterable", es2015_iterable_1.es2015_iterable],
		["es2015.promise", es2015_promise_1.es2015_promise],
		["es2015.proxy", es2015_proxy_1.es2015_proxy],
		["es2015.reflect", es2015_reflect_1.es2015_reflect],
		["es2015.symbol", es2015_symbol_1.es2015_symbol],
		["es2015.symbol.wellknown", es2015_symbol_wellknown_1.es2015_symbol_wellknown],
		["es2016.array.include", es2016_array_include_1.es2016_array_include],
		["es2016.intl", es2016_intl_1.es2016_intl],
		["es2017.arraybuffer", es2017_arraybuffer_1.es2017_arraybuffer],
		["es2017.date", es2017_date_1.es2017_date],
		["es2017.object", es2017_object_1.es2017_object],
		["es2017.sharedmemory", es2017_sharedmemory_1.es2017_sharedmemory],
		["es2017.string", es2017_string_1.es2017_string],
		["es2017.intl", es2017_intl_1.es2017_intl],
		["es2017.typedarrays", es2017_typedarrays_1.es2017_typedarrays],
		["es2018.asyncgenerator", es2018_asyncgenerator_1.es2018_asyncgenerator],
		["es2018.asynciterable", es2018_asynciterable_1.es2018_asynciterable],
		["es2018.intl", es2018_intl_1.es2018_intl],
		["es2018.promise", es2018_promise_1.es2018_promise],
		["es2018.regexp", es2018_regexp_1.es2018_regexp],
		["es2019.array", es2019_array_1.es2019_array],
		["es2019.object", es2019_object_1.es2019_object],
		["es2019.string", es2019_string_1.es2019_string],
		["es2019.symbol", es2019_symbol_1.es2019_symbol],
		["es2019.intl", es2019_intl_1.es2019_intl],
		["es2020.bigint", es2020_bigint_1.es2020_bigint],
		["es2020.date", es2020_date_1.es2020_date],
		["es2020.promise", es2020_promise_1.es2020_promise],
		["es2020.sharedmemory", es2020_sharedmemory_1.es2020_sharedmemory],
		["es2020.string", es2020_string_1.es2020_string],
		["es2020.symbol.wellknown", es2020_symbol_wellknown_1.es2020_symbol_wellknown],
		["es2020.intl", es2020_intl_1.es2020_intl],
		["es2020.number", es2020_number_1.es2020_number],
		["es2021.promise", es2021_promise_1.es2021_promise],
		["es2021.string", es2021_string_1.es2021_string],
		["es2021.weakref", es2021_weakref_1.es2021_weakref],
		["es2021.intl", es2021_intl_1.es2021_intl],
		["es2022.array", es2022_array_1.es2022_array],
		["es2022.error", es2022_error_1.es2022_error],
		["es2022.intl", es2022_intl_1.es2022_intl],
		["es2022.object", es2022_object_1.es2022_object],
		["es2022.string", es2022_string_1.es2022_string],
		["es2022.regexp", es2022_regexp_1.es2022_regexp],
		["es2023.array", es2023_array_1.es2023_array],
		["es2023.collection", es2023_collection_1.es2023_collection],
		["es2023.intl", es2023_intl_1.es2023_intl],
		["es2024.arraybuffer", es2024_arraybuffer_1.es2024_arraybuffer],
		["es2024.collection", es2024_collection_1.es2024_collection],
		["es2024.object", es2024_object_1.es2024_object],
		["es2024.promise", es2024_promise_1.es2024_promise],
		["es2024.regexp", es2024_regexp_1.es2024_regexp],
		["es2024.sharedmemory", es2024_sharedmemory_1.es2024_sharedmemory],
		["es2024.string", es2024_string_1.es2024_string],
		["esnext.array", esnext_array_1.esnext_array],
		["esnext.collection", esnext_collection_1.esnext_collection],
		["esnext.symbol", esnext_symbol_1.esnext_symbol],
		["esnext.asynciterable", esnext_asynciterable_1.esnext_asynciterable],
		["esnext.intl", esnext_intl_1.esnext_intl],
		["esnext.disposable", esnext_disposable_1.esnext_disposable],
		["esnext.bigint", esnext_bigint_1.esnext_bigint],
		["esnext.string", esnext_string_1.esnext_string],
		["esnext.promise", esnext_promise_1.esnext_promise],
		["esnext.weakref", esnext_weakref_1.esnext_weakref],
		["esnext.decorators", esnext_decorators_1.esnext_decorators],
		["esnext.object", esnext_object_1.esnext_object],
		["esnext.regexp", esnext_regexp_1.esnext_regexp],
		["esnext.iterator", esnext_iterator_1.esnext_iterator],
		["esnext.float16", esnext_float16_1.esnext_float16],
		["esnext.error", esnext_error_1.esnext_error],
		["esnext.sharedmemory", esnext_sharedmemory_1.esnext_sharedmemory],
		["decorators", decorators_1.decorators],
		["decorators.legacy", decorators_legacy_1.decorators_legacy],
		["es2016.full", es2016_full_1.es2016_full],
		["es2017.full", es2017_full_1.es2017_full],
		["es2018.full", es2018_full_1.es2018_full],
		["es2019.full", es2019_full_1.es2019_full],
		["es2020.full", es2020_full_1.es2020_full],
		["es2021.full", es2021_full_1.es2021_full],
		["es2022.full", es2022_full_1.es2022_full],
		["es2023.full", es2023_full_1.es2023_full],
		["es2024.full", es2024_full_1.es2024_full],
		["esnext.full", esnext_full_1.esnext_full],
		["lib", lib_1.lib]
	]);
})), require_Reference = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Reference = exports.ReferenceTypeFlag = exports.ReferenceFlag = void 0;
	let ID_1 = require_ID();
	var ReferenceFlag;
	(function(ReferenceFlag) {
		ReferenceFlag[ReferenceFlag.Read = 1] = "Read", ReferenceFlag[ReferenceFlag.Write = 2] = "Write", ReferenceFlag[ReferenceFlag.ReadWrite = 3] = "ReadWrite";
	})(ReferenceFlag || (exports.ReferenceFlag = ReferenceFlag = {}));
	let generator = (0, ID_1.createIdGenerator)();
	var ReferenceTypeFlag;
	(function(ReferenceTypeFlag) {
		ReferenceTypeFlag[ReferenceTypeFlag.Value = 1] = "Value", ReferenceTypeFlag[ReferenceTypeFlag.Type = 2] = "Type";
	})(ReferenceTypeFlag || (exports.ReferenceTypeFlag = ReferenceTypeFlag = {}));
	var Reference = class {
		$id = generator();
		#flag;
		from;
		identifier;
		init;
		maybeImplicitGlobal;
		resolved;
		writeExpr;
		#referenceType;
		constructor(identifier, scope, flag, writeExpr, maybeImplicitGlobal, init, referenceType = ReferenceTypeFlag.Value) {
			this.identifier = identifier, this.from = scope, this.resolved = null, this.#flag = flag, this.isWrite() && (this.writeExpr = writeExpr, this.init = init), this.maybeImplicitGlobal = maybeImplicitGlobal, this.#referenceType = referenceType;
		}
		get isTypeReference() {
			return (this.#referenceType & ReferenceTypeFlag.Type) !== 0;
		}
		get isValueReference() {
			return (this.#referenceType & ReferenceTypeFlag.Value) !== 0;
		}
		isWrite() {
			return !!(this.#flag & ReferenceFlag.Write);
		}
		isRead() {
			return !!(this.#flag & ReferenceFlag.Read);
		}
		isReadOnly() {
			return this.#flag === ReferenceFlag.Read;
		}
		isWriteOnly() {
			return this.#flag === ReferenceFlag.Write;
		}
		isReadWrite() {
			return this.#flag === ReferenceFlag.ReadWrite;
		}
	};
	exports.Reference = Reference;
})), require_VariableBase = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.VariableBase = void 0;
	let generator = (0, require_ID().createIdGenerator)();
	var VariableBase = class {
		$id = generator();
		defs = [];
		eslintUsed = !1;
		identifiers = [];
		name;
		references = [];
		scope;
		constructor(name, scope) {
			this.name = name, this.scope = scope;
		}
	};
	exports.VariableBase = VariableBase;
})), require_ESLintScopeVariable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ESLintScopeVariable = void 0;
	let VariableBase_1 = require_VariableBase();
	var ESLintScopeVariable = class extends VariableBase_1.VariableBase {
		writeable;
		eslintExplicitGlobal;
		eslintImplicitGlobalSetting;
		eslintExplicitGlobalComments;
	};
	exports.ESLintScopeVariable = ESLintScopeVariable;
})), require_ImplicitLibVariable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ImplicitLibVariable = void 0;
	let ESLintScopeVariable_1 = require_ESLintScopeVariable();
	var ImplicitLibVariable = class extends ESLintScopeVariable_1.ESLintScopeVariable {
		isTypeVariable;
		isValueVariable;
		constructor(scope, name, { eslintImplicitGlobalSetting, isTypeVariable, isValueVariable, writeable }) {
			super(name, scope), this.isTypeVariable = isTypeVariable ?? !1, this.isValueVariable = isValueVariable ?? !1, this.writeable = writeable ?? !1, this.eslintImplicitGlobalSetting = eslintImplicitGlobalSetting ?? "readonly";
		}
	};
	exports.ImplicitLibVariable = ImplicitLibVariable;
})), require_Variable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Variable = void 0;
	let VariableBase_1 = require_VariableBase();
	var Variable = class extends VariableBase_1.VariableBase {
		get isTypeVariable() {
			return this.defs.length === 0 ? !0 : this.defs.some((def) => def.isTypeDefinition);
		}
		get isValueVariable() {
			return this.defs.length === 0 ? !0 : this.defs.some((def) => def.isVariableDefinition);
		}
	};
	exports.Variable = Variable;
})), require_variable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Variable = exports.ImplicitLibVariable = exports.ESLintScopeVariable = void 0;
	var ESLintScopeVariable_1 = require_ESLintScopeVariable();
	Object.defineProperty(exports, "ESLintScopeVariable", {
		enumerable: !0,
		get: function() {
			return ESLintScopeVariable_1.ESLintScopeVariable;
		}
	});
	var ImplicitLibVariable_1 = require_ImplicitLibVariable();
	Object.defineProperty(exports, "ImplicitLibVariable", {
		enumerable: !0,
		get: function() {
			return ImplicitLibVariable_1.ImplicitLibVariable;
		}
	});
	var Variable_1 = require_Variable();
	Object.defineProperty(exports, "Variable", {
		enumerable: !0,
		get: function() {
			return Variable_1.Variable;
		}
	});
})), require_ScopeType = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ScopeType = void 0;
	var ScopeType;
	(function(ScopeType) {
		ScopeType.block = "block", ScopeType.catch = "catch", ScopeType.class = "class", ScopeType.classFieldInitializer = "class-field-initializer", ScopeType.classStaticBlock = "class-static-block", ScopeType.conditionalType = "conditionalType", ScopeType.for = "for", ScopeType.function = "function", ScopeType.functionExpressionName = "function-expression-name", ScopeType.functionType = "functionType", ScopeType.global = "global", ScopeType.mappedType = "mappedType", ScopeType.module = "module", ScopeType.switch = "switch", ScopeType.tsEnum = "tsEnum", ScopeType.tsModule = "tsModule", ScopeType.type = "type", ScopeType.with = "with";
	})(ScopeType || (exports.ScopeType = ScopeType = {}));
})), require_ScopeBase = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ScopeBase = void 0;
	let types_1 = require_dist$1(), assert_1 = require_assert$1(), definition_1 = require_definition(), ID_1 = require_ID(), Reference_1 = require_Reference(), variable_1 = require_variable(), ScopeType_1 = require_ScopeType();
	function isStrictScope(scope, block, isMethodDefinition) {
		let body;
		if (scope.upper?.isStrict || isMethodDefinition || scope.type === ScopeType_1.ScopeType.class || scope.type === ScopeType_1.ScopeType.conditionalType || scope.type === ScopeType_1.ScopeType.functionType || scope.type === ScopeType_1.ScopeType.mappedType || scope.type === ScopeType_1.ScopeType.module || scope.type === ScopeType_1.ScopeType.tsEnum || scope.type === ScopeType_1.ScopeType.tsModule || scope.type === ScopeType_1.ScopeType.type) return !0;
		if (scope.type === ScopeType_1.ScopeType.block || scope.type === ScopeType_1.ScopeType.switch) return !1;
		if (scope.type === ScopeType_1.ScopeType.function) {
			let functionBody = block;
			switch (functionBody.type) {
				case types_1.AST_NODE_TYPES.ArrowFunctionExpression:
					if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) return !1;
					body = functionBody.body;
					break;
				case types_1.AST_NODE_TYPES.Program:
					body = functionBody;
					break;
				default: body = functionBody.body;
			}
			if (!body) return !1;
		} else if (scope.type === ScopeType_1.ScopeType.global) body = block;
		else return !1;
		for (let stmt of body.body) {
			if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement || stmt.directive == null) break;
			if (stmt.directive === "use strict") return !0;
		}
		return !1;
	}
	function registerScope(scopeManager, scope) {
		scopeManager.scopes.push(scope);
		let scopes = scopeManager.nodeToScope.get(scope.block);
		scopes ? scopes.push(scope) : scopeManager.nodeToScope.set(scope.block, [scope]);
	}
	let generator = (0, ID_1.createIdGenerator)(), VARIABLE_SCOPE_TYPES = new Set([
		ScopeType_1.ScopeType.classFieldInitializer,
		ScopeType_1.ScopeType.classStaticBlock,
		ScopeType_1.ScopeType.function,
		ScopeType_1.ScopeType.global,
		ScopeType_1.ScopeType.module,
		ScopeType_1.ScopeType.tsModule
	]);
	var ScopeBase = class {
		$id = generator();
		block;
		childScopes = [];
		#declaredVariables;
		#dynamic;
		functionExpressionScope = !1;
		isStrict;
		leftToResolve = [];
		references = [];
		set = /* @__PURE__ */ new Map();
		through = [];
		type;
		upper;
		variables = [];
		#dynamicCloseRef = (ref) => {
			let current = this;
			do
				current.through.push(ref), current = current.upper;
			while (current);
		};
		#globalCloseRef = (ref, scopeManager) => {
			this.shouldStaticallyCloseForGlobal(ref, scopeManager) ? this.#staticCloseRef(ref) : this.#dynamicCloseRef(ref);
		};
		#staticCloseRef = (ref) => {
			let resolve = () => {
				let name = ref.identifier.name, variable = this.set.get(name);
				if (!variable || !this.isValidResolution(ref, variable)) return !1;
				let isValidTypeReference = ref.isTypeReference && variable.isTypeVariable, isValidValueReference = ref.isValueReference && variable.isValueVariable;
				return !isValidTypeReference && !isValidValueReference ? !1 : (variable.references.push(ref), ref.resolved = variable, !0);
			};
			resolve() || this.delegateToUpperScope(ref);
		};
		variableScope;
		constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
			let upperScopeAsScopeBase = upperScope;
			this.type = type, this.#dynamic = this.type === ScopeType_1.ScopeType.global || this.type === ScopeType_1.ScopeType.with, this.block = block, this.variableScope = this.isVariableScope() ? this : upperScopeAsScopeBase.variableScope, this.upper = upperScope, this.isStrict = isStrictScope(this, block, isMethodDefinition), upperScopeAsScopeBase?.childScopes.push(this), this.#declaredVariables = scopeManager.declaredVariables, registerScope(scopeManager, this);
		}
		isVariableScope() {
			return VARIABLE_SCOPE_TYPES.has(this.type);
		}
		shouldStaticallyCloseForGlobal(ref, scopeManager) {
			let name = ref.identifier.name, variable = this.set.get(name);
			if (!variable) return !1;
			if (scopeManager.isModule()) return !0;
			let defs = variable.defs;
			return defs.length > 0 && defs.every((def) => !(def.type === definition_1.DefinitionType.Variable && def.parent.kind === "var"));
		}
		close(scopeManager) {
			let closeRef;
			return closeRef = this.shouldStaticallyClose() ? this.#staticCloseRef : this.type === "global" ? this.#globalCloseRef : this.#dynamicCloseRef, (0, assert_1.assert)(this.leftToResolve), this.leftToResolve.forEach((ref) => closeRef(ref, scopeManager)), this.leftToResolve = null, this.upper;
		}
		shouldStaticallyClose() {
			return !this.#dynamic;
		}
		defineVariable(nameOrVariable, set, variables, node, def) {
			let name = typeof nameOrVariable == "string" ? nameOrVariable : nameOrVariable.name, variable = set.get(name);
			variable || (variable = typeof nameOrVariable == "string" ? new variable_1.Variable(name, this) : nameOrVariable, set.set(name, variable), variables.push(variable)), def && (variable.defs.push(def), this.addDeclaredVariablesOfNode(variable, def.node), this.addDeclaredVariablesOfNode(variable, def.parent)), node && variable.identifiers.push(node);
		}
		delegateToUpperScope(ref) {
			this.upper?.leftToResolve?.push(ref), this.through.push(ref);
		}
		isValidResolution(_ref, _variable) {
			return !0;
		}
		addDeclaredVariablesOfNode(variable, node) {
			if (node == null) return;
			let variables = this.#declaredVariables.get(node);
			variables ?? (variables = [], this.#declaredVariables.set(node, variables)), variables.includes(variable) || variables.push(variable);
		}
		defineIdentifier(node, def) {
			this.defineVariable(node.name, this.set, this.variables, node, def);
		}
		defineLiteralIdentifier(node, def) {
			this.defineVariable(node.value, this.set, this.variables, null, def);
		}
		referenceDualValueType(node) {
			let ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, !1, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);
			this.references.push(ref), this.leftToResolve?.push(ref);
		}
		referenceType(node) {
			let ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, !1, Reference_1.ReferenceTypeFlag.Type);
			this.references.push(ref), this.leftToResolve?.push(ref);
		}
		referenceValue(node, assign = Reference_1.ReferenceFlag.Read, writeExpr, maybeImplicitGlobal, init = !1) {
			let ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);
			this.references.push(ref), this.leftToResolve?.push(ref);
		}
	};
	exports.ScopeBase = ScopeBase;
})), require_BlockScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.BlockScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var BlockScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.block, upperScope, block, !1);
		}
	};
	exports.BlockScope = BlockScope;
})), require_CatchScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.CatchScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var CatchScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.catch, upperScope, block, !1);
		}
	};
	exports.CatchScope = CatchScope;
})), require_ClassFieldInitializerScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ClassFieldInitializerScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var ClassFieldInitializerScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.classFieldInitializer, upperScope, block, !1);
		}
	};
	exports.ClassFieldInitializerScope = ClassFieldInitializerScope;
})), require_ClassScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ClassScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var ClassScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.class, upperScope, block, !1);
		}
	};
	exports.ClassScope = ClassScope;
})), require_ConditionalTypeScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ConditionalTypeScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var ConditionalTypeScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.conditionalType, upperScope, block, !1);
		}
	};
	exports.ConditionalTypeScope = ConditionalTypeScope;
})), require_ForScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ForScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var ForScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.for, upperScope, block, !1);
		}
	};
	exports.ForScope = ForScope;
})), require_FunctionExpressionNameScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.FunctionExpressionNameScope = void 0;
	let definition_1 = require_definition(), ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var FunctionExpressionNameScope = class extends ScopeBase_1.ScopeBase {
		functionExpressionScope;
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.functionExpressionName, upperScope, block, !1), block.id && this.defineIdentifier(block.id, new definition_1.FunctionNameDefinition(block.id, block)), this.functionExpressionScope = !0;
		}
	};
	exports.FunctionExpressionNameScope = FunctionExpressionNameScope;
})), require_FunctionScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.FunctionScope = void 0;
	let types_1 = require_dist$1(), ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var FunctionScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block, isMethodDefinition) {
			super(scopeManager, ScopeType_1.ScopeType.function, upperScope, block, isMethodDefinition), this.block.type !== types_1.AST_NODE_TYPES.ArrowFunctionExpression && this.defineVariable("arguments", this.set, this.variables, null, null);
		}
		isValidResolution(ref, variable) {
			if (this.block.type === types_1.AST_NODE_TYPES.Program) return !0;
			let bodyStart = this.block.body?.range[0] ?? -1;
			return !(variable.scope === this && ref.identifier.range[0] < bodyStart && variable.defs.every((d) => d.name.range[0] >= bodyStart));
		}
	};
	exports.FunctionScope = FunctionScope;
})), require_FunctionTypeScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.FunctionTypeScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var FunctionTypeScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.functionType, upperScope, block, !1);
		}
	};
	exports.FunctionTypeScope = FunctionTypeScope;
})), require_GlobalScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.GlobalScope = void 0;
	let types_1 = require_dist$1(), assert_1 = require_assert$1(), ImplicitGlobalVariableDefinition_1 = require_ImplicitGlobalVariableDefinition(), variable_1 = require_variable(), ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var GlobalScope = class extends ScopeBase_1.ScopeBase {
		implicit;
		constructor(scopeManager, block) {
			super(scopeManager, ScopeType_1.ScopeType.global, null, block, !1), this.implicit = {
				leftToBeResolved: [],
				set: /* @__PURE__ */ new Map(),
				variables: []
			};
		}
		close(scopeManager) {
			(0, assert_1.assert)(this.leftToResolve);
			for (let ref of this.leftToResolve) if (ref.maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
				let info = ref.maybeImplicitGlobal, node = info.pattern;
				node.type === types_1.AST_NODE_TYPES.Identifier && this.defineVariable(node.name, this.implicit.set, this.implicit.variables, node, new ImplicitGlobalVariableDefinition_1.ImplicitGlobalVariableDefinition(info.pattern, info.node));
			}
			return this.implicit.leftToBeResolved = this.leftToResolve, super.close(scopeManager);
		}
		defineImplicitVariable(name, options) {
			this.defineVariable(new variable_1.ImplicitLibVariable(this, name, options), this.set, this.variables, null, null);
		}
	};
	exports.GlobalScope = GlobalScope;
})), require_MappedTypeScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.MappedTypeScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var MappedTypeScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.mappedType, upperScope, block, !1);
		}
	};
	exports.MappedTypeScope = MappedTypeScope;
})), require_ModuleScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ModuleScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var ModuleScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.module, upperScope, block, !1);
		}
	};
	exports.ModuleScope = ModuleScope;
})), require_Scope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
})), require_SwitchScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.SwitchScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var SwitchScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.switch, upperScope, block, !1);
		}
	};
	exports.SwitchScope = SwitchScope;
})), require_TSEnumScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TSEnumScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var TSEnumScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.tsEnum, upperScope, block, !1);
		}
	};
	exports.TSEnumScope = TSEnumScope;
})), require_TSModuleScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TSModuleScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var TSModuleScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.tsModule, upperScope, block, !1);
		}
	};
	exports.TSModuleScope = TSModuleScope;
})), require_TypeScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TypeScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var TypeScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.type, upperScope, block, !1);
		}
	};
	exports.TypeScope = TypeScope;
})), require_WithScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.WithScope = void 0;
	let assert_1 = require_assert$1(), ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var WithScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.with, upperScope, block, !1);
		}
		close(scopeManager) {
			return this.shouldStaticallyClose() ? super.close(scopeManager) : ((0, assert_1.assert)(this.leftToResolve), this.leftToResolve.forEach((ref) => this.delegateToUpperScope(ref)), this.leftToResolve = null, this.upper);
		}
	};
	exports.WithScope = WithScope;
})), require_scope = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k);
		var desc = Object.getOwnPropertyDescriptor(m, k);
		(!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
			enumerable: !0,
			get: function() {
				return m[k];
			}
		}), Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k), o[k2] = m[k];
	})), __exportStar = exports && exports.__exportStar || function(m, exports$3) {
		for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports$3, p) && __createBinding(exports$3, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: !0 }), __exportStar(require_BlockScope(), exports), __exportStar(require_CatchScope(), exports), __exportStar(require_ClassFieldInitializerScope(), exports), __exportStar(require_ClassScope(), exports), __exportStar(require_ConditionalTypeScope(), exports), __exportStar(require_ForScope(), exports), __exportStar(require_FunctionExpressionNameScope(), exports), __exportStar(require_FunctionScope(), exports), __exportStar(require_FunctionTypeScope(), exports), __exportStar(require_GlobalScope(), exports), __exportStar(require_MappedTypeScope(), exports), __exportStar(require_ModuleScope(), exports), __exportStar(require_Scope(), exports), __exportStar(require_ScopeType(), exports), __exportStar(require_SwitchScope(), exports), __exportStar(require_TSEnumScope(), exports), __exportStar(require_TSModuleScope(), exports), __exportStar(require_TypeScope(), exports), __exportStar(require_WithScope(), exports);
})), require_VisitorBase = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.VisitorBase = void 0;
	let visitor_keys_1 = require_dist$2();
	function isObject(obj) {
		return typeof obj == "object" && !!obj;
	}
	function isNode(node) {
		return isObject(node) && typeof node.type == "string";
	}
	var VisitorBase = class {
		#childVisitorKeys;
		#visitChildrenEvenIfSelectorExists;
		constructor(options) {
			this.#childVisitorKeys = options.childVisitorKeys ?? visitor_keys_1.visitorKeys, this.#visitChildrenEvenIfSelectorExists = options.visitChildrenEvenIfSelectorExists ?? !1;
		}
		visitChildren(node, excludeArr = []) {
			if (node?.type == null) return;
			let exclude = new Set([...excludeArr, "parent"]), children = this.#childVisitorKeys[node.type] ?? Object.keys(node);
			for (let key of children) {
				if (exclude.has(key)) continue;
				let child = node[key];
				if (child) if (Array.isArray(child)) for (let subChild of child) isNode(subChild) && this.visit(subChild);
				else isNode(child) && this.visit(child);
			}
		}
		visit(node) {
			if (node?.type == null) return;
			let visitor = this[node.type];
			visitor && (visitor.call(this, node), !this.#visitChildrenEvenIfSelectorExists) || this.visitChildren(node);
		}
	};
	exports.VisitorBase = VisitorBase;
})), require_PatternVisitor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.PatternVisitor = void 0;
	let types_1 = require_dist$1(), VisitorBase_1 = require_VisitorBase();
	var PatternVisitor = class extends VisitorBase_1.VisitorBase {
		#assignments = [];
		#callback;
		#restElements = [];
		#rootPattern;
		rightHandNodes = [];
		constructor(options, rootPattern, callback) {
			super(options), this.#rootPattern = rootPattern, this.#callback = callback;
		}
		static isPattern(node) {
			let nodeType = node.type;
			return nodeType === types_1.AST_NODE_TYPES.Identifier || nodeType === types_1.AST_NODE_TYPES.ObjectPattern || nodeType === types_1.AST_NODE_TYPES.ArrayPattern || nodeType === types_1.AST_NODE_TYPES.SpreadElement || nodeType === types_1.AST_NODE_TYPES.RestElement || nodeType === types_1.AST_NODE_TYPES.AssignmentPattern;
		}
		ArrayExpression(node) {
			node.elements.forEach(this.visit, this);
		}
		ArrayPattern(pattern) {
			for (let element of pattern.elements) this.visit(element);
		}
		AssignmentExpression(node) {
			this.#assignments.push(node), this.visit(node.left), this.rightHandNodes.push(node.right), this.#assignments.pop();
		}
		AssignmentPattern(pattern) {
			this.#assignments.push(pattern), this.visit(pattern.left), this.rightHandNodes.push(pattern.right), this.#assignments.pop();
		}
		CallExpression(node) {
			node.arguments.forEach((a) => {
				this.rightHandNodes.push(a);
			}), this.visit(node.callee);
		}
		Decorator() {}
		Identifier(pattern) {
			let lastRestElement = this.#restElements.at(-1);
			this.#callback(pattern, {
				assignments: this.#assignments,
				rest: lastRestElement?.argument === pattern,
				topLevel: pattern === this.#rootPattern
			});
		}
		MemberExpression(node) {
			node.computed && this.rightHandNodes.push(node.property), this.rightHandNodes.push(node.object);
		}
		Property(property) {
			property.computed && this.rightHandNodes.push(property.key), this.visit(property.value);
		}
		RestElement(pattern) {
			this.#restElements.push(pattern), this.visit(pattern.argument), this.#restElements.pop();
		}
		SpreadElement(node) {
			this.visit(node.argument);
		}
		TSTypeAnnotation() {}
	};
	exports.PatternVisitor = PatternVisitor;
})), require_Visitor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.VisitorBase = exports.Visitor = void 0;
	let PatternVisitor_1 = require_PatternVisitor(), VisitorBase_1 = require_VisitorBase();
	exports.Visitor = class Visitor extends VisitorBase_1.VisitorBase {
		#options;
		constructor(optionsOrVisitor) {
			super(optionsOrVisitor instanceof Visitor ? optionsOrVisitor.#options : optionsOrVisitor), this.#options = optionsOrVisitor instanceof Visitor ? optionsOrVisitor.#options : optionsOrVisitor;
		}
		visitPattern(node, callback, options = { processRightHandNodes: !1 }) {
			let visitor = new PatternVisitor_1.PatternVisitor(this.#options, node, callback);
			visitor.visit(node), options.processRightHandNodes && visitor.rightHandNodes.forEach(this.visit, this);
		}
	};
	var VisitorBase_2 = require_VisitorBase();
	Object.defineProperty(exports, "VisitorBase", {
		enumerable: !0,
		get: function() {
			return VisitorBase_2.VisitorBase;
		}
	});
})), require_TypeVisitor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.TypeVisitor = void 0;
	let types_1 = require_dist$1(), definition_1 = require_definition(), scope_1 = require_scope(), Visitor_1 = require_Visitor();
	exports.TypeVisitor = class TypeVisitor extends Visitor_1.Visitor {
		#referencer;
		constructor(referencer) {
			super(referencer), this.#referencer = referencer;
		}
		static visit(referencer, node) {
			new TypeVisitor(referencer).visit(node);
		}
		visitFunctionType(node) {
			this.#referencer.scopeManager.nestFunctionTypeScope(node), this.visit(node.typeParameters);
			for (let param of node.params) {
				let didVisitAnnotation = !1;
				this.visitPattern(param, (pattern, info) => {
					this.#referencer.currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest)), pattern.typeAnnotation && (this.visit(pattern.typeAnnotation), didVisitAnnotation = !0);
				}), !didVisitAnnotation && "typeAnnotation" in param && this.visit(param.typeAnnotation);
			}
			this.visit(node.returnType), this.#referencer.close(node);
		}
		visitPropertyKey(node) {
			node.computed && this.#referencer.visit(node.key);
		}
		Identifier(node) {
			this.#referencer.currentScope().referenceType(node);
		}
		MemberExpression(node) {
			this.visit(node.object);
		}
		TSCallSignatureDeclaration(node) {
			this.visitFunctionType(node);
		}
		TSConditionalType(node) {
			this.#referencer.scopeManager.nestConditionalTypeScope(node), this.visitChildren(node, ["falseType"]), this.#referencer.close(node), this.visit(node.falseType);
		}
		TSConstructorType(node) {
			this.visitFunctionType(node);
		}
		TSConstructSignatureDeclaration(node) {
			this.visitFunctionType(node);
		}
		TSFunctionType(node) {
			this.visitFunctionType(node);
		}
		TSImportType(node) {
			this.visit(node.typeArguments);
		}
		TSIndexSignature(node) {
			for (let param of node.parameters) param.type === types_1.AST_NODE_TYPES.Identifier && this.visit(param.typeAnnotation);
			this.visit(node.typeAnnotation);
		}
		TSInferType(node) {
			let typeParameter = node.typeParameter, scope = this.#referencer.currentScope();
			if (scope.type === scope_1.ScopeType.functionType || scope.type === scope_1.ScopeType.mappedType) {
				let currentScope = scope.upper;
				for (; currentScope;) {
					if (currentScope.type === scope_1.ScopeType.functionType || currentScope.type === scope_1.ScopeType.mappedType) {
						currentScope = currentScope.upper;
						continue;
					}
					if (currentScope.type === scope_1.ScopeType.conditionalType) {
						scope = currentScope;
						break;
					}
					break;
				}
			}
			scope.defineIdentifier(typeParameter.name, new definition_1.TypeDefinition(typeParameter.name, typeParameter)), this.visit(typeParameter.constraint);
		}
		TSInterfaceDeclaration(node) {
			this.#referencer.currentScope().defineIdentifier(node.id, new definition_1.TypeDefinition(node.id, node)), node.typeParameters && (this.#referencer.scopeManager.nestTypeScope(node), this.visit(node.typeParameters)), node.extends.forEach(this.visit, this), this.visit(node.body), node.typeParameters && this.#referencer.close(node);
		}
		TSMappedType(node) {
			this.#referencer.scopeManager.nestMappedTypeScope(node), this.#referencer.currentScope().defineIdentifier(node.key, new definition_1.TypeDefinition(node.key, node)), this.visit(node.constraint), this.visit(node.nameType), this.visit(node.typeAnnotation), this.#referencer.close(node);
		}
		TSMethodSignature(node) {
			this.visitPropertyKey(node), this.visitFunctionType(node);
		}
		TSNamedTupleMember(node) {
			this.visit(node.elementType);
		}
		TSPropertySignature(node) {
			this.visitPropertyKey(node), this.visit(node.typeAnnotation);
		}
		TSQualifiedName(node) {
			this.visit(node.left);
		}
		TSTypeAliasDeclaration(node) {
			this.#referencer.currentScope().defineIdentifier(node.id, new definition_1.TypeDefinition(node.id, node)), node.typeParameters && (this.#referencer.scopeManager.nestTypeScope(node), this.visit(node.typeParameters)), this.visit(node.typeAnnotation), node.typeParameters && this.#referencer.close(node);
		}
		TSTypeParameter(node) {
			this.#referencer.currentScope().defineIdentifier(node.name, new definition_1.TypeDefinition(node.name, node)), this.visit(node.constraint), this.visit(node.default);
		}
		TSTypePredicate(node) {
			node.parameterName.type !== types_1.AST_NODE_TYPES.TSThisType && this.#referencer.currentScope().referenceValue(node.parameterName), this.visit(node.typeAnnotation);
		}
		TSTypeAnnotation(node) {
			this.visitChildren(node);
		}
		TSTypeQuery(node) {
			let entityName;
			if (node.exprName.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
				let iter = node.exprName;
				for (; iter.left.type === types_1.AST_NODE_TYPES.TSQualifiedName;) iter = iter.left;
				entityName = iter.left;
			} else entityName = node.exprName, node.exprName.type === types_1.AST_NODE_TYPES.TSImportType && this.visit(node.exprName);
			entityName.type === types_1.AST_NODE_TYPES.Identifier && this.#referencer.currentScope().referenceValue(entityName), this.visit(node.typeArguments);
		}
	};
})), require_ClassVisitor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ClassVisitor = void 0;
	let types_1 = require_dist$1(), definition_1 = require_definition(), TypeVisitor_1 = require_TypeVisitor(), Visitor_1 = require_Visitor();
	exports.ClassVisitor = class ClassVisitor extends Visitor_1.Visitor {
		#referencer;
		constructor(referencer) {
			super(referencer), this.#referencer = referencer;
		}
		static visit(referencer, node) {
			new ClassVisitor(referencer).visitClass(node);
		}
		visit(node) {
			node && node.type in this ? super.visit(node) : this.#referencer.visit(node);
		}
		visitClass(node) {
			node.type === types_1.AST_NODE_TYPES.ClassDeclaration && node.id && this.#referencer.currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node)), node.decorators.forEach((d) => this.#referencer.visit(d)), this.#referencer.scopeManager.nestClassScope(node), node.id && this.#referencer.currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node)), this.#referencer.visit(node.superClass), this.visitType(node.typeParameters), this.visitType(node.superTypeArguments), node.implements.forEach((imp) => this.visitType(imp)), this.visit(node.body), this.#referencer.close(node);
		}
		visitFunctionParameterTypeAnnotation(node) {
			switch (node.type) {
				case types_1.AST_NODE_TYPES.AssignmentPattern:
					this.visitType(node.left.typeAnnotation);
					break;
				case types_1.AST_NODE_TYPES.TSParameterProperty:
					this.visitFunctionParameterTypeAnnotation(node.parameter);
					break;
				default: this.visitType(node.typeAnnotation);
			}
		}
		visitMethod(node) {
			node.computed && this.#referencer.visit(node.key), node.value.type === types_1.AST_NODE_TYPES.FunctionExpression ? this.visitMethodFunction(node.value) : this.#referencer.visit(node.value), node.decorators.forEach((d) => this.#referencer.visit(d));
		}
		visitMethodFunction(node) {
			node.id && this.#referencer.scopeManager.nestFunctionExpressionNameScope(node), node.params.forEach((param) => {
				param.decorators.forEach((d) => this.visit(d));
			}), this.#referencer.scopeManager.nestFunctionScope(node, !0);
			for (let param of node.params) this.visitPattern(param, (pattern, info) => {
				this.#referencer.currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest)), this.#referencer.referencingDefaultValue(pattern, info.assignments, null, !0);
			}, { processRightHandNodes: !0 }), this.visitFunctionParameterTypeAnnotation(param);
			this.visitType(node.returnType), this.visitType(node.typeParameters), this.#referencer.visitChildren(node.body), this.#referencer.close(node);
		}
		visitPropertyBase(node) {
			node.computed && this.#referencer.visit(node.key), node.value && ((node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) && this.#referencer.scopeManager.nestClassFieldInitializerScope(node.value), this.#referencer.visit(node.value), (node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) && this.#referencer.close(node.value)), node.decorators.forEach((d) => this.#referencer.visit(d));
		}
		visitPropertyDefinition(node) {
			this.visitPropertyBase(node), this.visitType(node.typeAnnotation);
		}
		visitType(node) {
			node && TypeVisitor_1.TypeVisitor.visit(this.#referencer, node);
		}
		AccessorProperty(node) {
			this.visitPropertyDefinition(node);
		}
		ClassBody(node) {
			this.visitChildren(node);
		}
		Identifier(node) {
			this.#referencer.visit(node);
		}
		MethodDefinition(node) {
			this.visitMethod(node);
		}
		PrivateIdentifier() {}
		PropertyDefinition(node) {
			this.visitPropertyDefinition(node);
		}
		StaticBlock(node) {
			this.#referencer.scopeManager.nestClassStaticBlockScope(node), node.body.forEach((b) => this.visit(b)), this.#referencer.close(node);
		}
		TSAbstractAccessorProperty(node) {
			this.visitPropertyDefinition(node);
		}
		TSAbstractMethodDefinition(node) {
			this.visitPropertyBase(node);
		}
		TSAbstractPropertyDefinition(node) {
			this.visitPropertyDefinition(node);
		}
		TSIndexSignature(node) {
			this.visitType(node);
		}
	};
})), require_ExportVisitor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ExportVisitor = void 0;
	let types_1 = require_dist$1(), Visitor_1 = require_Visitor();
	exports.ExportVisitor = class ExportVisitor extends Visitor_1.Visitor {
		#exportNode;
		#referencer;
		constructor(node, referencer) {
			super(referencer), this.#exportNode = node, this.#referencer = referencer;
		}
		static visit(referencer, node) {
			new ExportVisitor(node, referencer).visit(node);
		}
		ExportDefaultDeclaration(node) {
			node.declaration.type === types_1.AST_NODE_TYPES.Identifier && this.visit(node.declaration);
		}
		ExportNamedDeclaration(node) {
			node.source || node.declaration || this.visitChildren(node);
		}
		ExportSpecifier(node) {
			node.exportKind === "type" && node.local.type === types_1.AST_NODE_TYPES.Identifier ? this.#referencer.currentScope().referenceType(node.local) : this.visit(node.local);
		}
		Identifier(node) {
			this.#exportNode.exportKind === "type" ? this.#referencer.currentScope().referenceType(node) : this.#referencer.currentScope().referenceDualValueType(node);
		}
	};
})), require_ImportVisitor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ImportVisitor = void 0;
	let definition_1 = require_definition(), Visitor_1 = require_Visitor();
	exports.ImportVisitor = class ImportVisitor extends Visitor_1.Visitor {
		#declaration;
		#referencer;
		constructor(declaration, referencer) {
			super(referencer), this.#declaration = declaration, this.#referencer = referencer;
		}
		static visit(referencer, declaration) {
			new ImportVisitor(declaration, referencer).visit(declaration);
		}
		ImportDefaultSpecifier(node) {
			let local = node.local;
			this.visitImport(local, node);
		}
		ImportNamespaceSpecifier(node) {
			let local = node.local;
			this.visitImport(local, node);
		}
		ImportSpecifier(node) {
			let local = node.local;
			this.visitImport(local, node);
		}
		visitImport(id, specifier) {
			this.#referencer.currentScope().defineIdentifier(id, new definition_1.ImportBindingDefinition(id, specifier, this.#declaration));
		}
	};
})), require_Referencer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Referencer = void 0;
	let types_1 = require_dist$1(), assert_1 = require_assert$1(), definition_1 = require_definition(), lib_1 = require_lib(), ClassVisitor_1 = require_ClassVisitor(), ExportVisitor_1 = require_ExportVisitor(), ImportVisitor_1 = require_ImportVisitor(), PatternVisitor_1 = require_PatternVisitor(), Reference_1 = require_Reference(), TypeVisitor_1 = require_TypeVisitor(), Visitor_1 = require_Visitor();
	var Referencer = class extends Visitor_1.Visitor {
		#hasReferencedJsxFactory = !1;
		#hasReferencedJsxFragmentFactory = !1;
		#jsxFragmentName;
		#jsxPragma;
		#lib;
		scopeManager;
		constructor(options, scopeManager) {
			super(options), this.scopeManager = scopeManager, this.#jsxPragma = options.jsxPragma, this.#jsxFragmentName = options.jsxFragmentName, this.#lib = options.lib;
		}
		populateGlobalsFromLib(globalScope) {
			let flattenedLibs = /* @__PURE__ */ new Set();
			for (let lib of this.#lib) {
				let definition = lib_1.lib.get(lib);
				if (!definition) throw Error(`Invalid value for lib provided: ${lib}`);
				flattenedLibs.add(definition);
			}
			for (let lib of flattenedLibs) {
				for (let referencedLib of lib.libs) flattenedLibs.add(referencedLib);
				for (let [name, variable] of lib.variables) globalScope.defineImplicitVariable(name, variable);
			}
			globalScope.defineImplicitVariable("const", {
				eslintImplicitGlobalSetting: "readonly",
				isTypeVariable: !0,
				isValueVariable: !1
			});
		}
		close(node) {
			for (; this.currentScope(!0) && node === this.currentScope().block;) this.scopeManager.currentScope = this.currentScope().close(this.scopeManager);
		}
		currentScope(dontThrowOnNull) {
			return dontThrowOnNull || (0, assert_1.assert)(this.scopeManager.currentScope, "Expected currentScope to exist. This usually happens when analyze() is called with an incomplete AST node instead of a complete Program node."), this.scopeManager.currentScope;
		}
		referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
			assignments.forEach((assignment) => {
				this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, assignment.right, maybeImplicitGlobal, init);
			});
		}
		referenceInSomeUpperScope(name) {
			let scope = this.scopeManager.currentScope;
			for (; scope;) {
				let variable = scope.set.get(name);
				if (!variable) {
					scope = scope.upper;
					continue;
				}
				return scope.referenceValue(variable.identifiers[0]), !0;
			}
			return !1;
		}
		referenceJsxFragment() {
			this.#jsxFragmentName == null || this.#hasReferencedJsxFragmentFactory || (this.#hasReferencedJsxFragmentFactory = this.referenceInSomeUpperScope(this.#jsxFragmentName));
		}
		referenceJsxPragma() {
			this.#jsxPragma == null || this.#hasReferencedJsxFactory || (this.#hasReferencedJsxFactory = this.referenceInSomeUpperScope(this.#jsxPragma));
		}
		visitClass(node) {
			ClassVisitor_1.ClassVisitor.visit(this, node);
		}
		visitForIn(node) {
			node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration && node.left.kind !== "var" && this.scopeManager.nestForScope(node), node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration ? (this.visit(node.left), this.visitPattern(node.left.declarations[0].id, (pattern) => {
				this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, null, !0);
			})) : this.visitPattern(node.left, (pattern, info) => {
				let maybeImplicitGlobal = this.currentScope().isStrict ? null : {
					node,
					pattern
				};
				this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, !1), this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, !1);
			}, { processRightHandNodes: !0 }), this.visit(node.right), this.visit(node.body), this.close(node);
		}
		visitFunction(node) {
			node.type === types_1.AST_NODE_TYPES.FunctionExpression ? node.id && this.scopeManager.nestFunctionExpressionNameScope(node) : node.id && this.currentScope().defineIdentifier(node.id, new definition_1.FunctionNameDefinition(node.id, node)), this.scopeManager.nestFunctionScope(node, !1);
			for (let param of node.params) this.visitPattern(param, (pattern, info) => {
				this.currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest)), this.referencingDefaultValue(pattern, info.assignments, null, !0);
			}, { processRightHandNodes: !0 }), this.visitFunctionParameterTypeAnnotation(param), param.decorators.forEach((d) => this.visit(d));
			this.visitType(node.returnType), this.visitType(node.typeParameters), node.body && (node.body.type === types_1.AST_NODE_TYPES.BlockStatement ? this.visitChildren(node.body) : this.visit(node.body)), this.close(node);
		}
		visitFunctionParameterTypeAnnotation(node) {
			switch (node.type) {
				case types_1.AST_NODE_TYPES.AssignmentPattern:
					this.visitType(node.left.typeAnnotation);
					break;
				case types_1.AST_NODE_TYPES.TSParameterProperty:
					this.visitFunctionParameterTypeAnnotation(node.parameter);
					break;
				default:
					this.visitType(node.typeAnnotation);
					break;
			}
		}
		visitJSXElement(node) {
			node.name.type === types_1.AST_NODE_TYPES.JSXIdentifier ? (node.name.name[0].toUpperCase() === node.name.name[0] || node.name.name === "this") && this.visit(node.name) : this.visit(node.name);
		}
		visitProperty(node) {
			node.computed && this.visit(node.key), this.visit(node.value);
		}
		visitType(node) {
			node && TypeVisitor_1.TypeVisitor.visit(this, node);
		}
		visitTypeAssertion(node) {
			this.visit(node.expression), this.visitType(node.typeAnnotation);
		}
		ArrowFunctionExpression(node) {
			this.visitFunction(node);
		}
		AssignmentExpression(node) {
			let left = this.visitExpressionTarget(node.left);
			PatternVisitor_1.PatternVisitor.isPattern(left) ? node.operator === "=" ? this.visitPattern(left, (pattern, info) => {
				let maybeImplicitGlobal = this.currentScope().isStrict ? null : {
					node,
					pattern
				};
				this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, !1), this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, !1);
			}, { processRightHandNodes: !0 }) : left.type === types_1.AST_NODE_TYPES.Identifier && this.currentScope().referenceValue(left, Reference_1.ReferenceFlag.ReadWrite, node.right) : this.visit(left), this.visit(node.right);
		}
		BlockStatement(node) {
			this.scopeManager.nestBlockScope(node), this.visitChildren(node), this.close(node);
		}
		BreakStatement() {}
		CallExpression(node) {
			this.visitChildren(node, ["typeArguments"]), this.visitType(node.typeArguments);
		}
		CatchClause(node) {
			if (this.scopeManager.nestCatchScope(node), node.param) {
				let param = node.param;
				this.visitPattern(param, (pattern, info) => {
					this.currentScope().defineIdentifier(pattern, new definition_1.CatchClauseDefinition(param, node)), this.referencingDefaultValue(pattern, info.assignments, null, !0);
				}, { processRightHandNodes: !0 });
			}
			this.visit(node.body), this.close(node);
		}
		ClassDeclaration(node) {
			this.visitClass(node);
		}
		ClassExpression(node) {
			this.visitClass(node);
		}
		ContinueStatement() {}
		ExportAllDeclaration() {}
		ExportDefaultDeclaration(node) {
			node.declaration.type === types_1.AST_NODE_TYPES.Identifier ? ExportVisitor_1.ExportVisitor.visit(this, node) : this.visit(node.declaration);
		}
		ExportNamedDeclaration(node) {
			node.declaration ? this.visit(node.declaration) : ExportVisitor_1.ExportVisitor.visit(this, node);
		}
		ForInStatement(node) {
			this.visitForIn(node);
		}
		ForOfStatement(node) {
			this.visitForIn(node);
		}
		ForStatement(node) {
			node.init?.type === types_1.AST_NODE_TYPES.VariableDeclaration && node.init.kind !== "var" && this.scopeManager.nestForScope(node), this.visitChildren(node), this.close(node);
		}
		FunctionDeclaration(node) {
			this.visitFunction(node);
		}
		FunctionExpression(node) {
			this.visitFunction(node);
		}
		Identifier(node) {
			this.currentScope().referenceValue(node), this.visitType(node.typeAnnotation);
		}
		ImportAttribute() {}
		ImportDeclaration(node) {
			(0, assert_1.assert)(this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context."), ImportVisitor_1.ImportVisitor.visit(this, node);
		}
		JSXAttribute(node) {
			this.visit(node.value);
		}
		JSXClosingElement(node) {
			this.visitJSXElement(node);
		}
		JSXFragment(node) {
			this.referenceJsxPragma(), this.referenceJsxFragment(), this.visitChildren(node);
		}
		JSXIdentifier(node) {
			this.currentScope().referenceValue(node);
		}
		JSXMemberExpression(node) {
			(node.object.type !== types_1.AST_NODE_TYPES.JSXIdentifier || node.object.name !== "this") && this.visit(node.object);
		}
		JSXOpeningElement(node) {
			this.referenceJsxPragma(), this.visitJSXElement(node), this.visitType(node.typeArguments);
			for (let attr of node.attributes) this.visit(attr);
		}
		LabeledStatement(node) {
			this.visit(node.body);
		}
		MemberExpression(node) {
			this.visit(node.object), node.computed && this.visit(node.property);
		}
		MetaProperty() {}
		NewExpression(node) {
			this.visitChildren(node, ["typeArguments"]), this.visitType(node.typeArguments);
		}
		PrivateIdentifier() {}
		Program(node) {
			let globalScope = this.scopeManager.nestGlobalScope(node);
			this.populateGlobalsFromLib(globalScope), this.scopeManager.isGlobalReturn() && (this.currentScope().isStrict = !1, this.scopeManager.nestFunctionScope(node, !1)), this.scopeManager.isModule() && this.scopeManager.nestModuleScope(node), this.scopeManager.isImpliedStrict() && (this.currentScope().isStrict = !0), this.visitChildren(node), this.close(node);
		}
		Property(node) {
			this.visitProperty(node);
		}
		SwitchStatement(node) {
			this.visit(node.discriminant), this.scopeManager.nestSwitchScope(node);
			for (let switchCase of node.cases) this.visit(switchCase);
			this.close(node);
		}
		TaggedTemplateExpression(node) {
			this.visit(node.tag), this.visit(node.quasi), this.visitType(node.typeArguments);
		}
		TSAsExpression(node) {
			this.visitTypeAssertion(node);
		}
		TSDeclareFunction(node) {
			this.visitFunction(node);
		}
		TSEmptyBodyFunctionExpression(node) {
			this.visitFunction(node);
		}
		TSEnumDeclaration(node) {
			this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node)), this.scopeManager.nestTSEnumScope(node);
			for (let member of node.body.members) {
				if (member.id.type === types_1.AST_NODE_TYPES.Literal && typeof member.id.value == "string") {
					let name = member.id;
					this.currentScope().defineLiteralIdentifier(name, new definition_1.TSEnumMemberDefinition(name, member));
				} else member.id.type === types_1.AST_NODE_TYPES.Identifier && this.currentScope().defineIdentifier(member.id, new definition_1.TSEnumMemberDefinition(member.id, member));
				this.visit(member.initializer);
			}
			this.close(node);
		}
		TSExportAssignment(node) {
			node.expression.type === types_1.AST_NODE_TYPES.Identifier ? this.currentScope().referenceDualValueType(node.expression) : this.visit(node.expression);
		}
		TSImportEqualsDeclaration(node) {
			if (this.currentScope().defineIdentifier(node.id, new definition_1.ImportBindingDefinition(node.id, node, node)), node.moduleReference.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
				let moduleIdentifier = node.moduleReference.left;
				for (; moduleIdentifier.type === types_1.AST_NODE_TYPES.TSQualifiedName;) moduleIdentifier = moduleIdentifier.left;
				this.visit(moduleIdentifier);
			} else this.visit(node.moduleReference);
		}
		TSInstantiationExpression(node) {
			this.visitChildren(node, ["typeArguments"]), this.visitType(node.typeArguments);
		}
		TSInterfaceDeclaration(node) {
			this.visitType(node);
		}
		TSModuleDeclaration(node) {
			node.id.type === types_1.AST_NODE_TYPES.Identifier && node.kind !== "global" && this.currentScope().defineIdentifier(node.id, new definition_1.TSModuleNameDefinition(node.id, node)), this.scopeManager.nestTSModuleScope(node), this.visit(node.body), this.close(node);
		}
		TSSatisfiesExpression(node) {
			this.visitTypeAssertion(node);
		}
		TSTypeAliasDeclaration(node) {
			this.visitType(node);
		}
		TSTypeAssertion(node) {
			this.visitTypeAssertion(node);
		}
		UpdateExpression(node) {
			let argument = this.visitExpressionTarget(node.argument);
			PatternVisitor_1.PatternVisitor.isPattern(argument) ? this.visitPattern(argument, (pattern) => {
				this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.ReadWrite, null);
			}) : this.visitChildren(node);
		}
		VariableDeclaration(node) {
			let variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();
			for (let decl of node.declarations) {
				let init = decl.init;
				this.visitPattern(decl.id, (pattern, info) => {
					variableTargetScope.defineIdentifier(pattern, new definition_1.VariableDefinition(pattern, decl, node)), this.referencingDefaultValue(pattern, info.assignments, null, !0), init && this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, init, null, !0);
				}, { processRightHandNodes: !0 }), this.visit(decl.init), this.visitType(decl.id.typeAnnotation);
			}
		}
		WithStatement(node) {
			this.visit(node.object), this.scopeManager.nestWithScope(node), this.visit(node.body), this.close(node);
		}
		visitExpressionTarget(left) {
			switch (left.type) {
				case types_1.AST_NODE_TYPES.TSAsExpression:
				case types_1.AST_NODE_TYPES.TSTypeAssertion: this.visitType(left.typeAnnotation);
				case types_1.AST_NODE_TYPES.TSNonNullExpression: left = left.expression;
			}
			return left;
		}
	};
	exports.Referencer = Referencer;
})), require_referencer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Referencer = void 0;
	var Referencer_1 = require_Referencer();
	Object.defineProperty(exports, "Referencer", {
		enumerable: !0,
		get: function() {
			return Referencer_1.Referencer;
		}
	});
})), require_ClassStaticBlockScope = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ClassStaticBlockScope = void 0;
	let ScopeBase_1 = require_ScopeBase(), ScopeType_1 = require_ScopeType();
	var ClassStaticBlockScope = class extends ScopeBase_1.ScopeBase {
		constructor(scopeManager, upperScope, block) {
			super(scopeManager, ScopeType_1.ScopeType.classStaticBlock, upperScope, block, !1);
		}
	};
	exports.ClassStaticBlockScope = ClassStaticBlockScope;
})), require_ScopeManager = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ScopeManager = void 0;
	let assert_1 = require_assert$1(), scope_1 = require_scope(), ClassFieldInitializerScope_1 = require_ClassFieldInitializerScope(), ClassStaticBlockScope_1 = require_ClassStaticBlockScope();
	var ScopeManager = class {
		#options;
		currentScope;
		declaredVariables;
		globalScope;
		nodeToScope;
		scopes;
		constructor(options) {
			this.scopes = [], this.globalScope = null, this.nodeToScope = /* @__PURE__ */ new WeakMap(), this.currentScope = null, this.#options = options, this.declaredVariables = /* @__PURE__ */ new WeakMap();
		}
		isES6() {
			return !0;
		}
		isGlobalReturn() {
			return this.#options.globalReturn === !0;
		}
		isImpliedStrict() {
			return this.#options.impliedStrict === !0;
		}
		isModule() {
			return this.#options.sourceType === "module";
		}
		isStrictModeSupported() {
			return !0;
		}
		get variables() {
			let variables = /* @__PURE__ */ new Set();
			function recurse(scope) {
				scope.variables.forEach((v) => variables.add(v)), scope.childScopes.forEach(recurse);
			}
			return this.scopes.forEach(recurse), [...variables].sort((a, b) => a.$id - b.$id);
		}
		getDeclaredVariables(node) {
			return this.declaredVariables.get(node) ?? [];
		}
		acquire(node, inner = !1) {
			function predicate(testScope) {
				return !(testScope.type === scope_1.ScopeType.function && testScope.functionExpressionScope);
			}
			let scopes = this.nodeToScope.get(node);
			if (!scopes || scopes.length === 0) return null;
			if (scopes.length === 1) return scopes[0];
			if (inner) {
				for (let i = scopes.length - 1; i >= 0; --i) {
					let scope = scopes[i];
					if (predicate(scope)) return scope;
				}
				return null;
			}
			return scopes.find(predicate) ?? null;
		}
		nestBlockScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.BlockScope(this, this.currentScope, node));
		}
		nestCatchScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.CatchScope(this, this.currentScope, node));
		}
		nestClassFieldInitializerScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new ClassFieldInitializerScope_1.ClassFieldInitializerScope(this, this.currentScope, node));
		}
		nestClassScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.ClassScope(this, this.currentScope, node));
		}
		nestClassStaticBlockScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new ClassStaticBlockScope_1.ClassStaticBlockScope(this, this.currentScope, node));
		}
		nestConditionalTypeScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.ConditionalTypeScope(this, this.currentScope, node));
		}
		nestForScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.ForScope(this, this.currentScope, node));
		}
		nestFunctionExpressionNameScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.FunctionExpressionNameScope(this, this.currentScope, node));
		}
		nestFunctionScope(node, isMethodDefinition) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.FunctionScope(this, this.currentScope, node, isMethodDefinition));
		}
		nestFunctionTypeScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.FunctionTypeScope(this, this.currentScope, node));
		}
		nestGlobalScope(node) {
			return this.nestScope(new scope_1.GlobalScope(this, node));
		}
		nestMappedTypeScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.MappedTypeScope(this, this.currentScope, node));
		}
		nestModuleScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.ModuleScope(this, this.currentScope, node));
		}
		nestSwitchScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.SwitchScope(this, this.currentScope, node));
		}
		nestTSEnumScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.TSEnumScope(this, this.currentScope, node));
		}
		nestTSModuleScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.TSModuleScope(this, this.currentScope, node));
		}
		nestTypeScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.TypeScope(this, this.currentScope, node));
		}
		nestWithScope(node) {
			return (0, assert_1.assert)(this.currentScope), this.nestScope(new scope_1.WithScope(this, this.currentScope, node));
		}
		nestScope(scope) {
			return scope instanceof scope_1.GlobalScope && ((0, assert_1.assert)(this.currentScope == null), this.globalScope = scope), this.currentScope = scope, scope;
		}
	};
	exports.ScopeManager = ScopeManager;
})), require_analyze = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.analyze = analyze;
	let visitor_keys_1 = require_dist$2(), referencer_1 = require_referencer(), ScopeManager_1 = require_ScopeManager(), DEFAULT_OPTIONS = {
		childVisitorKeys: visitor_keys_1.visitorKeys,
		emitDecoratorMetadata: !1,
		globalReturn: !1,
		impliedStrict: !1,
		jsxFragmentName: null,
		jsxPragma: "React",
		lib: ["es2018"],
		sourceType: "script"
	};
	function analyze(tree, providedOptions) {
		let options = {
			childVisitorKeys: providedOptions?.childVisitorKeys ?? DEFAULT_OPTIONS.childVisitorKeys,
			emitDecoratorMetadata: !1,
			globalReturn: providedOptions?.globalReturn ?? DEFAULT_OPTIONS.globalReturn,
			impliedStrict: providedOptions?.impliedStrict ?? DEFAULT_OPTIONS.impliedStrict,
			jsxFragmentName: providedOptions?.jsxFragmentName ?? DEFAULT_OPTIONS.jsxFragmentName,
			jsxPragma: providedOptions?.jsxPragma === void 0 ? DEFAULT_OPTIONS.jsxPragma : providedOptions.jsxPragma,
			lib: providedOptions?.lib ?? ["esnext"],
			sourceType: providedOptions?.sourceType ?? DEFAULT_OPTIONS.sourceType
		};
		options.lib = options.lib.map((l) => l.toLowerCase());
		let scopeManager = new ScopeManager_1.ScopeManager(options);
		return new referencer_1.Referencer(options, scopeManager).visit(tree), scopeManager;
	}
})), require_dist = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k);
		var desc = Object.getOwnPropertyDescriptor(m, k);
		(!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
			enumerable: !0,
			get: function() {
				return m[k];
			}
		}), Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		k2 === void 0 && (k2 = k), o[k2] = m[k];
	})), __exportStar = exports && exports.__exportStar || function(m, exports$2) {
		for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports$2, p) && __createBinding(exports$2, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ScopeManager = exports.Visitor = exports.Reference = exports.PatternVisitor = exports.analyze = void 0;
	var analyze_1 = require_analyze();
	Object.defineProperty(exports, "analyze", {
		enumerable: !0,
		get: function() {
			return analyze_1.analyze;
		}
	}), __exportStar(require_definition(), exports);
	var PatternVisitor_1 = require_PatternVisitor();
	Object.defineProperty(exports, "PatternVisitor", {
		enumerable: !0,
		get: function() {
			return PatternVisitor_1.PatternVisitor;
		}
	});
	var Reference_1 = require_Reference();
	Object.defineProperty(exports, "Reference", {
		enumerable: !0,
		get: function() {
			return Reference_1.Reference;
		}
	});
	var Visitor_1 = require_Visitor();
	Object.defineProperty(exports, "Visitor", {
		enumerable: !0,
		get: function() {
			return Visitor_1.Visitor;
		}
	}), __exportStar(require_scope(), exports);
	var ScopeManager_1 = require_ScopeManager();
	Object.defineProperty(exports, "ScopeManager", {
		enumerable: !0,
		get: function() {
			return ScopeManager_1.ScopeManager;
		}
	}), __exportStar(require_variable(), exports);
}));
let globalsJSON = null, globals = null, envs = null;
function setGlobalsForFile(globalsJSONInput) {
	globalsJSON = globalsJSONInput;
}
function initGlobals() {
	({globals, envs} = JSONParse(globalsJSON)), ObjectFreeze(globals), ObjectFreeze(envs);
}
function resetGlobals() {
	globals = null, envs = null, globalsJSON = null;
}
const ENV_AMD = {
	readonly: ["define", "require"],
	writable: []
}, ENV_APPLESCRIPT = {
	readonly: [
		"$",
		"Application",
		"Automation",
		"Library",
		"ObjC",
		"ObjectSpecifier",
		"Path",
		"Progress",
		"Ref",
		"console",
		"delay"
	],
	writable: []
}, ENV_ASTRO = {
	readonly: ["Astro"],
	writable: []
}, ENV_ATOMTEST = {
	readonly: [
		"advanceClock",
		"atom",
		"fakeClearInterval",
		"fakeClearTimeout",
		"fakeSetInterval",
		"fakeSetTimeout",
		"resetTimeouts",
		"waitsForPromise"
	],
	writable: []
}, ENV_AUDIOWORKLET = {
	readonly: /* @__PURE__ */ "AbortController.AbortSignal.AsyncDisposableStack.AudioWorkletGlobalScope.AudioWorkletProcessor.ByteLengthQueuingStrategy.CompressionStream.CountQueuingStrategy.DecompressionStream.DisposableStack.Event.EventTarget.MessageEvent.MessagePort.PaintWorkletGlobalScope.QuotaExceededError.ReadableByteStreamController.ReadableStream.ReadableStreamBYOBReader.ReadableStreamBYOBRequest.ReadableStreamDefaultController.ReadableStreamDefaultReader.SuppressedError.Temporal.TextDecoderStream.TextEncoderStream.TransformStream.TransformStreamDefaultController.UserActivation.WebAssembly.WorkletGlobalScope.WritableStream.WritableStreamDefaultController.WritableStreamDefaultWriter.console.currentFrame.currentTime.port.registerProcessor.sampleRate".split("."),
	writable: []
}, ENV_BROWSER = {
	readonly: /* @__PURE__ */ "AI.AICreateMonitor.AITextSession.AbortController.AbortSignal.AbsoluteOrientationSensor.AbstractRange.Accelerometer.AnalyserNode.Animation.AnimationEffect.AnimationEvent.AnimationPlaybackEvent.AnimationTimeline.AsyncDisposableStack.Attr.Audio.AudioBuffer.AudioBufferSourceNode.AudioContext.AudioData.AudioDecoder.AudioDestinationNode.AudioEncoder.AudioListener.AudioNode.AudioParam.AudioParamMap.AudioProcessingEvent.AudioScheduledSourceNode.AudioSinkInfo.AudioWorklet.AudioWorkletNode.AuthenticatorAssertionResponse.AuthenticatorAttestationResponse.AuthenticatorResponse.BackgroundFetchManager.BackgroundFetchRecord.BackgroundFetchRegistration.BarProp.BarcodeDetector.BaseAudioContext.BatteryManager.BeforeUnloadEvent.BiquadFilterNode.Blob.BlobEvent.Bluetooth.BluetoothCharacteristicProperties.BluetoothDevice.BluetoothRemoteGATTCharacteristic.BluetoothRemoteGATTDescriptor.BluetoothRemoteGATTServer.BluetoothRemoteGATTService.BluetoothUUID.BroadcastChannel.BrowserCaptureMediaStreamTrack.ByteLengthQueuingStrategy.CDATASection.CSPViolationReportBody.CSS.CSSAnimation.CSSConditionRule.CSSContainerRule.CSSCounterStyleRule.CSSFontFaceRule.CSSFontFeatureValuesRule.CSSFontPaletteValuesRule.CSSFunctionDeclarations.CSSFunctionDescriptors.CSSFunctionRule.CSSGroupingRule.CSSImageValue.CSSImportRule.CSSKeyframeRule.CSSKeyframesRule.CSSKeywordValue.CSSLayerBlockRule.CSSLayerStatementRule.CSSMarginRule.CSSMathClamp.CSSMathInvert.CSSMathMax.CSSMathMin.CSSMathNegate.CSSMathProduct.CSSMathSum.CSSMathValue.CSSMatrixComponent.CSSMediaRule.CSSNamespaceRule.CSSNestedDeclarations.CSSNumericArray.CSSNumericValue.CSSPageDescriptors.CSSPageRule.CSSPerspective.CSSPositionTryDescriptors.CSSPositionTryRule.CSSPositionValue.CSSPropertyRule.CSSRotate.CSSRule.CSSRuleList.CSSScale.CSSScopeRule.CSSSkew.CSSSkewX.CSSSkewY.CSSStartingStyleRule.CSSStyleDeclaration.CSSStyleProperties.CSSStyleRule.CSSStyleSheet.CSSStyleValue.CSSSupportsRule.CSSTransformComponent.CSSTransformValue.CSSTransition.CSSTranslate.CSSUnitValue.CSSUnparsedValue.CSSVariableReferenceValue.CSSViewTransitionRule.Cache.CacheStorage.CanvasCaptureMediaStream.CanvasCaptureMediaStreamTrack.CanvasGradient.CanvasPattern.CanvasRenderingContext2D.CaptureController.CaretPosition.ChannelMergerNode.ChannelSplitterNode.ChapterInformation.CharacterBoundsUpdateEvent.CharacterData.Clipboard.ClipboardChangeEvent.ClipboardEvent.ClipboardItem.CloseEvent.CloseWatcher.CommandEvent.Comment.CompositionEvent.CompressionStream.ConstantSourceNode.ContentVisibilityAutoStateChangeEvent.ConvolverNode.CookieChangeEvent.CookieDeprecationLabel.CookieStore.CookieStoreManager.CountQueuingStrategy.CreateMonitor.Credential.CredentialsContainer.CropTarget.Crypto.CryptoKey.CustomElementRegistry.CustomEvent.CustomStateSet.DOMError.DOMException.DOMImplementation.DOMMatrix.DOMMatrixReadOnly.DOMParser.DOMPoint.DOMPointReadOnly.DOMQuad.DOMRect.DOMRectList.DOMRectReadOnly.DOMStringList.DOMStringMap.DOMTokenList.DataTransfer.DataTransferItem.DataTransferItemList.DecompressionStream.DelayNode.DelegatedInkTrailPresenter.DeviceMotionEvent.DeviceMotionEventAcceleration.DeviceMotionEventRotationRate.DeviceOrientationEvent.DevicePosture.DigitalCredential.DisposableStack.Document.DocumentFragment.DocumentPictureInPicture.DocumentPictureInPictureEvent.DocumentTimeline.DocumentType.DragEvent.DynamicsCompressorNode.EditContext.Element.ElementInternals.EncodedAudioChunk.EncodedVideoChunk.ErrorEvent.Event.EventCounts.EventSource.EventTarget.External.EyeDropper.FeaturePolicy.FederatedCredential.Fence.FencedFrameConfig.FetchLaterResult.File.FileList.FileReader.FileSystem.FileSystemDirectoryEntry.FileSystemDirectoryHandle.FileSystemDirectoryReader.FileSystemEntry.FileSystemFileEntry.FileSystemFileHandle.FileSystemHandle.FileSystemObserver.FileSystemWritableFileStream.FocusEvent.FontData.FontFace.FontFaceSet.FontFaceSetLoadEvent.FormData.FormDataEvent.FragmentDirective.GPU.GPUAdapter.GPUAdapterInfo.GPUBindGroup.GPUBindGroupLayout.GPUBuffer.GPUBufferUsage.GPUCanvasContext.GPUColorWrite.GPUCommandBuffer.GPUCommandEncoder.GPUCompilationInfo.GPUCompilationMessage.GPUComputePassEncoder.GPUComputePipeline.GPUDevice.GPUDeviceLostInfo.GPUError.GPUExternalTexture.GPUInternalError.GPUMapMode.GPUOutOfMemoryError.GPUPipelineError.GPUPipelineLayout.GPUQuerySet.GPUQueue.GPURenderBundle.GPURenderBundleEncoder.GPURenderPassEncoder.GPURenderPipeline.GPUSampler.GPUShaderModule.GPUShaderStage.GPUSupportedFeatures.GPUSupportedLimits.GPUTexture.GPUTextureUsage.GPUTextureView.GPUUncapturedErrorEvent.GPUValidationError.GainNode.Gamepad.GamepadAxisMoveEvent.GamepadButton.GamepadButtonEvent.GamepadEvent.GamepadHapticActuator.GamepadPose.Geolocation.GeolocationCoordinates.GeolocationPosition.GeolocationPositionError.GravitySensor.Gyroscope.HID.HIDConnectionEvent.HIDDevice.HIDInputReportEvent.HTMLAllCollection.HTMLAnchorElement.HTMLAreaElement.HTMLAudioElement.HTMLBRElement.HTMLBaseElement.HTMLBodyElement.HTMLButtonElement.HTMLCanvasElement.HTMLCollection.HTMLDListElement.HTMLDataElement.HTMLDataListElement.HTMLDetailsElement.HTMLDialogElement.HTMLDirectoryElement.HTMLDivElement.HTMLDocument.HTMLElement.HTMLEmbedElement.HTMLFencedFrameElement.HTMLFieldSetElement.HTMLFontElement.HTMLFormControlsCollection.HTMLFormElement.HTMLFrameElement.HTMLFrameSetElement.HTMLHRElement.HTMLHeadElement.HTMLHeadingElement.HTMLHtmlElement.HTMLIFrameElement.HTMLImageElement.HTMLInputElement.HTMLLIElement.HTMLLabelElement.HTMLLegendElement.HTMLLinkElement.HTMLMapElement.HTMLMarqueeElement.HTMLMediaElement.HTMLMenuElement.HTMLMetaElement.HTMLMeterElement.HTMLModElement.HTMLOListElement.HTMLObjectElement.HTMLOptGroupElement.HTMLOptionElement.HTMLOptionsCollection.HTMLOutputElement.HTMLParagraphElement.HTMLParamElement.HTMLPictureElement.HTMLPreElement.HTMLProgressElement.HTMLQuoteElement.HTMLScriptElement.HTMLSelectElement.HTMLSelectedContentElement.HTMLSlotElement.HTMLSourceElement.HTMLSpanElement.HTMLStyleElement.HTMLTableCaptionElement.HTMLTableCellElement.HTMLTableColElement.HTMLTableElement.HTMLTableRowElement.HTMLTableSectionElement.HTMLTemplateElement.HTMLTextAreaElement.HTMLTimeElement.HTMLTitleElement.HTMLTrackElement.HTMLUListElement.HTMLUnknownElement.HTMLVideoElement.HashChangeEvent.Headers.Highlight.HighlightRegistry.History.IDBCursor.IDBCursorWithValue.IDBDatabase.IDBFactory.IDBIndex.IDBKeyRange.IDBObjectStore.IDBOpenDBRequest.IDBRecord.IDBRequest.IDBTransaction.IDBVersionChangeEvent.IIRFilterNode.IdentityCredential.IdentityCredentialError.IdentityProvider.IdleDeadline.IdleDetector.Image.ImageBitmap.ImageBitmapRenderingContext.ImageCapture.ImageData.ImageDecoder.ImageTrack.ImageTrackList.Ink.InputDeviceCapabilities.InputDeviceInfo.InputEvent.IntegrityViolationReportBody.InterestEvent.IntersectionObserver.IntersectionObserverEntry.Keyboard.KeyboardEvent.KeyboardLayoutMap.KeyframeEffect.LanguageDetector.LargestContentfulPaint.LaunchParams.LaunchQueue.LayoutShift.LayoutShiftAttribution.LinearAccelerationSensor.Location.Lock.LockManager.MIDIAccess.MIDIConnectionEvent.MIDIInput.MIDIInputMap.MIDIMessageEvent.MIDIOutput.MIDIOutputMap.MIDIPort.MathMLElement.MediaCapabilities.MediaCapabilitiesInfo.MediaDeviceInfo.MediaDevices.MediaElementAudioSourceNode.MediaEncryptedEvent.MediaError.MediaKeyError.MediaKeyMessageEvent.MediaKeySession.MediaKeyStatusMap.MediaKeySystemAccess.MediaKeys.MediaList.MediaMetadata.MediaQueryList.MediaQueryListEvent.MediaRecorder.MediaRecorderErrorEvent.MediaSession.MediaSource.MediaSourceHandle.MediaStream.MediaStreamAudioDestinationNode.MediaStreamAudioSourceNode.MediaStreamEvent.MediaStreamTrack.MediaStreamTrackAudioSourceNode.MediaStreamTrackAudioStats.MediaStreamTrackEvent.MediaStreamTrackGenerator.MediaStreamTrackProcessor.MediaStreamTrackVideoStats.MessageChannel.MessageEvent.MessagePort.MimeType.MimeTypeArray.ModelGenericSession.ModelManager.MouseEvent.MutationEvent.MutationObserver.MutationRecord.NamedNodeMap.NavigateEvent.Navigation.NavigationActivation.NavigationCurrentEntryChangeEvent.NavigationDestination.NavigationHistoryEntry.NavigationPrecommitController.NavigationPreloadManager.NavigationTransition.Navigator.NavigatorLogin.NavigatorManagedData.NavigatorUAData.NetworkInformation.Node.NodeFilter.NodeIterator.NodeList.NotRestoredReasonDetails.NotRestoredReasons.Notification.NotifyPaintEvent.OTPCredential.Observable.OfflineAudioCompletionEvent.OfflineAudioContext.OffscreenCanvas.OffscreenCanvasRenderingContext2D.Option.OrientationSensor.OscillatorNode.OverconstrainedError.PERSISTENT.PageRevealEvent.PageSwapEvent.PageTransitionEvent.PannerNode.PasswordCredential.Path2D.PaymentAddress.PaymentManager.PaymentMethodChangeEvent.PaymentRequest.PaymentRequestUpdateEvent.PaymentResponse.Performance.PerformanceElementTiming.PerformanceEntry.PerformanceEventTiming.PerformanceLongAnimationFrameTiming.PerformanceLongTaskTiming.PerformanceMark.PerformanceMeasure.PerformanceNavigation.PerformanceNavigationTiming.PerformanceObserver.PerformanceObserverEntryList.PerformancePaintTiming.PerformanceResourceTiming.PerformanceScriptTiming.PerformanceServerTiming.PerformanceTiming.PeriodicSyncManager.PeriodicWave.PermissionStatus.Permissions.PictureInPictureEvent.PictureInPictureWindow.Plugin.PluginArray.PointerEvent.PopStateEvent.Presentation.PresentationAvailability.PresentationConnection.PresentationConnectionAvailableEvent.PresentationConnectionCloseEvent.PresentationConnectionList.PresentationReceiver.PresentationRequest.PressureObserver.PressureRecord.ProcessingInstruction.Profiler.ProgressEvent.PromiseRejectionEvent.ProtectedAudience.PublicKeyCredential.PushManager.PushSubscription.PushSubscriptionOptions.QuotaExceededError.RTCCertificate.RTCDTMFSender.RTCDTMFToneChangeEvent.RTCDataChannel.RTCDataChannelEvent.RTCDtlsTransport.RTCEncodedAudioFrame.RTCEncodedVideoFrame.RTCError.RTCErrorEvent.RTCIceCandidate.RTCIceTransport.RTCPeerConnection.RTCPeerConnectionIceErrorEvent.RTCPeerConnectionIceEvent.RTCRtpReceiver.RTCRtpScriptTransform.RTCRtpSender.RTCRtpTransceiver.RTCSctpTransport.RTCSessionDescription.RTCStatsReport.RTCTrackEvent.RadioNodeList.Range.ReadableByteStreamController.ReadableStream.ReadableStreamBYOBReader.ReadableStreamBYOBRequest.ReadableStreamDefaultController.ReadableStreamDefaultReader.RelativeOrientationSensor.RemotePlayback.ReportBody.ReportingObserver.Request.ResizeObserver.ResizeObserverEntry.ResizeObserverSize.Response.RestrictionTarget.SVGAElement.SVGAngle.SVGAnimateElement.SVGAnimateMotionElement.SVGAnimateTransformElement.SVGAnimatedAngle.SVGAnimatedBoolean.SVGAnimatedEnumeration.SVGAnimatedInteger.SVGAnimatedLength.SVGAnimatedLengthList.SVGAnimatedNumber.SVGAnimatedNumberList.SVGAnimatedPreserveAspectRatio.SVGAnimatedRect.SVGAnimatedString.SVGAnimatedTransformList.SVGAnimationElement.SVGCircleElement.SVGClipPathElement.SVGComponentTransferFunctionElement.SVGDefsElement.SVGDescElement.SVGElement.SVGEllipseElement.SVGFEBlendElement.SVGFEColorMatrixElement.SVGFEComponentTransferElement.SVGFECompositeElement.SVGFEConvolveMatrixElement.SVGFEDiffuseLightingElement.SVGFEDisplacementMapElement.SVGFEDistantLightElement.SVGFEDropShadowElement.SVGFEFloodElement.SVGFEFuncAElement.SVGFEFuncBElement.SVGFEFuncGElement.SVGFEFuncRElement.SVGFEGaussianBlurElement.SVGFEImageElement.SVGFEMergeElement.SVGFEMergeNodeElement.SVGFEMorphologyElement.SVGFEOffsetElement.SVGFEPointLightElement.SVGFESpecularLightingElement.SVGFESpotLightElement.SVGFETileElement.SVGFETurbulenceElement.SVGFilterElement.SVGForeignObjectElement.SVGGElement.SVGGeometryElement.SVGGradientElement.SVGGraphicsElement.SVGImageElement.SVGLength.SVGLengthList.SVGLineElement.SVGLinearGradientElement.SVGMPathElement.SVGMarkerElement.SVGMaskElement.SVGMatrix.SVGMetadataElement.SVGNumber.SVGNumberList.SVGPathElement.SVGPatternElement.SVGPoint.SVGPointList.SVGPolygonElement.SVGPolylineElement.SVGPreserveAspectRatio.SVGRadialGradientElement.SVGRect.SVGRectElement.SVGSVGElement.SVGScriptElement.SVGSetElement.SVGStopElement.SVGStringList.SVGStyleElement.SVGSwitchElement.SVGSymbolElement.SVGTSpanElement.SVGTextContentElement.SVGTextElement.SVGTextPathElement.SVGTextPositioningElement.SVGTitleElement.SVGTransform.SVGTransformList.SVGUnitTypes.SVGUseElement.SVGViewElement.Scheduler.Scheduling.Screen.ScreenDetailed.ScreenDetails.ScreenOrientation.ScriptProcessorNode.ScrollTimeline.SecurityPolicyViolationEvent.Selection.Sensor.SensorErrorEvent.Serial.SerialPort.ServiceWorker.ServiceWorkerContainer.ServiceWorkerRegistration.ShadowRoot.SharedStorage.SharedStorageAppendMethod.SharedStorageClearMethod.SharedStorageDeleteMethod.SharedStorageModifierMethod.SharedStorageSetMethod.SharedStorageWorklet.SharedWorker.SnapEvent.SourceBuffer.SourceBufferList.SpeechGrammar.SpeechGrammarList.SpeechRecognition.SpeechRecognitionErrorEvent.SpeechRecognitionEvent.SpeechRecognitionPhrase.SpeechSynthesis.SpeechSynthesisErrorEvent.SpeechSynthesisEvent.SpeechSynthesisUtterance.SpeechSynthesisVoice.StaticRange.StereoPannerNode.Storage.StorageBucket.StorageBucketManager.StorageEvent.StorageManager.StylePropertyMap.StylePropertyMapReadOnly.StyleSheet.StyleSheetList.SubmitEvent.Subscriber.SubtleCrypto.Summarizer.SuppressedError.SyncManager.TEMPORARY.TaskAttributionTiming.TaskController.TaskPriorityChangeEvent.TaskSignal.Temporal.Text.TextDecoder.TextDecoderStream.TextEncoder.TextEncoderStream.TextEvent.TextFormat.TextFormatUpdateEvent.TextMetrics.TextTrack.TextTrackCue.TextTrackCueList.TextTrackList.TextUpdateEvent.TimeEvent.TimeRanges.ToggleEvent.Touch.TouchEvent.TouchList.TrackEvent.TransformStream.TransformStreamDefaultController.TransitionEvent.Translator.TreeWalker.TrustedHTML.TrustedScript.TrustedScriptURL.TrustedTypePolicy.TrustedTypePolicyFactory.UIEvent.URL.URLPattern.URLSearchParams.USB.USBAlternateInterface.USBConfiguration.USBConnectionEvent.USBDevice.USBEndpoint.USBInTransferResult.USBInterface.USBIsochronousInTransferPacket.USBIsochronousInTransferResult.USBIsochronousOutTransferPacket.USBIsochronousOutTransferResult.USBOutTransferResult.UserActivation.VTTCue.VTTRegion.ValidityState.VideoColorSpace.VideoDecoder.VideoEncoder.VideoFrame.VideoPlaybackQuality.ViewTimeline.ViewTransition.ViewTransitionTypeSet.Viewport.VirtualKeyboard.VirtualKeyboardGeometryChangeEvent.VisibilityStateEntry.VisualViewport.WGSLLanguageFeatures.WakeLock.WakeLockSentinel.WaveShaperNode.WebAssembly.WebGL2RenderingContext.WebGLActiveInfo.WebGLBuffer.WebGLContextEvent.WebGLFramebuffer.WebGLObject.WebGLProgram.WebGLQuery.WebGLRenderbuffer.WebGLRenderingContext.WebGLSampler.WebGLShader.WebGLShaderPrecisionFormat.WebGLSync.WebGLTexture.WebGLTransformFeedback.WebGLUniformLocation.WebGLVertexArrayObject.WebSocket.WebSocketError.WebSocketStream.WebTransport.WebTransportBidirectionalStream.WebTransportDatagramDuplexStream.WebTransportError.WebTransportReceiveStream.WebTransportSendStream.WheelEvent.Window.WindowControlsOverlay.WindowControlsOverlayGeometryChangeEvent.Worker.Worklet.WritableStream.WritableStreamDefaultController.WritableStreamDefaultWriter.XMLDocument.XMLHttpRequest.XMLHttpRequestEventTarget.XMLHttpRequestUpload.XMLSerializer.XPathEvaluator.XPathExpression.XPathResult.XRAnchor.XRAnchorSet.XRBoundedReferenceSpace.XRCPUDepthInformation.XRCamera.XRDOMOverlayState.XRDepthInformation.XRFrame.XRHand.XRHitTestResult.XRHitTestSource.XRInputSource.XRInputSourceArray.XRInputSourceEvent.XRInputSourcesChangeEvent.XRJointPose.XRJointSpace.XRLayer.XRLightEstimate.XRLightProbe.XRPose.XRRay.XRReferenceSpace.XRReferenceSpaceEvent.XRRenderState.XRRigidTransform.XRSession.XRSessionEvent.XRSpace.XRSystem.XRTransientInputHitTestResult.XRTransientInputHitTestSource.XRView.XRViewerPose.XRViewport.XRWebGLBinding.XRWebGLDepthInformation.XRWebGLLayer.XSLTProcessor.addEventListener.ai.alert.atob.blur.btoa.caches.cancelAnimationFrame.cancelIdleCallback.clearInterval.clearTimeout.clientInformation.close.closed.confirm.console.cookieStore.createImageBitmap.credentialless.crossOriginIsolated.crypto.customElements.devicePixelRatio.dispatchEvent.document.documentPictureInPicture.event.external.fence.fetch.fetchLater.find.focus.frameElement.frames.getComputedStyle.getScreenDetails.getSelection.history.indexedDB.innerHeight.innerWidth.isSecureContext.launchQueue.length.localStorage.locationbar.matchMedia.menubar.model.moveBy.moveTo.name.navigation.navigator.offscreenBuffering.open.opener.origin.originAgentCluster.outerHeight.outerWidth.pageXOffset.pageYOffset.parent.performance.personalbar.postMessage.print.prompt.queryLocalFonts.queueMicrotask.removeEventListener.reportError.requestAnimationFrame.requestIdleCallback.resizeBy.resizeTo.scheduler.screen.screenLeft.screenTop.screenX.screenY.scroll.scrollBy.scrollTo.scrollX.scrollY.scrollbars.self.sessionStorage.setInterval.setTimeout.sharedStorage.showDirectoryPicker.showOpenFilePicker.showSaveFilePicker.speechSynthesis.status.statusbar.stop.structuredClone.styleMedia.toolbar.top.trustedTypes.viewport.visualViewport.when.window".split("."),
	writable: /* @__PURE__ */ "location.onabort.onafterprint.onanimationcancel.onanimationend.onanimationiteration.onanimationstart.onappinstalled.onauxclick.onbeforeinput.onbeforeinstallprompt.onbeforematch.onbeforeprint.onbeforetoggle.onbeforeunload.onbeforexrselect.onblur.oncancel.oncanplay.oncanplaythrough.onchange.onclick.onclose.oncommand.oncontentvisibilityautostatechange.oncontextlost.oncontextmenu.oncontextrestored.oncopy.oncuechange.oncut.ondblclick.ondevicemotion.ondeviceorientation.ondeviceorientationabsolute.ondrag.ondragend.ondragenter.ondragleave.ondragover.ondragstart.ondrop.ondurationchange.onemptied.onended.onerror.onfocus.onformdata.ongamepadconnected.ongamepaddisconnected.ongotpointercapture.onhashchange.oninput.oninvalid.onkeydown.onkeypress.onkeyup.onlanguagechange.onload.onloadeddata.onloadedmetadata.onloadstart.onlostpointercapture.onmessage.onmessageerror.onmousedown.onmouseenter.onmouseleave.onmousemove.onmouseout.onmouseover.onmouseup.onmousewheel.onoffline.ononline.onpagehide.onpagereveal.onpageshow.onpageswap.onpaste.onpause.onplay.onplaying.onpointercancel.onpointerdown.onpointerenter.onpointerleave.onpointermove.onpointerout.onpointerover.onpointerrawupdate.onpointerup.onpopstate.onprogress.onratechange.onrejectionhandled.onreset.onresize.onscroll.onscrollend.onscrollsnapchange.onscrollsnapchanging.onsearch.onsecuritypolicyviolation.onseeked.onseeking.onselect.onselectionchange.onselectstart.onslotchange.onstalled.onstorage.onsubmit.onsuspend.ontimeupdate.ontoggle.ontransitioncancel.ontransitionend.ontransitionrun.ontransitionstart.onunhandledrejection.onunload.onvolumechange.onwaiting.onwheel".split(".")
}, ENV_BUILTIN = {
	readonly: /* @__PURE__ */ "AggregateError.Array.ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.Boolean.DataView.Date.Error.EvalError.FinalizationRegistry.Float16Array.Float32Array.Float64Array.Function.Infinity.Int16Array.Int32Array.Int8Array.Intl.Iterator.JSON.Map.Math.NaN.Number.Object.Promise.Proxy.RangeError.ReferenceError.Reflect.RegExp.Set.SharedArrayBuffer.String.Symbol.SyntaxError.TypeError.URIError.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakRef.WeakSet.decodeURI.decodeURIComponent.encodeURI.encodeURIComponent.escape.eval.globalThis.isFinite.isNaN.parseFloat.parseInt.undefined.unescape".split("."),
	writable: []
}, ENV_COMMONJS = {
	readonly: [
		"global",
		"module",
		"require"
	],
	writable: ["exports"]
}, ENV_EMBERTEST = {
	readonly: [
		"andThen",
		"click",
		"currentPath",
		"currentRouteName",
		"currentURL",
		"fillIn",
		"find",
		"findAll",
		"findWithAssert",
		"keyEvent",
		"pauseTest",
		"resumeTest",
		"triggerEvent",
		"visit",
		"wait"
	],
	writable: []
}, ENV_ES_2015 = {
	readonly: [
		"ArrayBuffer",
		"DataView",
		"Float32Array",
		"Float64Array",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"Intl",
		"Map",
		"Promise",
		"Proxy",
		"Reflect",
		"Set",
		"Symbol",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"WeakMap",
		"WeakSet"
	],
	writable: []
}, ENV_ES_2016 = {
	readonly: [
		"ArrayBuffer",
		"DataView",
		"Float32Array",
		"Float64Array",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"Intl",
		"Map",
		"Promise",
		"Proxy",
		"Reflect",
		"Set",
		"Symbol",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"WeakMap",
		"WeakSet"
	],
	writable: []
}, ENV_ES_2017 = {
	readonly: [
		"ArrayBuffer",
		"Atomics",
		"DataView",
		"Float32Array",
		"Float64Array",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"Intl",
		"Map",
		"Promise",
		"Proxy",
		"Reflect",
		"Set",
		"SharedArrayBuffer",
		"Symbol",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"WeakMap",
		"WeakSet"
	],
	writable: []
}, ENV_ES_2018 = {
	readonly: [
		"ArrayBuffer",
		"Atomics",
		"DataView",
		"Float32Array",
		"Float64Array",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"Intl",
		"Map",
		"Promise",
		"Proxy",
		"Reflect",
		"Set",
		"SharedArrayBuffer",
		"Symbol",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"WeakMap",
		"WeakSet"
	],
	writable: []
}, ENV_ES_2019 = {
	readonly: [
		"ArrayBuffer",
		"Atomics",
		"DataView",
		"Float32Array",
		"Float64Array",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"Intl",
		"Map",
		"Promise",
		"Proxy",
		"Reflect",
		"Set",
		"SharedArrayBuffer",
		"Symbol",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"WeakMap",
		"WeakSet"
	],
	writable: []
}, ENV_ES_2020 = {
	readonly: /* @__PURE__ */ "ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.DataView.Float32Array.Float64Array.Int16Array.Int32Array.Int8Array.Intl.Map.Promise.Proxy.Reflect.Set.SharedArrayBuffer.Symbol.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakSet.globalThis".split("."),
	writable: []
}, ENV_ES_2021 = {
	readonly: /* @__PURE__ */ "AggregateError.ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.DataView.FinalizationRegistry.Float32Array.Float64Array.Int16Array.Int32Array.Int8Array.Intl.Map.Promise.Proxy.Reflect.Set.SharedArrayBuffer.Symbol.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakRef.WeakSet.globalThis".split("."),
	writable: []
}, ENV_ES_2022 = {
	readonly: /* @__PURE__ */ "AggregateError.ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.DataView.FinalizationRegistry.Float32Array.Float64Array.Int16Array.Int32Array.Int8Array.Intl.Map.Promise.Proxy.Reflect.Set.SharedArrayBuffer.Symbol.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakRef.WeakSet.globalThis".split("."),
	writable: []
}, ENV_ES_2023 = {
	readonly: /* @__PURE__ */ "AggregateError.ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.DataView.FinalizationRegistry.Float32Array.Float64Array.Int16Array.Int32Array.Int8Array.Intl.Map.Promise.Proxy.Reflect.Set.SharedArrayBuffer.Symbol.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakRef.WeakSet.globalThis".split("."),
	writable: []
}, ENV_ES_2024 = {
	readonly: /* @__PURE__ */ "AggregateError.ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.DataView.FinalizationRegistry.Float32Array.Float64Array.Int16Array.Int32Array.Int8Array.Intl.Map.Promise.Proxy.Reflect.Set.SharedArrayBuffer.Symbol.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakRef.WeakSet.globalThis".split("."),
	writable: []
}, ENV_ES_2025 = {
	readonly: /* @__PURE__ */ "AggregateError.ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.DataView.FinalizationRegistry.Float16Array.Float32Array.Float64Array.Int16Array.Int32Array.Int8Array.Intl.Iterator.Map.Promise.Proxy.Reflect.Set.SharedArrayBuffer.Symbol.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakRef.WeakSet.globalThis".split("."),
	writable: []
}, ENV_ES_2026 = {
	readonly: /* @__PURE__ */ "AggregateError.ArrayBuffer.Atomics.BigInt.BigInt64Array.BigUint64Array.DataView.FinalizationRegistry.Float16Array.Float32Array.Float64Array.Int16Array.Int32Array.Int8Array.Intl.Iterator.Map.Promise.Proxy.Reflect.Set.SharedArrayBuffer.Symbol.Uint16Array.Uint32Array.Uint8Array.Uint8ClampedArray.WeakMap.WeakRef.WeakSet.globalThis".split("."),
	writable: []
}, ENV_ES_6 = {
	readonly: [
		"ArrayBuffer",
		"DataView",
		"Float32Array",
		"Float64Array",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"Intl",
		"Map",
		"Promise",
		"Proxy",
		"Reflect",
		"Set",
		"Symbol",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"WeakMap",
		"WeakSet"
	],
	writable: []
}, ENV_GREASEMONKEY = {
	readonly: /* @__PURE__ */ "GM.GM_addElement.GM_addStyle.GM_addValueChangeListener.GM_deleteValue.GM_deleteValues.GM_download.GM_getResourceText.GM_getResourceURL.GM_getTab.GM_getTabs.GM_getValue.GM_getValues.GM_info.GM_listValues.GM_log.GM_notification.GM_openInTab.GM_registerMenuCommand.GM_removeValueChangeListener.GM_saveTab.GM_setClipboard.GM_setValue.GM_setValues.GM_unregisterMenuCommand.GM_xmlhttpRequest.cloneInto.createObjectIn.exportFunction.unsafeWindow".split("."),
	writable: []
}, ENV_JASMINE = {
	readonly: [
		"afterAll",
		"afterEach",
		"beforeAll",
		"beforeEach",
		"describe",
		"expect",
		"expectAsync",
		"fail",
		"fdescribe",
		"fit",
		"it",
		"jasmine",
		"pending",
		"runs",
		"spyOn",
		"spyOnAllFunctions",
		"spyOnProperty",
		"waits",
		"waitsFor",
		"xdescribe",
		"xit"
	],
	writable: []
}, ENV_JEST = {
	readonly: [
		"afterAll",
		"afterEach",
		"beforeAll",
		"beforeEach",
		"describe",
		"expect",
		"fit",
		"it",
		"jest",
		"test",
		"xdescribe",
		"xit",
		"xtest"
	],
	writable: []
}, ENV_JQUERY = {
	readonly: ["$", "jQuery"],
	writable: []
}, ENV_METEOR = {
	readonly: /* @__PURE__ */ "$.Accounts.AccountsClient.AccountsCommon.AccountsServer.App.Assets.Blaze.Cordova.DDP.DDPRateLimiter.DDPServer.Deps.EJSON.Email.HTTP.Log.Match.Meteor.Mongo.MongoInternals.Npm.Package.Plugin.Random.ReactiveDict.ReactiveVar.Router.ServiceConfiguration.Session.Spacebars.Template.Tinytest.Tracker.UI.Utils.WebApp.WebAppInternals.check.process.share".split("."),
	writable: []
}, ENV_MOCHA = {
	readonly: [
		"after",
		"afterEach",
		"before",
		"beforeEach",
		"context",
		"describe",
		"it",
		"mocha",
		"run",
		"setup",
		"specify",
		"suite",
		"suiteSetup",
		"suiteTeardown",
		"teardown",
		"test",
		"xcontext",
		"xdescribe",
		"xit",
		"xspecify"
	],
	writable: []
}, ENV_MONGO = {
	readonly: /* @__PURE__ */ "BulkWriteResult.ISODate.Mongo.NumberInt.NumberLong.ObjectId.PlanCache.UUID.WriteResult._isWindows._rand.cat.cd.connect.db.getHostName.getMemInfo.hostname.listFiles.load.ls.md5sumFile.mkdir.print.printjson.pwd.quit.removeFile.rs.sh.version".split("."),
	writable: []
}, ENV_NASHORN = {
	readonly: [
		"JSAdapter",
		"Java",
		"JavaImporter",
		"Packages",
		"__DIR__",
		"__FILE__",
		"__LINE__",
		"com",
		"edu",
		"exit",
		"java",
		"javafx",
		"javax",
		"load",
		"loadWithNewGlobal",
		"org",
		"print",
		"quit"
	],
	writable: []
}, ENV_NODE = {
	readonly: /* @__PURE__ */ "AbortController.AbortSignal.AsyncDisposableStack.Blob.BroadcastChannel.Buffer.ByteLengthQueuingStrategy.CloseEvent.CompressionStream.CountQueuingStrategy.Crypto.CryptoKey.CustomEvent.DOMException.DecompressionStream.DisposableStack.ErrorEvent.Event.EventTarget.File.FormData.Headers.MessageChannel.MessageEvent.MessagePort.Navigator.Performance.PerformanceEntry.PerformanceMark.PerformanceMeasure.PerformanceObserver.PerformanceObserverEntryList.PerformanceResourceTiming.ReadableByteStreamController.ReadableStream.ReadableStreamBYOBReader.ReadableStreamBYOBRequest.ReadableStreamDefaultController.ReadableStreamDefaultReader.Request.Response.Storage.SubtleCrypto.SuppressedError.TextDecoder.TextDecoderStream.TextEncoder.TextEncoderStream.TransformStream.TransformStreamDefaultController.URL.URLPattern.URLSearchParams.WebAssembly.WebSocket.WritableStream.WritableStreamDefaultController.WritableStreamDefaultWriter.__dirname.__filename.atob.btoa.clearImmediate.clearInterval.clearTimeout.console.crypto.fetch.global.localStorage.module.navigator.performance.process.queueMicrotask.require.sessionStorage.setImmediate.setInterval.setTimeout.structuredClone".split("."),
	writable: ["exports"]
}, ENV_PHANTOMJS = {
	readonly: [],
	writable: [
		"WebPage",
		"console",
		"exports",
		"phantom",
		"require"
	]
}, ENV_PROTOTYPEJS = {
	readonly: /* @__PURE__ */ "$.$$.$A.$F.$H.$R.$break.$continue.$w.Abstract.Ajax.Autocompleter.Builder.Class.Control.Draggable.Draggables.Droppables.Effect.Element.Enumerable.Event.Field.Form.Hash.Insertion.ObjectRange.PeriodicalExecuter.Position.Prototype.Scriptaculous.Selector.Sortable.SortableObserver.Sound.Template.Toggle.Try".split("."),
	writable: []
}, ENV_PROTRACTOR = {
	readonly: [
		"$",
		"$$",
		"By",
		"DartObject",
		"browser",
		"by",
		"element",
		"protractor"
	],
	writable: []
}, ENV_QUNIT = {
	readonly: [
		"QUnit",
		"asyncTest",
		"deepEqual",
		"equal",
		"expect",
		"module",
		"notDeepEqual",
		"notEqual",
		"notOk",
		"notPropEqual",
		"notStrictEqual",
		"ok",
		"propEqual",
		"raises",
		"start",
		"stop",
		"strictEqual",
		"test",
		"throws"
	],
	writable: []
}, ENV_SERVICEWORKER = {
	readonly: /* @__PURE__ */ "AI.AICreateMonitor.AbortController.AbortPaymentEvent.AbortSignal.AsyncDisposableStack.BackgroundFetchEvent.BackgroundFetchManager.BackgroundFetchRecord.BackgroundFetchRegistration.BackgroundFetchUpdateUIEvent.BarcodeDetector.Blob.BroadcastChannel.ByteLengthQueuingStrategy.CSSSkewX.CSSSkewY.Cache.CacheStorage.CanMakePaymentEvent.CanvasGradient.CanvasPattern.Client.Clients.CloseEvent.CompressionStream.CookieStore.CookieStoreManager.CountQueuingStrategy.CreateMonitor.CropTarget.Crypto.CryptoKey.CustomEvent.DOMException.DOMMatrix.DOMMatrixReadOnly.DOMPoint.DOMPointReadOnly.DOMQuad.DOMRect.DOMRectReadOnly.DOMStringList.DecompressionStream.DisposableStack.ErrorEvent.Event.EventSource.EventTarget.ExtendableCookieChangeEvent.ExtendableEvent.ExtendableMessageEvent.FetchEvent.File.FileList.FileReader.FileSystemDirectoryHandle.FileSystemFileHandle.FileSystemHandle.FileSystemWritableFileStream.FontFace.FontFaceSet.FontFaceSetLoadEvent.FormData.GPU.GPUAdapter.GPUAdapterInfo.GPUBindGroup.GPUBindGroupLayout.GPUBuffer.GPUBufferUsage.GPUCanvasContext.GPUColorWrite.GPUCommandBuffer.GPUCommandEncoder.GPUCompilationInfo.GPUCompilationMessage.GPUComputePassEncoder.GPUComputePipeline.GPUDevice.GPUDeviceLostInfo.GPUError.GPUExternalTexture.GPUInternalError.GPUMapMode.GPUOutOfMemoryError.GPUPipelineError.GPUPipelineLayout.GPUQuerySet.GPUQueue.GPURenderBundle.GPURenderBundleEncoder.GPURenderPassEncoder.GPURenderPipeline.GPUSampler.GPUShaderModule.GPUShaderStage.GPUSupportedFeatures.GPUSupportedLimits.GPUTexture.GPUTextureUsage.GPUTextureView.GPUUncapturedErrorEvent.GPUValidationError.Headers.IDBCursor.IDBCursorWithValue.IDBDatabase.IDBFactory.IDBIndex.IDBKeyRange.IDBObjectStore.IDBOpenDBRequest.IDBRecord.IDBRequest.IDBTransaction.IDBVersionChangeEvent.ImageBitmap.ImageBitmapRenderingContext.ImageData.InstallEvent.LanguageDetector.Lock.LockManager.MediaCapabilities.MessageChannel.MessageEvent.MessagePort.NavigationPreloadManager.NavigatorUAData.NetworkInformation.Notification.NotificationEvent.Observable.OffscreenCanvas.OffscreenCanvasRenderingContext2D.Path2D.PaymentRequestEvent.Performance.PerformanceEntry.PerformanceMark.PerformanceMeasure.PerformanceObserver.PerformanceObserverEntryList.PerformanceResourceTiming.PerformanceServerTiming.PeriodicSyncEvent.PeriodicSyncManager.PermissionStatus.Permissions.ProgressEvent.PromiseRejectionEvent.PushEvent.PushManager.PushMessageData.PushSubscription.PushSubscriptionChangeEvent.PushSubscriptionOptions.QuotaExceededError.ReadableByteStreamController.ReadableStream.ReadableStreamBYOBReader.ReadableStreamBYOBRequest.ReadableStreamDefaultController.ReadableStreamDefaultReader.ReportBody.ReportingObserver.Request.Response.RestrictionTarget.Scheduler.SecurityPolicyViolationEvent.ServiceWorker.ServiceWorkerContainer.ServiceWorkerGlobalScope.ServiceWorkerRegistration.StorageBucket.StorageBucketManager.StorageManager.Subscriber.SubtleCrypto.SuppressedError.SyncEvent.SyncManager.TaskController.TaskPriorityChangeEvent.TaskSignal.Temporal.TextDecoder.TextDecoderStream.TextEncoder.TextEncoderStream.TextMetrics.TransformStream.TransformStreamDefaultController.TrustedHTML.TrustedScript.TrustedScriptURL.TrustedTypePolicy.TrustedTypePolicyFactory.URL.URLPattern.URLSearchParams.UserActivation.WGSLLanguageFeatures.WebAssembly.WebGL2RenderingContext.WebGLActiveInfo.WebGLBuffer.WebGLContextEvent.WebGLFramebuffer.WebGLObject.WebGLProgram.WebGLQuery.WebGLRenderbuffer.WebGLRenderingContext.WebGLSampler.WebGLShader.WebGLShaderPrecisionFormat.WebGLSync.WebGLTexture.WebGLTransformFeedback.WebGLUniformLocation.WebGLVertexArrayObject.WebSocket.WebSocketError.WebSocketStream.WebTransport.WebTransportBidirectionalStream.WebTransportDatagramDuplexStream.WebTransportError.WebTransportReceiveStream.WebTransportSendStream.WindowClient.WorkerGlobalScope.WorkerLocation.WorkerNavigator.WritableStream.WritableStreamDefaultController.WritableStreamDefaultWriter.addEventListener.ai.atob.btoa.caches.clearInterval.clearTimeout.clients.console.cookieStore.createImageBitmap.crossOriginIsolated.crypto.dispatchEvent.fetch.fonts.importScripts.indexedDB.isSecureContext.location.navigator.origin.performance.queueMicrotask.registration.removeEventListener.reportError.scheduler.self.serviceWorker.setInterval.setTimeout.skipWaiting.structuredClone.trustedTypes.when".split("."),
	writable: [
		"onabortpayment",
		"onactivate",
		"onbackgroundfetchabort",
		"onbackgroundfetchclick",
		"onbackgroundfetchfail",
		"onbackgroundfetchsuccess",
		"oncanmakepayment",
		"oncookiechange",
		"onerror",
		"onfetch",
		"oninstall",
		"onlanguagechange",
		"onmessage",
		"onmessageerror",
		"onnotificationclick",
		"onnotificationclose",
		"onoffline",
		"ononline",
		"onpaymentrequest",
		"onperiodicsync",
		"onpush",
		"onpushsubscriptionchange",
		"onrejectionhandled",
		"onsync",
		"onunhandledrejection"
	]
}, ENV_SHARED_NODE_BROWSER = {
	readonly: /* @__PURE__ */ "AbortController.AbortSignal.AsyncDisposableStack.Blob.BroadcastChannel.ByteLengthQueuingStrategy.CloseEvent.CompressionStream.CountQueuingStrategy.Crypto.CryptoKey.CustomEvent.DOMException.DecompressionStream.DisposableStack.ErrorEvent.Event.EventTarget.File.FormData.Headers.MessageChannel.MessageEvent.MessagePort.Navigator.Performance.PerformanceEntry.PerformanceMark.PerformanceMeasure.PerformanceObserver.PerformanceObserverEntryList.PerformanceResourceTiming.ReadableByteStreamController.ReadableStream.ReadableStreamBYOBReader.ReadableStreamBYOBRequest.ReadableStreamDefaultController.ReadableStreamDefaultReader.Request.Response.Storage.SubtleCrypto.SuppressedError.TextDecoder.TextDecoderStream.TextEncoder.TextEncoderStream.TransformStream.TransformStreamDefaultController.URL.URLPattern.URLSearchParams.WebAssembly.WebSocket.WritableStream.WritableStreamDefaultController.WritableStreamDefaultWriter.atob.btoa.clearInterval.clearTimeout.console.crypto.fetch.localStorage.navigator.performance.queueMicrotask.sessionStorage.setInterval.setTimeout.structuredClone".split("."),
	writable: []
}, ENV_SHELLJS = {
	readonly: /* @__PURE__ */ "ShellString.cat.cd.chmod.cmd.config.cp.dirs.echo.env.error.errorCode.exec.exit.find.grep.head.ln.ls.mkdir.mv.popd.pushd.pwd.rm.sed.set.sort.tail.tempdir.test.touch.uniq.which".split("."),
	writable: []
}, ENV_SVELTE = {
	readonly: [
		"$bindable",
		"$derived",
		"$effect",
		"$host",
		"$inspect",
		"$props",
		"$state"
	],
	writable: []
}, ENV_VITEST = {
	readonly: [
		"afterAll",
		"afterEach",
		"assert",
		"assertType",
		"beforeAll",
		"beforeEach",
		"chai",
		"describe",
		"expect",
		"expectTypeOf",
		"it",
		"onTestFailed",
		"onTestFinished",
		"suite",
		"test",
		"vi",
		"vitest"
	],
	writable: []
}, ENV_VUE = {
	readonly: [
		"defineEmits",
		"defineExpose",
		"defineModel",
		"defineOptions",
		"defineProps",
		"defineSlots",
		"withDefaults"
	],
	writable: []
}, ENV_WEBEXTENSIONS = {
	readonly: [
		"browser",
		"chrome",
		"opr"
	],
	writable: []
}, ENV_WORKER = {
	readonly: /* @__PURE__ */ "AI.AICreateMonitor.AbortController.AbortSignal.AsyncDisposableStack.AudioData.AudioDecoder.AudioEncoder.BackgroundFetchManager.BackgroundFetchRecord.BackgroundFetchRegistration.BarcodeDetector.Blob.BroadcastChannel.ByteLengthQueuingStrategy.CSSSkewX.CSSSkewY.Cache.CacheStorage.CanvasGradient.CanvasPattern.CloseEvent.CompressionStream.CountQueuingStrategy.CreateMonitor.CropTarget.Crypto.CryptoKey.CustomEvent.DOMException.DOMMatrix.DOMMatrixReadOnly.DOMPoint.DOMPointReadOnly.DOMQuad.DOMRect.DOMRectReadOnly.DOMStringList.DecompressionStream.DedicatedWorkerGlobalScope.DisposableStack.EncodedAudioChunk.EncodedVideoChunk.ErrorEvent.Event.EventSource.EventTarget.File.FileList.FileReader.FileReaderSync.FileSystemDirectoryHandle.FileSystemFileHandle.FileSystemHandle.FileSystemObserver.FileSystemSyncAccessHandle.FileSystemWritableFileStream.FontFace.FontFaceSet.FontFaceSetLoadEvent.FormData.GPU.GPUAdapter.GPUAdapterInfo.GPUBindGroup.GPUBindGroupLayout.GPUBuffer.GPUBufferUsage.GPUCanvasContext.GPUColorWrite.GPUCommandBuffer.GPUCommandEncoder.GPUCompilationInfo.GPUCompilationMessage.GPUComputePassEncoder.GPUComputePipeline.GPUDevice.GPUDeviceLostInfo.GPUError.GPUExternalTexture.GPUInternalError.GPUMapMode.GPUOutOfMemoryError.GPUPipelineError.GPUPipelineLayout.GPUQuerySet.GPUQueue.GPURenderBundle.GPURenderBundleEncoder.GPURenderPassEncoder.GPURenderPipeline.GPUSampler.GPUShaderModule.GPUShaderStage.GPUSupportedFeatures.GPUSupportedLimits.GPUTexture.GPUTextureUsage.GPUTextureView.GPUUncapturedErrorEvent.GPUValidationError.HID.HIDConnectionEvent.HIDDevice.HIDInputReportEvent.Headers.IDBCursor.IDBCursorWithValue.IDBDatabase.IDBFactory.IDBIndex.IDBKeyRange.IDBObjectStore.IDBOpenDBRequest.IDBRecord.IDBRequest.IDBTransaction.IDBVersionChangeEvent.IdleDetector.ImageBitmap.ImageBitmapRenderingContext.ImageData.ImageDecoder.ImageTrack.ImageTrackList.LanguageDetector.Lock.LockManager.MediaCapabilities.MediaSource.MediaSourceHandle.MessageChannel.MessageEvent.MessagePort.NavigationPreloadManager.NavigatorUAData.NetworkInformation.Notification.Observable.OffscreenCanvas.OffscreenCanvasRenderingContext2D.PERSISTENT.Path2D.Performance.PerformanceEntry.PerformanceMark.PerformanceMeasure.PerformanceObserver.PerformanceObserverEntryList.PerformanceResourceTiming.PerformanceServerTiming.PeriodicSyncManager.PermissionStatus.Permissions.PressureObserver.PressureRecord.ProgressEvent.PromiseRejectionEvent.PushManager.PushSubscription.PushSubscriptionOptions.QuotaExceededError.RTCDataChannel.RTCEncodedAudioFrame.RTCEncodedVideoFrame.RTCRtpScriptTransformer.RTCTransformEvent.ReadableByteStreamController.ReadableStream.ReadableStreamBYOBReader.ReadableStreamBYOBRequest.ReadableStreamDefaultController.ReadableStreamDefaultReader.ReportBody.ReportingObserver.Request.Response.RestrictionTarget.Scheduler.SecurityPolicyViolationEvent.Serial.SerialPort.ServiceWorker.ServiceWorkerContainer.ServiceWorkerRegistration.SourceBuffer.SourceBufferList.StorageBucket.StorageBucketManager.StorageManager.Subscriber.SubtleCrypto.SuppressedError.SyncManager.TEMPORARY.TaskController.TaskPriorityChangeEvent.TaskSignal.Temporal.TextDecoder.TextDecoderStream.TextEncoder.TextEncoderStream.TextMetrics.TransformStream.TransformStreamDefaultController.TrustedHTML.TrustedScript.TrustedScriptURL.TrustedTypePolicy.TrustedTypePolicyFactory.URL.URLPattern.URLSearchParams.USB.USBAlternateInterface.USBConfiguration.USBConnectionEvent.USBDevice.USBEndpoint.USBInTransferResult.USBInterface.USBIsochronousInTransferPacket.USBIsochronousInTransferResult.USBIsochronousOutTransferPacket.USBIsochronousOutTransferResult.USBOutTransferResult.UserActivation.VideoColorSpace.VideoDecoder.VideoEncoder.VideoFrame.WGSLLanguageFeatures.WebAssembly.WebGL2RenderingContext.WebGLActiveInfo.WebGLBuffer.WebGLContextEvent.WebGLFramebuffer.WebGLObject.WebGLProgram.WebGLQuery.WebGLRenderbuffer.WebGLRenderingContext.WebGLSampler.WebGLShader.WebGLShaderPrecisionFormat.WebGLSync.WebGLTexture.WebGLTransformFeedback.WebGLUniformLocation.WebGLVertexArrayObject.WebSocket.WebSocketError.WebSocketStream.WebTransport.WebTransportBidirectionalStream.WebTransportDatagramDuplexStream.WebTransportError.WebTransportReceiveStream.WebTransportSendStream.Worker.WorkerGlobalScope.WorkerLocation.WorkerNavigator.WritableStream.WritableStreamDefaultController.WritableStreamDefaultWriter.XMLHttpRequest.XMLHttpRequestEventTarget.XMLHttpRequestUpload.addEventListener.ai.atob.btoa.caches.cancelAnimationFrame.clearInterval.clearTimeout.close.console.createImageBitmap.crossOriginIsolated.crypto.dispatchEvent.fetch.fonts.importScripts.indexedDB.isSecureContext.location.name.navigator.origin.performance.postMessage.queueMicrotask.removeEventListener.reportError.requestAnimationFrame.scheduler.self.setInterval.setTimeout.structuredClone.trustedTypes.webkitRequestFileSystem.webkitRequestFileSystemSync.webkitResolveLocalFileSystemSyncURL.webkitResolveLocalFileSystemURL.when".split("."),
	writable: [
		"onerror",
		"onlanguagechange",
		"onmessage",
		"onmessageerror",
		"onoffline",
		"ononline",
		"onrejectionhandled",
		"onrtctransform",
		"onunhandledrejection"
	]
}, ENVS = new Map([
	["amd", ENV_AMD],
	["applescript", ENV_APPLESCRIPT],
	["astro", ENV_ASTRO],
	["atomtest", ENV_ATOMTEST],
	["audioworklet", ENV_AUDIOWORKLET],
	["browser", ENV_BROWSER],
	["builtin", ENV_BUILTIN],
	["commonjs", ENV_COMMONJS],
	["embertest", ENV_EMBERTEST],
	["es2015", ENV_ES_2015],
	["es2016", ENV_ES_2016],
	["es2017", ENV_ES_2017],
	["es2018", ENV_ES_2018],
	["es2019", ENV_ES_2019],
	["es2020", ENV_ES_2020],
	["es2021", ENV_ES_2021],
	["es2022", ENV_ES_2022],
	["es2023", ENV_ES_2023],
	["es2024", ENV_ES_2024],
	["es2025", ENV_ES_2025],
	["es2026", ENV_ES_2026],
	["es6", ENV_ES_6],
	["greasemonkey", ENV_GREASEMONKEY],
	["jasmine", ENV_JASMINE],
	["jest", ENV_JEST],
	["jquery", ENV_JQUERY],
	["meteor", ENV_METEOR],
	["mocha", ENV_MOCHA],
	["mongo", ENV_MONGO],
	["nashorn", ENV_NASHORN],
	["node", ENV_NODE],
	["phantomjs", ENV_PHANTOMJS],
	["prototypejs", ENV_PROTOTYPEJS],
	["protractor", ENV_PROTRACTOR],
	["qunit", ENV_QUNIT],
	["serviceworker", ENV_SERVICEWORKER],
	["shared-node-browser", ENV_SHARED_NODE_BROWSER],
	["shelljs", ENV_SHELLJS],
	["svelte", ENV_SVELTE],
	["vitest", ENV_VITEST],
	["vue", ENV_VUE],
	["webextensions", ENV_WEBEXTENSIONS],
	["worker", ENV_WORKER]
]);
var import_dist = require_dist();
let tsScopeManager = null;
const analyzeOptions = {
	childVisitorKeys: void 0,
	globalReturn: !1,
	impliedStrict: !1,
	jsxPragma: "React",
	jsxFragmentName: null,
	lib: [],
	sourceType: "module",
	emitDecoratorMetadata: !1
};
function initTsScopeManager() {
	ast === null && initAst();
	let { sourceType } = ast;
	analyzeOptions.sourceType = sourceType, analyzeOptions.globalReturn = sourceType === "commonjs", analyzeOptions.impliedStrict = sourceType === "module", tsScopeManager = (0, import_dist.analyze)(ast, analyzeOptions), fixCatchClauseDefinitions(), addGlobals();
}
function fixCatchClauseDefinitions() {
	let { scopes } = tsScopeManager;
	for (let scopeIndex = 0; scopeIndex < scopes.length; scopeIndex++) {
		let scope = scopes[scopeIndex];
		if (scope.type !== "catch") continue;
		let { param } = scope.block;
		if (param === null || param.type === "Identifier") continue;
		let { variables } = scope;
		for (let varIndex = 0; varIndex < variables.length; varIndex++) {
			let variable = variables[varIndex];
			variable.defs[0].name = variable.identifiers[0];
		}
	}
}
function addGlobals() {
	let globalScope = tsScopeManager.scopes[0];
	for (let envName in globals === null && initGlobals(), envs) {
		let preset = ENVS.get(envName);
		if (preset === void 0) continue;
		let { readonly, writable } = preset;
		for (let i = 0, len = readonly.length; i < len; i++) {
			let varName = readonly[i];
			ObjectHasOwn(globals, varName) || createGlobalVariable(varName, globalScope, !1);
		}
		for (let i = 0, len = writable.length; i < len; i++) {
			let varName = writable[i];
			ObjectHasOwn(globals, varName) || createGlobalVariable(varName, globalScope, !0);
		}
	}
	for (let name in globals) {
		let value = globals[name];
		value !== "off" && createGlobalVariable(name, globalScope, value === "writable");
	}
	globalScope.through = globalScope.through.filter((ref) => {
		let { name } = ref.identifier, variable = globalScope.set.get(name);
		return variable ? (ref.resolved = variable, variable.references.push(ref), !1) : !0;
	});
	let { implicit } = globalScope;
	implicit.variables = implicit.variables.filter((variable) => {
		let { name } = variable;
		return globalScope.set.has(name) ? (implicit.set.delete(name), !1) : !0;
	}), implicit.leftToBeResolved = implicit.leftToBeResolved.filter((ref) => !globalScope.set.has(ref.identifier.name));
}
function createGlobalVariable(name, globalScope, isWritable) {
	let variable = globalScope.set.get(name);
	variable === void 0 && (variable = new import_dist.Variable(name, globalScope), globalScope.set.set(name, variable), globalScope.variables.push(variable)), variable.writeable = isWritable, variable.eslintImplicitGlobalSetting = isWritable ? "writable" : "readonly", variable.eslintExplicitGlobal = !1, variable.eslintExplicitGlobalComments = void 0;
}
function resetScopeManager() {
	tsScopeManager = null;
}
const SCOPE_MANAGER = ObjectFreeze({
	get scopes() {
		return tsScopeManager === null && initTsScopeManager(), tsScopeManager.scopes;
	},
	get globalScope() {
		return tsScopeManager === null && initTsScopeManager(), tsScopeManager.globalScope;
	},
	getDeclaredVariables(node) {
		return tsScopeManager === null && initTsScopeManager(), tsScopeManager.getDeclaredVariables(node);
	},
	acquire(node, inner) {
		return tsScopeManager === null && initTsScopeManager(), tsScopeManager.acquire(node, inner);
	}
});
function isGlobalReference(node) {
	if (!node) throw TypeError("Missing required argument: `node`");
	if (node.type !== "Identifier") return !1;
	tsScopeManager === null && initTsScopeManager();
	let { scopes } = tsScopeManager;
	if (scopes.length === 0) return !1;
	let variable = scopes[0].set.get(node.name);
	if (variable === void 0 || variable.defs.length > 0) return !1;
	let { references } = variable;
	for (let i = 0, len = references.length; i < len; i++) if (references[i].identifier === node) return !0;
	return !1;
}
function getDeclaredVariables(node) {
	return tsScopeManager === null && initTsScopeManager(), tsScopeManager.getDeclaredVariables(node);
}
function getScope(node) {
	if (!node) throw TypeError("Missing required argument: `node`");
	tsScopeManager === null && initTsScopeManager();
	let inner = node.type !== "Program";
	do {
		let scope = tsScopeManager.acquire(node, inner);
		if (scope !== null) return scope.type === "function-expression-name" ? scope.childScopes[0] : scope;
		node = node.parent;
	} while (node !== null);
	return tsScopeManager.scopes[0];
}
function markVariableAsUsed(name, refNode) {
	throw Error("`context.markVariableAsUsed` not implemented yet");
}
const textDecoder = new TextDecoder("utf-8", { ignoreBOM: !0 });
let buffer = null, hasBOM = !1, sourceText = null, sourceStartPos = 0, sourceByteLen = 0, ast = null, parserServices = null;
function setupSourceForFile(bufferInput, hasBOMInput, parserServicesInput) {
	buffer = bufferInput, hasBOM = hasBOMInput, parserServices = parserServicesInput;
}
function initSourceText() {
	let { uint32 } = buffer, programPos = uint32[DATA_POINTER_POS_32];
	sourceStartPos = uint32[programPos + 8 >> 2], sourceByteLen = uint32[programPos + 16 >> 2], sourceText = textDecoder.decode(buffer.subarray(sourceStartPos, sourceStartPos + sourceByteLen));
}
function initAst() {
	sourceText === null && initSourceText(), ast = deserializeProgramOnly(buffer, sourceText, sourceStartPos, sourceByteLen, getNodeLoc);
}
function resetSourceAndAst() {
	buffer = null, sourceText = null, ast = null, parserServices = null, resetBuffer(), resetLines(), resetScopeManager(), resetTokens();
}
function fileIsJsx() {
	return buffer[2147483613] === 1;
}
function fileIsTs() {
	return buffer[2147483612] === 1;
}
const SOURCE_CODE = ObjectFreeze({
	get text() {
		return sourceText === null && initSourceText(), sourceText;
	},
	get hasBOM() {
		return hasBOM;
	},
	get ast() {
		return ast === null && initAst(), ast;
	},
	isESTree: !0,
	get scopeManager() {
		return SCOPE_MANAGER;
	},
	get visitorKeys() {
		return keys_default;
	},
	get parserServices() {
		return parserServices;
	},
	get lines() {
		return lines.length === 0 && initLines(), lines;
	},
	get lineStartIndices() {
		return lines.length === 0 && initLines(), lineStartIndices;
	},
	get tokensAndComments() {
		return tokensAndComments === null && (tokens === null && (sourceText === null && initSourceText(), initTokens()), initTokensAndComments()), tokensAndComments;
	},
	getText(node, beforeCount, afterCount) {
		if (sourceText === null && initSourceText(), !node) return sourceText;
		let { range } = node, start = range[0], end = range[1];
		return beforeCount && (start = MathMax(start - beforeCount, 0)), afterCount && (end += afterCount), sourceText.slice(start, end);
	},
	getAncestors(node) {
		let ancestors = [];
		for (; node = node.parent, node !== null;) ancestors.push(node);
		return ancestors.reverse();
	},
	getLines() {
		return lines.length === 0 && initLines(), lines;
	},
	getRange,
	getLoc: getLoc$1,
	getNodeByRangeIndex,
	getLocFromIndex: getLineColumnFromOffset,
	getIndexFromLoc: getOffsetFromLineColumn$1,
	getAllComments,
	getCommentsBefore,
	getCommentsAfter,
	getCommentsInside,
	commentsExistBetween,
	getJSDocComment,
	isGlobalReference,
	getDeclaredVariables,
	getScope,
	markVariableAsUsed,
	getTokens,
	getFirstToken,
	getFirstTokens,
	getLastToken,
	getLastTokens,
	getTokenBefore,
	getTokenOrCommentBefore,
	getTokensBefore,
	getTokenAfter,
	getTokenOrCommentAfter,
	getTokensAfter,
	getTokensBetween,
	getFirstTokenBetween,
	getFirstTokensBetween,
	getLastTokenBetween,
	getLastTokensBetween,
	getTokenByRangeStart,
	isSpaceBetween,
	isSpaceBetweenTokens
}), FIXER = ObjectFreeze({
	insertTextBefore(nodeOrToken, text) {
		let start = nodeOrToken.range[0];
		return {
			range: [start, start],
			text
		};
	},
	insertTextBeforeRange(range, text) {
		let start = range[0];
		return {
			range: [start, start],
			text
		};
	},
	insertTextAfter(nodeOrToken, text) {
		let end = nodeOrToken.range[1];
		return {
			range: [end, end],
			text
		};
	},
	insertTextAfterRange(range, text) {
		let end = range[1];
		return {
			range: [end, end],
			text
		};
	},
	remove(nodeOrToken) {
		return {
			range: nodeOrToken.range,
			text: ""
		};
	},
	removeRange(range) {
		return {
			range,
			text: ""
		};
	},
	replaceText(nodeOrToken, text) {
		return {
			range: nodeOrToken.range,
			text
		};
	},
	replaceTextRange(range, text) {
		return {
			range,
			text
		};
	}
});
function getFixes(diagnostic, ruleDetails) {
	let { fix } = diagnostic;
	if (typeof fix != "function") return null;
	let fixes = fix.call(diagnostic, FIXER);
	if (!fixes) return null;
	if (SymbolIterator in fixes) {
		let isCloned = !1;
		(ObjectGetPrototypeOf(fixes) !== ArrayPrototype || ObjectHasOwn(fixes, "toJSON")) && (fixes = ArrayFrom(fixes), isCloned = !0);
		let fixesLen = fixes.length;
		if (fixesLen === 0) return null;
		for (let i = 0; i < fixesLen; i++) {
			let fix = fixes[i];
			if (!fix) {
				if (fixes = fixes.filter(Boolean), fixes.length === 0) return null;
				isCloned = !0, i--;
				continue;
			}
			let conformedFix = validateAndConformFix(fix);
			conformedFix !== fix && (isCloned === !1 && (fixes = fixes.slice(), isCloned = !0), fixes[i] = conformedFix);
		}
	} else fixes = [validateAndConformFix(fixes)];
	if (ruleDetails.isFixable === !1) throw Error("Fixable rules must set the `meta.fixable` property to \"code\" or \"whitespace\".");
	return fixes;
}
function validateAndConformFix(fix) {
	let { range, text } = fix;
	if (!range || typeof range[0] != "number" || typeof range[1] != "number") throw Error(`Fix has invalid range: ${JSONStringify(fix, null, 2)}`);
	let fixPrototype = ObjectGetPrototypeOf(fix);
	return (fixPrototype === ObjectPrototype || fixPrototype === null) && ReflectOwnKeys(fix).length === 2 && ObjectGetPrototypeOf(range) === ArrayPrototype && !ObjectHasOwn(range, "toJSON") && range.length === 2 && typeof text == "string" ? fix : {
		range: [range[0], range[1]],
		text: String(text)
	};
}
const diagnostics = [], PLACEHOLDER_REGEX = /\{\{([^{}]+)\}\}/gu;
function report(diagnostic, ruleDetails) {
	if (filePath === null) throw Error("Cannot report errors in `createOnce`");
	let { message, messageId } = getMessage(diagnostic, ruleDetails);
	if (ObjectHasOwn(diagnostic, "data")) {
		let { data } = diagnostic;
		data != null && (message = replacePlaceholders(message, data));
	}
	let start, end, loc;
	if (ObjectHasOwn(diagnostic, "loc") && (loc = diagnostic.loc) != null) {
		if (typeof loc != "object") throw TypeError("`loc` must be an object if provided");
		if (ObjectHasOwn(loc, "start")) {
			let { start: startLineCol, end: endLineCol } = loc;
			if (typeof startLineCol != "object" || !startLineCol) throw TypeError("`loc.start` must be an object");
			if (start = getOffsetFromLineColumn(startLineCol), endLineCol == null) end = start;
			else if (typeof endLineCol == "object") end = getOffsetFromLineColumn(endLineCol);
			else throw TypeError("`loc.end` must be an object or null/undefined");
		} else start = getOffsetFromLineColumn(loc), end = start;
	} else {
		let { node } = diagnostic;
		if (node == null) throw TypeError("Either `node` or `loc` is required");
		if (typeof node != "object") throw TypeError("`node` must be an object");
		let { range } = node;
		if (typeof range != "object" || !range) throw TypeError("`node.range` must be present");
		if (start = range[0], end = range[1], typeof start != "number" || typeof end != "number" || start < 0 || end < 0 || (start | 0) !== start || (end | 0) !== end) throw TypeError("`node.range[0]` and `node.range[1]` must be non-negative integers");
	}
	diagnostics.push({
		message,
		messageId,
		start,
		end,
		ruleIndex: ruleDetails.ruleIndex,
		fixes: getFixes(diagnostic, ruleDetails)
	});
}
function getMessage(diagnostic, ruleDetails) {
	if (ObjectHasOwn(diagnostic, "messageId")) {
		let { messageId } = diagnostic;
		if (messageId != null) return {
			message: resolveMessageFromMessageId(messageId, ruleDetails),
			messageId
		};
	}
	if (ObjectHasOwn(diagnostic, "message")) {
		let { message } = diagnostic;
		if (typeof message == "string") return {
			message,
			messageId: null
		};
		if (message != null) throw TypeError("`message` must be a string");
	}
	throw Error("Either `message` or `messageId` is required");
}
function resolveMessageFromMessageId(messageId, ruleDetails) {
	let { messages } = ruleDetails;
	if (messages === null) throw Error(`Cannot use messageId '${messageId}' - rule does not define any messages in \`meta.messages\``);
	if (!ObjectHasOwn(messages, messageId)) throw Error(`Unknown messageId '${messageId}'. Available \`messageIds\`: ${ObjectKeys(messages).map((msg) => `'${msg}'`).join(", ")}`);
	return messages[messageId];
}
function replacePlaceholders(message, data) {
	return message.replace(PLACEHOLDER_REGEX, (match, key) => {
		key = key.trim();
		let value = data[key];
		return value === void 0 ? match : value;
	});
}
function getOffsetFromLineColumn(lineCol) {
	let { line, column } = lineCol;
	if (typeof line != "number" || typeof column != "number" || (line | 0) !== line || (column | 0) !== column) throw TypeError("Expected an object with integer `line` and `column` properties");
	if (lines.length === 0 && initLines(), line <= 0 || line > lineStartIndices.length) {
		if (line === lineStartIndices.length + 1 && column === 0) return sourceText.length;
		throw RangeError(`Line number out of range (line ${line} requested). Line numbers should be 1-based, and less than or equal to number of lines in file (${lineStartIndices.length}).`);
	}
	let offset = lineStartIndices[line - 1] + column;
	if (offset < 0 || offset > sourceText.length) throw RangeError("Line/column pair translates to an out of range offset");
	return offset;
}
function deepFreezeJsonValue(value) {
	typeof value != "object" || !value || (ArrayIsArray(value) ? deepFreezeJsonArray(value) : deepFreezeJsonObject(value));
}
function deepFreezeJsonObject(obj) {
	for (let key in obj) deepFreezeJsonValue(obj[key]);
	ObjectFreeze(obj);
}
function deepFreezeJsonArray(arr) {
	for (let i = 0, len = arr.length; i !== len; i++) deepFreezeJsonValue(arr[i]);
	ObjectFreeze(arr);
}
function deepCloneJsonValue(value) {
	return typeof value != "object" || !value ? value : ArrayIsArray(value) ? deepCloneJsonArray(value) : deepCloneJsonObject(value);
}
function deepCloneJsonObject(obj) {
	let cloned = { ...obj };
	for (let key in cloned) {
		let value = cloned[key];
		typeof value != "object" || !value || (cloned[key] = ArrayIsArray(value) ? deepCloneJsonArray(value) : deepCloneJsonObject(value));
	}
	return cloned;
}
function deepCloneJsonArray(arr) {
	let cloned = [];
	for (let i = 0, len = arr.length; i !== len; i++) cloned.push(deepCloneJsonValue(arr[i]));
	return cloned;
}
let settingsJSON = null, settings = null;
function setSettingsForFile(settingsJSONInput) {
	settingsJSON = settingsJSONInput;
}
function initSettings() {
	settings = JSONParse(settingsJSON), deepFreezeJsonValue(settings);
}
function resetSettings() {
	settings = null, settingsJSON = null;
}
let cwd = null, filePath = null;
function setupFileContext(filePathInput) {
	filePath = filePathInput;
}
function resetFileContext() {
	filePath = null;
}
const SUPPORTED_ECMA_VERSIONS = ObjectFreeze([
	3,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	12,
	13,
	14,
	15,
	16,
	17
]);
let Syntax = null;
const PARSER = ObjectFreeze({
	name: "oxc",
	version: "0.0.0",
	parse(code, options) {
		throw Error("`context.languageOptions.parser.parse` not implemented yet.");
	},
	VisitorKeys: keys_default,
	get Syntax() {
		if (Syntax === null) {
			for (let key in Syntax = ObjectCreate(null), keys_default) Syntax[key] = key;
			ObjectFreeze(Syntax);
		}
		return Syntax;
	},
	latestEcmaVersion: 17,
	supportedEcmaVersions: SUPPORTED_ECMA_VERSIONS
}), PARSER_OPTIONS = ObjectFreeze({
	get sourceType() {
		return ast === null && initAst(), ast.sourceType;
	},
	ecmaFeatures: ObjectFreeze({
		get jsx() {
			return fileIsJsx();
		},
		get globalReturn() {
			return ast === null && initAst(), ast.sourceType === "commonjs";
		},
		get impliedStrict() {
			return ast === null && initAst(), ast.sourceType === "module";
		}
	})
}), LANGUAGE_OPTIONS = {
	get sourceType() {
		return ast === null && initAst(), ast.sourceType;
	},
	ecmaVersion: 2026,
	parser: PARSER,
	parserOptions: PARSER_OPTIONS,
	get globals() {
		return globals === null && initGlobals(), globals;
	},
	get env() {
		return envs === null && initGlobals(), envs;
	}
};
ObjectFreeze(LANGUAGE_OPTIONS);
const FILE_CONTEXT = ObjectFreeze({
	get filename() {
		if (filePath === null) throw Error("Cannot access `context.filename` in `createOnce`");
		return filePath;
	},
	getFilename() {
		if (filePath === null) throw Error("Cannot call `context.getFilename` in `createOnce`");
		return filePath;
	},
	get physicalFilename() {
		if (filePath === null) throw Error("Cannot access `context.physicalFilename` in `createOnce`");
		return filePath;
	},
	getPhysicalFilename() {
		if (filePath === null) throw Error("Cannot call `context.getPhysicalFilename` in `createOnce`");
		return filePath;
	},
	get cwd() {
		if (filePath === null) throw Error("Cannot access `context.cwd` in `createOnce`");
		return cwd === null && (cwd = process.cwd()), cwd;
	},
	getCwd() {
		if (filePath === null) throw Error("Cannot call `context.getCwd` in `createOnce`");
		return cwd === null && (cwd = process.cwd()), cwd;
	},
	get sourceCode() {
		if (filePath === null) throw Error("Cannot access `context.sourceCode` in `createOnce`");
		return SOURCE_CODE;
	},
	getSourceCode() {
		if (filePath === null) throw Error("Cannot call `context.getSourceCode` in `createOnce`");
		return SOURCE_CODE;
	},
	get languageOptions() {
		if (filePath === null) throw Error("Cannot access `context.languageOptions` in `createOnce`");
		return LANGUAGE_OPTIONS;
	},
	get settings() {
		if (filePath === null) throw Error("Cannot access `context.settings` in `createOnce`");
		return settings === null && initSettings(), settings;
	},
	extend(extension) {
		return ObjectFreeze(ObjectAssign(ObjectCreate(this), extension));
	},
	get parserOptions() {
		if (filePath === null) throw Error("Cannot access `context.parserOptions` in `createOnce`");
		return PARSER_OPTIONS;
	},
	get parserPath() {
		throw Error("`context.parserPath` is unsupported at present (and deprecated)");
	}
});
function createContext(ruleDetails) {
	return ObjectFreeze({
		__proto__: FILE_CONTEXT,
		get id() {
			if (filePath === null) throw Error("Cannot access `context.id` in `createOnce`");
			return ruleDetails.fullName;
		},
		get options() {
			if (filePath === null) throw Error("Cannot access `context.options` in `createOnce`");
			return ruleDetails.options;
		},
		report(diagnostic) {
			report(diagnostic, ruleDetails);
		}
	});
}
var require_uri_all = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
	(function(global, factory) {
		typeof exports == "object" && module !== void 0 ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : factory(global.URI = global.URI || {});
	})(exports, (function(exports$1) {
		function merge() {
			var sets = [...arguments];
			if (sets.length > 1) {
				sets[0] = sets[0].slice(0, -1);
				for (var xl = sets.length - 1, x = 1; x < xl; ++x) sets[x] = sets[x].slice(1, -1);
				return sets[xl] = sets[xl].slice(1), sets.join("");
			} else return sets[0];
		}
		function subexp(str) {
			return "(?:" + str + ")";
		}
		function typeOf(o) {
			return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
		}
		function toUpperCase(str) {
			return str.toUpperCase();
		}
		function toArray(obj) {
			return obj == null ? [] : obj instanceof Array ? obj : typeof obj.length != "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj);
		}
		function assign(target, source) {
			var obj = target;
			if (source) for (var key in source) obj[key] = source[key];
			return obj;
		}
		function buildExps(isIRI) {
			var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
			subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$);
			var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS$ = subexp([
				subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
				subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
				subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
				subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
				subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
				subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
				subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
				subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
				subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:")
			].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
			subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$);
			var IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")";
			subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$);
			var QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE$ = subexp(subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$) + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?");
			return subexp(URI$ + "|" + RELATIVE$), subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), "" + SCHEME$ + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + subexp("\\#(" + FRAGMENT$ + ")"), "" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + subexp("\\#(" + FRAGMENT$ + ")"), "" + SCHEME$ + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")"), "" + subexp("\\#(" + FRAGMENT$ + ")"), "" + subexp("(" + USERINFO$ + ")@") + HOST$ + subexp("\\:(" + PORT$ + ")"), {
				NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
				NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
				NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
				NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
				NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
				NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
				NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
				ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
				UNRESERVED: new RegExp(UNRESERVED$$, "g"),
				OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
				PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
				IPV4ADDRESS: RegExp("^(" + IPV4ADDRESS$ + ")$"),
				IPV6ADDRESS: RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
			};
		}
		var URI_PROTOCOL = buildExps(!1), IRI_PROTOCOL = buildExps(!0), slicedToArray = function() {
			function sliceIterator(arr, i) {
				var _arr = [], _n = !0, _d = !1, _e = void 0;
				try {
					for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0);
				} catch (err) {
					_d = !0, _e = err;
				} finally {
					try {
						!_n && _i.return && _i.return();
					} finally {
						if (_d) throw _e;
					}
				}
				return _arr;
			}
			return function(arr, i) {
				if (Array.isArray(arr)) return arr;
				if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
				throw TypeError("Invalid attempt to destructure non-iterable instance");
			};
		}(), toConsumableArray = function(arr) {
			if (Array.isArray(arr)) {
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2;
			} else return Array.from(arr);
		}, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\0-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
			overflow: "Overflow: input needs wider integers to process",
			"not-basic": "Illegal input >= 0x80 (not a basic code point)",
			"invalid-input": "Invalid input"
		}, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode;
		function error$1(type) {
			throw RangeError(errors[type]);
		}
		function map(array, fn) {
			for (var result = [], length = array.length; length--;) result[length] = fn(array[length]);
			return result;
		}
		function mapDomain(string, fn) {
			var parts = string.split("@"), result = "";
			parts.length > 1 && (result = parts[0] + "@", string = parts[1]), string = string.replace(regexSeparators, ".");
			var encoded = map(string.split("."), fn).join(".");
			return result + encoded;
		}
		function ucs2decode(string) {
			for (var output = [], counter = 0, length = string.length; counter < length;) {
				var value = string.charCodeAt(counter++);
				if (value >= 55296 && value <= 56319 && counter < length) {
					var extra = string.charCodeAt(counter++);
					(extra & 64512) == 56320 ? output.push(((value & 1023) << 10) + (extra & 1023) + 65536) : (output.push(value), counter--);
				} else output.push(value);
			}
			return output;
		}
		var ucs2encode = function ucs2encode(array) {
			return String.fromCodePoint.apply(String, toConsumableArray(array));
		}, basicToDigit = function basicToDigit(codePoint) {
			return codePoint - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : base;
		}, digitToBasic = function digitToBasic(digit, flag) {
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}, adapt = function adapt(delta, numPoints, firstTime) {
			var k = 0;
			for (delta = firstTime ? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints); delta > baseMinusTMin * tMax >> 1; k += base) delta = floor(delta / baseMinusTMin);
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}, decode = function decode(input) {
			var output = [], inputLength = input.length, i = 0, n = initialN, bias = initialBias, basic = input.lastIndexOf(delimiter);
			basic < 0 && (basic = 0);
			for (var j = 0; j < basic; ++j) input.charCodeAt(j) >= 128 && error$1("not-basic"), output.push(input.charCodeAt(j));
			for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
				for (var oldi = i, w = 1, k = base;; k += base) {
					index >= inputLength && error$1("invalid-input");
					var digit = basicToDigit(input.charCodeAt(index++));
					(digit >= base || digit > floor((maxInt - i) / w)) && error$1("overflow"), i += digit * w;
					var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
					if (digit < t) break;
					var baseMinusT = base - t;
					w > floor(maxInt / baseMinusT) && error$1("overflow"), w *= baseMinusT;
				}
				var out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0), floor(i / out) > maxInt - n && error$1("overflow"), n += floor(i / out), i %= out, output.splice(i++, 0, n);
			}
			return String.fromCodePoint.apply(String, output);
		}, encode = function encode(input) {
			var output = [];
			input = ucs2decode(input);
			var inputLength = input.length, n = initialN, delta = 0, bias = initialBias, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
			try {
				for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
					var _currentValue2 = _step.value;
					_currentValue2 < 128 && output.push(stringFromCharCode(_currentValue2));
				}
			} catch (err) {
				_didIteratorError = !0, _iteratorError = err;
			} finally {
				try {
					!_iteratorNormalCompletion && _iterator.return && _iterator.return();
				} finally {
					if (_didIteratorError) throw _iteratorError;
				}
			}
			var basicLength = output.length, handledCPCount = basicLength;
			for (basicLength && output.push(delimiter); handledCPCount < inputLength;) {
				var m = maxInt, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
				try {
					for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
						var currentValue = _step2.value;
						currentValue >= n && currentValue < m && (m = currentValue);
					}
				} catch (err) {
					_didIteratorError2 = !0, _iteratorError2 = err;
				} finally {
					try {
						!_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return();
					} finally {
						if (_didIteratorError2) throw _iteratorError2;
					}
				}
				var handledCPCountPlusOne = handledCPCount + 1;
				m - n > floor((maxInt - delta) / handledCPCountPlusOne) && error$1("overflow"), delta += (m - n) * handledCPCountPlusOne, n = m;
				var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
				try {
					for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
						var _currentValue = _step3.value;
						if (_currentValue < n && ++delta > maxInt && error$1("overflow"), _currentValue == n) {
							for (var q = delta, k = base;; k += base) {
								var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
								if (q < t) break;
								var qMinusT = q - t, baseMinusT = base - t;
								output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);
							}
							output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), delta = 0, ++handledCPCount;
						}
					}
				} catch (err) {
					_didIteratorError3 = !0, _iteratorError3 = err;
				} finally {
					try {
						!_iteratorNormalCompletion3 && _iterator3.return && _iterator3.return();
					} finally {
						if (_didIteratorError3) throw _iteratorError3;
					}
				}
				++delta, ++n;
			}
			return output.join("");
		}, punycode = {
			version: "2.1.0",
			ucs2: {
				decode: ucs2decode,
				encode: ucs2encode
			},
			decode,
			encode,
			toASCII: function toASCII(input) {
				return mapDomain(input, function(string) {
					return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
				});
			},
			toUnicode: function toUnicode(input) {
				return mapDomain(input, function(string) {
					return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
				});
			}
		}, SCHEMES = {};
		function pctEncChar(chr) {
			var c = chr.charCodeAt(0), e = void 0;
			return e = c < 16 ? "%0" + c.toString(16).toUpperCase() : c < 128 ? "%" + c.toString(16).toUpperCase() : c < 2048 ? "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase() : "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase(), e;
		}
		function pctDecChars(str) {
			for (var newStr = "", i = 0, il = str.length; i < il;) {
				var c = parseInt(str.substr(i + 1, 2), 16);
				if (c < 128) newStr += String.fromCharCode(c), i += 3;
				else if (c >= 194 && c < 224) {
					if (il - i >= 6) {
						var c2 = parseInt(str.substr(i + 4, 2), 16);
						newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
					} else newStr += str.substr(i, 6);
					i += 6;
				} else if (c >= 224) {
					if (il - i >= 9) {
						var _c = parseInt(str.substr(i + 4, 2), 16), c3 = parseInt(str.substr(i + 7, 2), 16);
						newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
					} else newStr += str.substr(i, 9);
					i += 9;
				} else newStr += str.substr(i, 3), i += 3;
			}
			return newStr;
		}
		function _normalizeComponentEncoding(components, protocol) {
			function decodeUnreserved(str) {
				var decStr = pctDecChars(str);
				return decStr.match(protocol.UNRESERVED) ? decStr : str;
			}
			return components.scheme &&= String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, ""), components.userinfo !== void 0 && (components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), components.host !== void 0 && (components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), components.path !== void 0 && (components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), components.query !== void 0 && (components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), components.fragment !== void 0 && (components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), components;
		}
		function _stripLeadingZeros(str) {
			return str.replace(/^0*(.*)/, "$1") || "0";
		}
		function _normalizeIPv4(host, protocol) {
			var address = slicedToArray(host.match(protocol.IPV4ADDRESS) || [], 2)[1];
			return address ? address.split(".").map(_stripLeadingZeros).join(".") : host;
		}
		function _normalizeIPv6(host, protocol) {
			var _matches2 = slicedToArray(host.match(protocol.IPV6ADDRESS) || [], 3), address = _matches2[1], zone = _matches2[2];
			if (address) {
				for (var _address$toLowerCase$2 = slicedToArray(address.toLowerCase().split("::").reverse(), 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1], firstFields = first ? first.split(":").map(_stripLeadingZeros) : [], lastFields = last.split(":").map(_stripLeadingZeros), isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]), fieldCount = isLastFieldIPv4Address ? 7 : 8, lastFieldsStart = lastFields.length - fieldCount, fields = Array(fieldCount), x = 0; x < fieldCount; ++x) fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
				isLastFieldIPv4Address && (fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol));
				var longestZeroFields = fields.reduce(function(acc, field, index) {
					if (!field || field === "0") {
						var lastLongest = acc[acc.length - 1];
						lastLongest && lastLongest.index + lastLongest.length === index ? lastLongest.length++ : acc.push({
							index,
							length: 1
						});
					}
					return acc;
				}, []).sort(function(a, b) {
					return b.length - a.length;
				})[0], newHost = void 0;
				if (longestZeroFields && longestZeroFields.length > 1) {
					var newFirst = fields.slice(0, longestZeroFields.index), newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
					newHost = newFirst.join(":") + "::" + newLast.join(":");
				} else newHost = fields.join(":");
				return zone && (newHost += "%" + zone), newHost;
			} else return host;
		}
		var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
		function parse(uriString) {
			var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, components = {}, protocol = options.iri === !1 ? URI_PROTOCOL : IRI_PROTOCOL;
			options.reference === "suffix" && (uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString);
			var matches = uriString.match(URI_PARSE);
			if (matches) {
				NO_MATCH_IS_UNDEFINED ? (components.scheme = matches[1], components.userinfo = matches[3], components.host = matches[4], components.port = parseInt(matches[5], 10), components.path = matches[6] || "", components.query = matches[7], components.fragment = matches[8], isNaN(components.port) && (components.port = matches[5])) : (components.scheme = matches[1] || void 0, components.userinfo = uriString.indexOf("@") === -1 ? void 0 : matches[3], components.host = uriString.indexOf("//") === -1 ? void 0 : matches[4], components.port = parseInt(matches[5], 10), components.path = matches[6] || "", components.query = uriString.indexOf("?") === -1 ? void 0 : matches[7], components.fragment = uriString.indexOf("#") === -1 ? void 0 : matches[8], isNaN(components.port) && (components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0)), components.host &&= _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol), components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0 ? components.reference = "same-document" : components.scheme === void 0 ? components.reference = "relative" : components.fragment === void 0 ? components.reference = "absolute" : components.reference = "uri", options.reference && options.reference !== "suffix" && options.reference !== components.reference && (components.error = components.error || "URI is not a " + options.reference + " reference.");
				var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
				if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
					if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) try {
						components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
					} catch (e) {
						components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
					}
					_normalizeComponentEncoding(components, URI_PROTOCOL);
				} else _normalizeComponentEncoding(components, protocol);
				schemeHandler && schemeHandler.parse && schemeHandler.parse(components, options);
			} else components.error = components.error || "URI can not be parsed.";
			return components;
		}
		function _recomposeAuthority(components, options) {
			var protocol = options.iri === !1 ? URI_PROTOCOL : IRI_PROTOCOL, uriTokens = [];
			return components.userinfo !== void 0 && (uriTokens.push(components.userinfo), uriTokens.push("@")), components.host !== void 0 && uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
				return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
			})), (typeof components.port == "number" || typeof components.port == "string") && (uriTokens.push(":"), uriTokens.push(String(components.port))), uriTokens.length ? uriTokens.join("") : void 0;
		}
		var RDS1 = /^\.\.?\//, RDS2 = /^\/\.(\/|$)/, RDS3 = /^\/\.\.(\/|$)/, RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
		function removeDotSegments(input) {
			for (var output = []; input.length;) if (input.match(RDS1)) input = input.replace(RDS1, "");
			else if (input.match(RDS2)) input = input.replace(RDS2, "/");
			else if (input.match(RDS3)) input = input.replace(RDS3, "/"), output.pop();
			else if (input === "." || input === "..") input = "";
			else {
				var im = input.match(RDS5);
				if (im) {
					var s = im[0];
					input = input.slice(s.length), output.push(s);
				} else throw Error("Unexpected dot segment condition");
			}
			return output.join("");
		}
		function serialize(components) {
			var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL, uriTokens = [], schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
			if (schemeHandler && schemeHandler.serialize && schemeHandler.serialize(components, options), components.host && !protocol.IPV6ADDRESS.test(components.host) && (options.domainHost || schemeHandler && schemeHandler.domainHost)) try {
				components.host = options.iri ? punycode.toUnicode(components.host) : punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
			} catch (e) {
				components.error = components.error || "Host's domain name can not be converted to " + (options.iri ? "Unicode" : "ASCII") + " via punycode: " + e;
			}
			_normalizeComponentEncoding(components, protocol), options.reference !== "suffix" && components.scheme && (uriTokens.push(components.scheme), uriTokens.push(":"));
			var authority = _recomposeAuthority(components, options);
			if (authority !== void 0 && (options.reference !== "suffix" && uriTokens.push("//"), uriTokens.push(authority), components.path && components.path.charAt(0) !== "/" && uriTokens.push("/")), components.path !== void 0) {
				var s = components.path;
				!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath) && (s = removeDotSegments(s)), authority === void 0 && (s = s.replace(/^\/\//, "/%2F")), uriTokens.push(s);
			}
			return components.query !== void 0 && (uriTokens.push("?"), uriTokens.push(components.query)), components.fragment !== void 0 && (uriTokens.push("#"), uriTokens.push(components.fragment)), uriTokens.join("");
		}
		function resolveComponents(base, relative) {
			var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, skipNormalization = arguments[3], target = {};
			return skipNormalization || (base = parse(serialize(base, options), options), relative = parse(serialize(relative, options), options)), options ||= {}, !options.tolerant && relative.scheme ? (target.scheme = relative.scheme, target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0 ? (target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.path ? (relative.path.charAt(0) === "/" ? target.path = removeDotSegments(relative.path) : ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path ? target.path = "/" + relative.path : base.path ? target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : target.path = relative.path, target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, relative.query === void 0 ? target.query = base.query : target.query = relative.query), target.userinfo = base.userinfo, target.host = base.host, target.port = base.port), target.scheme = base.scheme), target.fragment = relative.fragment, target;
		}
		function resolve(baseURI, relativeURI, options) {
			var schemelessOptions = assign({ scheme: "null" }, options);
			return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, !0), schemelessOptions);
		}
		function normalize(uri, options) {
			return typeof uri == "string" ? uri = serialize(parse(uri, options), options) : typeOf(uri) === "object" && (uri = parse(serialize(uri, options), options)), uri;
		}
		function equal(uriA, uriB, options) {
			return typeof uriA == "string" ? uriA = serialize(parse(uriA, options), options) : typeOf(uriA) === "object" && (uriA = serialize(uriA, options)), typeof uriB == "string" ? uriB = serialize(parse(uriB, options), options) : typeOf(uriB) === "object" && (uriB = serialize(uriB, options)), uriA === uriB;
		}
		function escapeComponent(str, options) {
			return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
		}
		function unescapeComponent(str, options) {
			return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
		}
		var handler = {
			scheme: "http",
			domainHost: !0,
			parse: function parse(components, options) {
				return components.host || (components.error = components.error || "HTTP URIs must have a host."), components;
			},
			serialize: function serialize(components, options) {
				var secure = String(components.scheme).toLowerCase() === "https";
				return (components.port === (secure ? 443 : 80) || components.port === "") && (components.port = void 0), components.path ||= "/", components;
			}
		}, handler$1 = {
			scheme: "https",
			domainHost: handler.domainHost,
			parse: handler.parse,
			serialize: handler.serialize
		};
		function isSecure(wsComponents) {
			return typeof wsComponents.secure == "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
		}
		var handler$2 = {
			scheme: "ws",
			domainHost: !0,
			parse: function parse(components, options) {
				var wsComponents = components;
				return wsComponents.secure = isSecure(wsComponents), wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : ""), wsComponents.path = void 0, wsComponents.query = void 0, wsComponents;
			},
			serialize: function serialize(wsComponents, options) {
				if ((wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") && (wsComponents.port = void 0), typeof wsComponents.secure == "boolean" && (wsComponents.scheme = wsComponents.secure ? "wss" : "ws", wsComponents.secure = void 0), wsComponents.resourceName) {
					var _wsComponents$resourc2 = slicedToArray(wsComponents.resourceName.split("?"), 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
					wsComponents.path = path && path !== "/" ? path : void 0, wsComponents.query = query, wsComponents.resourceName = void 0;
				}
				return wsComponents.fragment = void 0, wsComponents;
			}
		}, handler$3 = {
			scheme: "wss",
			domainHost: handler$2.domainHost,
			parse: handler$2.parse,
			serialize: handler$2.serialize
		}, O = {}, UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", HEXDIG$$ = "[0-9A-Fa-f]", PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", VCHAR$$ = merge("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", "[\\\"\\\\]"), SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", UNRESERVED = new RegExp(UNRESERVED$$, "g"), PCT_ENCODED = new RegExp(PCT_ENCODED$, "g"), NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", "[\\\"]", VCHAR$$), "g"), NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g"), NOT_HFVALUE = NOT_HFNAME;
		function decodeUnreserved(str) {
			var decStr = pctDecChars(str);
			return decStr.match(UNRESERVED) ? decStr : str;
		}
		var handler$4 = {
			scheme: "mailto",
			parse: function parse$$1(components, options) {
				var mailtoComponents = components, to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
				if (mailtoComponents.path = void 0, mailtoComponents.query) {
					for (var unknownHeaders = !1, headers = {}, hfields = mailtoComponents.query.split("&"), x = 0, xl = hfields.length; x < xl; ++x) {
						var hfield = hfields[x].split("=");
						switch (hfield[0]) {
							case "to":
								for (var toAddrs = hfield[1].split(","), _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) to.push(toAddrs[_x]);
								break;
							case "subject":
								mailtoComponents.subject = unescapeComponent(hfield[1], options);
								break;
							case "body":
								mailtoComponents.body = unescapeComponent(hfield[1], options);
								break;
							default:
								unknownHeaders = !0, headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
								break;
						}
					}
					unknownHeaders && (mailtoComponents.headers = headers);
				}
				mailtoComponents.query = void 0;
				for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
					var addr = to[_x2].split("@");
					if (addr[0] = unescapeComponent(addr[0]), options.unicodeSupport) addr[1] = unescapeComponent(addr[1], options).toLowerCase();
					else try {
						addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
					} catch (e) {
						mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
					}
					to[_x2] = addr.join("@");
				}
				return mailtoComponents;
			},
			serialize: function serialize$$1(mailtoComponents, options) {
				var components = mailtoComponents, to = toArray(mailtoComponents.to);
				if (to) {
					for (var x = 0, xl = to.length; x < xl; ++x) {
						var toAddr = String(to[x]), atIdx = toAddr.lastIndexOf("@"), localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar), domain = toAddr.slice(atIdx + 1);
						try {
							domain = options.iri ? punycode.toUnicode(domain) : punycode.toASCII(unescapeComponent(domain, options).toLowerCase());
						} catch (e) {
							components.error = components.error || "Email address's domain name can not be converted to " + (options.iri ? "Unicode" : "ASCII") + " via punycode: " + e;
						}
						to[x] = localPart + "@" + domain;
					}
					components.path = to.join(",");
				}
				var headers = mailtoComponents.headers = mailtoComponents.headers || {};
				mailtoComponents.subject && (headers.subject = mailtoComponents.subject), mailtoComponents.body && (headers.body = mailtoComponents.body);
				var fields = [];
				for (var name in headers) headers[name] !== O[name] && fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
				return fields.length && (components.query = fields.join("&")), components;
			}
		}, URN_PARSE = /^([^\:]+)\:(.*)/, handler$5 = {
			scheme: "urn",
			parse: function parse$$1(components, options) {
				var matches = components.path && components.path.match(URN_PARSE), urnComponents = components;
				if (matches) {
					var scheme = options.scheme || urnComponents.scheme || "urn", nid = matches[1].toLowerCase(), nss = matches[2], schemeHandler = SCHEMES[scheme + ":" + (options.nid || nid)];
					urnComponents.nid = nid, urnComponents.nss = nss, urnComponents.path = void 0, schemeHandler && (urnComponents = schemeHandler.parse(urnComponents, options));
				} else urnComponents.error = urnComponents.error || "URN can not be parsed.";
				return urnComponents;
			},
			serialize: function serialize$$1(urnComponents, options) {
				var scheme = options.scheme || urnComponents.scheme || "urn", nid = urnComponents.nid, schemeHandler = SCHEMES[scheme + ":" + (options.nid || nid)];
				schemeHandler && (urnComponents = schemeHandler.serialize(urnComponents, options));
				var uriComponents = urnComponents, nss = urnComponents.nss;
				return uriComponents.path = (nid || options.nid) + ":" + nss, uriComponents;
			}
		}, UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, handler$6 = {
			scheme: "urn:uuid",
			parse: function parse(urnComponents, options) {
				var uuidComponents = urnComponents;
				return uuidComponents.uuid = uuidComponents.nss, uuidComponents.nss = void 0, !options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID)) && (uuidComponents.error = uuidComponents.error || "UUID is not valid."), uuidComponents;
			},
			serialize: function serialize(uuidComponents, options) {
				var urnComponents = uuidComponents;
				return urnComponents.nss = (uuidComponents.uuid || "").toLowerCase(), urnComponents;
			}
		};
		SCHEMES[handler.scheme] = handler, SCHEMES[handler$1.scheme] = handler$1, SCHEMES[handler$2.scheme] = handler$2, SCHEMES[handler$3.scheme] = handler$3, SCHEMES[handler$4.scheme] = handler$4, SCHEMES[handler$5.scheme] = handler$5, SCHEMES[handler$6.scheme] = handler$6, exports$1.SCHEMES = SCHEMES, exports$1.pctEncChar = pctEncChar, exports$1.pctDecChars = pctDecChars, exports$1.parse = parse, exports$1.removeDotSegments = removeDotSegments, exports$1.serialize = serialize, exports$1.resolveComponents = resolveComponents, exports$1.resolve = resolve, exports$1.normalize = normalize, exports$1.equal = equal, exports$1.escapeComponent = escapeComponent, exports$1.unescapeComponent = unescapeComponent, Object.defineProperty(exports$1, "__esModule", { value: !0 });
	}));
})), require_fast_deep_equal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function equal(a, b) {
		if (a === b) return !0;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return !1;
			var length, i, keys;
			if (Array.isArray(a)) {
				if (length = a.length, length != b.length) return !1;
				for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return !1;
				return !0;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
			for (i = length; i-- !== 0;) {
				var key = keys[i];
				if (!equal(a[key], b[key])) return !1;
			}
			return !0;
		}
		return a !== a && b !== b;
	};
})), require_ucs2length = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function ucs2length(str) {
		for (var length = 0, len = str.length, pos = 0, value; pos < len;) length++, value = str.charCodeAt(pos++), value >= 55296 && value <= 56319 && pos < len && (value = str.charCodeAt(pos), (value & 64512) == 56320 && pos++);
		return length;
	};
})), require_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		copy,
		checkDataType,
		checkDataTypes,
		coerceToTypes,
		toHash,
		getProperty,
		escapeQuotes,
		equal: require_fast_deep_equal(),
		ucs2length: require_ucs2length(),
		varOccurences,
		varReplace,
		schemaHasRules,
		schemaHasRulesExcept,
		schemaUnknownRules,
		toQuotedString,
		getPathExpr,
		getPath,
		getData,
		unescapeFragment,
		unescapeJsonPointer,
		escapeFragment,
		escapeJsonPointer
	};
	function copy(o, to) {
		for (var key in to ||= {}, o) to[key] = o[key];
		return to;
	}
	function checkDataType(dataType, data, strictNumbers, negate) {
		var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
		switch (dataType) {
			case "null": return data + EQUAL + "null";
			case "array": return OK + "Array.isArray(" + data + ")";
			case "object": return "(" + OK + data + AND + "typeof " + data + EQUAL + "\"object\"" + AND + NOT + "Array.isArray(" + data + "))";
			case "integer": return "(typeof " + data + EQUAL + "\"number\"" + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
			case "number": return "(typeof " + data + EQUAL + "\"" + dataType + "\"" + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
			default: return "typeof " + data + EQUAL + "\"" + dataType + "\"";
		}
	}
	function checkDataTypes(dataTypes, data, strictNumbers) {
		switch (dataTypes.length) {
			case 1: return checkDataType(dataTypes[0], data, strictNumbers, !0);
			default:
				var code = "", types = toHash(dataTypes);
				for (var t in types.array && types.object && (code = types.null ? "(" : "(!" + data + " || ", code += "typeof " + data + " !== \"object\")", delete types.null, delete types.array, delete types.object), types.number && delete types.integer, types) code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, !0);
				return code;
		}
	}
	var COERCE_TO_TYPES = toHash([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(optionCoerceTypes, dataTypes) {
		if (Array.isArray(dataTypes)) {
			for (var types = [], i = 0; i < dataTypes.length; i++) {
				var t = dataTypes[i];
				(COERCE_TO_TYPES[t] || optionCoerceTypes === "array" && t === "array") && (types[types.length] = t);
			}
			if (types.length) return types;
		} else if (COERCE_TO_TYPES[dataTypes]) return [dataTypes];
		else if (optionCoerceTypes === "array" && dataTypes === "array") return ["array"];
	}
	function toHash(arr) {
		for (var hash = {}, i = 0; i < arr.length; i++) hash[arr[i]] = !0;
		return hash;
	}
	var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i, SINGLE_QUOTE = /'|\\/g;
	function getProperty(key) {
		return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
	}
	function escapeQuotes(str) {
		return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
	}
	function varOccurences(str, dataVar) {
		dataVar += "[^0-9]";
		var matches = str.match(new RegExp(dataVar, "g"));
		return matches ? matches.length : 0;
	}
	function varReplace(str, dataVar, expr) {
		return dataVar += "([^0-9])", expr = expr.replace(/\$/g, "$$$$"), str.replace(new RegExp(dataVar, "g"), expr + "$1");
	}
	function schemaHasRules(schema, rules) {
		if (typeof schema == "boolean") return !schema;
		for (var key in schema) if (rules[key]) return !0;
	}
	function schemaHasRulesExcept(schema, rules, exceptKeyword) {
		if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
		for (var key in schema) if (key != exceptKeyword && rules[key]) return !0;
	}
	function schemaUnknownRules(schema, rules) {
		if (typeof schema != "boolean") {
			for (var key in schema) if (!rules[key]) return key;
		}
	}
	function toQuotedString(str) {
		return "'" + escapeQuotes(str) + "'";
	}
	function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
		return joinPaths(currentPath, jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'");
	}
	function getPath(currentPath, prop, jsonPointers) {
		return joinPaths(currentPath, toQuotedString(jsonPointers ? "/" + escapeJsonPointer(prop) : getProperty(prop)));
	}
	var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/, RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, lvl, paths) {
		var up, jsonPointer, data, matches;
		if ($data === "") return "rootData";
		if ($data[0] == "/") {
			if (!JSON_POINTER.test($data)) throw Error("Invalid JSON-pointer: " + $data);
			jsonPointer = $data, data = "rootData";
		} else {
			if (matches = $data.match(RELATIVE_JSON_POINTER), !matches) throw Error("Invalid JSON-pointer: " + $data);
			if (up = +matches[1], jsonPointer = matches[2], jsonPointer == "#") {
				if (up >= lvl) throw Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
				return paths[lvl - up];
			}
			if (up > lvl) throw Error("Cannot access data " + up + " levels up, current level is " + lvl);
			if (data = "data" + (lvl - up || ""), !jsonPointer) return data;
		}
		for (var expr = data, segments = jsonPointer.split("/"), i = 0; i < segments.length; i++) {
			var segment = segments[i];
			segment && (data += getProperty(unescapeJsonPointer(segment)), expr += " && " + data);
		}
		return expr;
	}
	function joinPaths(a, b) {
		return a == "\"\"" ? b : (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
	}
	function unescapeFragment(str) {
		return unescapeJsonPointer(decodeURIComponent(str));
	}
	function escapeFragment(str) {
		return encodeURIComponent(escapeJsonPointer(str));
	}
	function escapeJsonPointer(str) {
		return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	function unescapeJsonPointer(str) {
		return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
})), require_schema_obj = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var util = require_util();
	module.exports = SchemaObject;
	function SchemaObject(obj) {
		util.copy(obj, this);
	}
})), require_json_schema_traverse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var traverse = module.exports = function(schema, opts, cb) {
		typeof opts == "function" && (cb = opts, opts = {}), cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {}, post = cb.post || function() {};
		_traverse(opts, pre, post, schema, "", schema);
	};
	traverse.keywords = {
		additionalItems: !0,
		items: !0,
		contains: !0,
		additionalProperties: !0,
		propertyNames: !0,
		not: !0
	}, traverse.arrayKeywords = {
		items: !0,
		allOf: !0,
		anyOf: !0,
		oneOf: !0
	}, traverse.propsKeywords = {
		definitions: !0,
		properties: !0,
		patternProperties: !0,
		dependencies: !0
	}, traverse.skipKeywords = {
		default: !0,
		enum: !0,
		const: !0,
		required: !0,
		maximum: !0,
		minimum: !0,
		exclusiveMaximum: !0,
		exclusiveMinimum: !0,
		multipleOf: !0,
		maxLength: !0,
		minLength: !0,
		pattern: !0,
		format: !0,
		maxItems: !0,
		minItems: !0,
		uniqueItems: !0,
		maxProperties: !0,
		minProperties: !0
	};
	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema && typeof schema == "object" && !Array.isArray(schema)) {
			for (var key in pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex), schema) {
				var sch = schema[key];
				if (Array.isArray(sch)) {
					if (key in traverse.arrayKeywords) for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
				} else if (key in traverse.propsKeywords) {
					if (sch && typeof sch == "object") for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
				} else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
			}
			post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str) {
		return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
})), require_resolve = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var URI = require_uri_all(), equal = require_fast_deep_equal(), util = require_util(), SchemaObject = require_schema_obj(), traverse = require_json_schema_traverse();
	module.exports = resolve, resolve.normalizeId = normalizeId, resolve.fullPath = getFullPath, resolve.url = resolveUrl, resolve.ids = resolveIds, resolve.inlineRef = inlineRef, resolve.schema = resolveSchema;
	function resolve(compile, root, ref) {
		var refVal = this._refs[ref];
		if (typeof refVal == "string") if (this._refs[refVal]) refVal = this._refs[refVal];
		else return resolve.call(this, compile, root, refVal);
		if (refVal ||= this._schemas[ref], refVal instanceof SchemaObject) return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
		var res = resolveSchema.call(this, root, ref), schema, v, baseId;
		return res && (schema = res.schema, root = res.root, baseId = res.baseId), schema instanceof SchemaObject ? v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId) : schema !== void 0 && (v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId)), v;
	}
	function resolveSchema(root, ref) {
		var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
		if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
			var id = normalizeId(refPath), refVal = this._refs[id];
			if (typeof refVal == "string") return resolveRecursive.call(this, root, refVal, p);
			if (refVal instanceof SchemaObject) refVal.validate || this._compile(refVal), root = refVal;
			else if (refVal = this._schemas[id], refVal instanceof SchemaObject) {
				if (refVal.validate || this._compile(refVal), id == normalizeId(ref)) return {
					schema: refVal,
					root,
					baseId
				};
				root = refVal;
			} else return;
			if (!root.schema) return;
			baseId = getFullPath(this._getId(root.schema));
		}
		return getJsonPointer.call(this, p, baseId, root.schema, root);
	}
	function resolveRecursive(root, ref, parsedRef) {
		var res = resolveSchema.call(this, root, ref);
		if (res) {
			var schema = res.schema, baseId = res.baseId;
			root = res.root;
			var id = this._getId(schema);
			return id && (baseId = resolveUrl(baseId, id)), getJsonPointer.call(this, parsedRef, baseId, schema, root);
		}
	}
	var PREVENT_SCOPE_CHANGE = util.toHash([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, baseId, schema, root) {
		if (parsedRef.fragment = parsedRef.fragment || "", parsedRef.fragment.slice(0, 1) == "/") {
			for (var parts = parsedRef.fragment.split("/"), i = 1; i < parts.length; i++) {
				var part = parts[i];
				if (part) {
					if (part = util.unescapeFragment(part), schema = schema[part], schema === void 0) break;
					var id;
					if (!PREVENT_SCOPE_CHANGE[part] && (id = this._getId(schema), id && (baseId = resolveUrl(baseId, id)), schema.$ref)) {
						var $ref = resolveUrl(baseId, schema.$ref), res = resolveSchema.call(this, root, $ref);
						res && (schema = res.schema, root = res.root, baseId = res.baseId);
					}
				}
			}
			if (schema !== void 0 && schema !== root.schema) return {
				schema,
				root,
				baseId
			};
		}
	}
	var SIMPLE_INLINED = util.toHash([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum"
	]);
	function inlineRef(schema, limit) {
		if (limit === !1) return !1;
		if (limit === void 0 || limit === !0) return checkNoRef(schema);
		if (limit) return countKeys(schema) <= limit;
	}
	function checkNoRef(schema) {
		var item;
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) if (item = schema[i], typeof item == "object" && !checkNoRef(item)) return !1;
		} else for (var key in schema) if (key == "$ref" || (item = schema[key], typeof item == "object" && !checkNoRef(item))) return !1;
		return !0;
	}
	function countKeys(schema) {
		var count = 0, item;
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) if (item = schema[i], typeof item == "object" && (count += countKeys(item)), count == Infinity) return Infinity;
		} else for (var key in schema) {
			if (key == "$ref") return Infinity;
			if (SIMPLE_INLINED[key]) count++;
			else if (item = schema[key], typeof item == "object" && (count += countKeys(item) + 1), count == Infinity) return Infinity;
		}
		return count;
	}
	function getFullPath(id, normalize) {
		return normalize !== !1 && (id = normalizeId(id)), _getFullPath(URI.parse(id));
	}
	function _getFullPath(p) {
		return URI.serialize(p).split("#")[0] + "#";
	}
	var TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	function resolveUrl(baseId, id) {
		return id = normalizeId(id), URI.resolve(baseId, id);
	}
	function resolveIds(schema) {
		var schemaId = normalizeId(this._getId(schema)), baseIds = { "": schemaId }, fullPaths = { "": getFullPath(schemaId, !1) }, localRefs = {}, self = this;
		return traverse(schema, { allKeys: !0 }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
			if (jsonPtr !== "") {
				var id = self._getId(sch), baseId = baseIds[parentJsonPtr], fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
				if (keyIndex !== void 0 && (fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex))), typeof id == "string") {
					id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
					var refVal = self._refs[id];
					if (typeof refVal == "string" && (refVal = self._refs[refVal]), refVal && refVal.schema) {
						if (!equal(sch, refVal.schema)) throw Error("id \"" + id + "\" resolves to more than one schema");
					} else if (id != normalizeId(fullPath)) if (id[0] == "#") {
						if (localRefs[id] && !equal(sch, localRefs[id])) throw Error("id \"" + id + "\" resolves to more than one schema");
						localRefs[id] = sch;
					} else self._refs[id] = fullPath;
				}
				baseIds[jsonPtr] = baseId, fullPaths[jsonPtr] = fullPath;
			}
		}), localRefs;
	}
})), require_error_classes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var resolve = require_resolve();
	module.exports = {
		Validation: errorSubclass(ValidationError),
		MissingRef: errorSubclass(MissingRefError)
	};
	function ValidationError(errors) {
		this.message = "validation failed", this.errors = errors, this.ajv = this.validation = !0;
	}
	MissingRefError.message = function(baseId, ref) {
		return "can't resolve reference " + ref + " from id " + baseId;
	};
	function MissingRefError(baseId, ref, message) {
		this.message = message || MissingRefError.message(baseId, ref), this.missingRef = resolve.url(baseId, ref), this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
	}
	function errorSubclass(Subclass) {
		return Subclass.prototype = Object.create(Error.prototype), Subclass.prototype.constructor = Subclass, Subclass;
	}
})), require_fast_json_stable_stringify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(data, opts) {
		opts ||= {}, typeof opts == "function" && (opts = { cmp: opts });
		var cycles = typeof opts.cycles == "boolean" ? opts.cycles : !1, cmp = opts.cmp && (function(f) {
			return function(node) {
				return function(a, b) {
					return f({
						key: a,
						value: node[a]
					}, {
						key: b,
						value: node[b]
					});
				};
			};
		})(opts.cmp), seen = [];
		return (function stringify(node) {
			if (node && node.toJSON && typeof node.toJSON == "function" && (node = node.toJSON()), node !== void 0) {
				if (typeof node == "number") return isFinite(node) ? "" + node : "null";
				if (typeof node != "object") return JSON.stringify(node);
				var i, out;
				if (Array.isArray(node)) {
					for (out = "[", i = 0; i < node.length; i++) i && (out += ","), out += stringify(node[i]) || "null";
					return out + "]";
				}
				if (node === null) return "null";
				if (seen.indexOf(node) !== -1) {
					if (cycles) return JSON.stringify("__cycle__");
					throw TypeError("Converting circular structure to JSON");
				}
				var seenIndex = seen.push(node) - 1, keys = Object.keys(node).sort(cmp && cmp(node));
				for (out = "", i = 0; i < keys.length; i++) {
					var key = keys[i], value = stringify(node[key]);
					value && (out && (out += ","), out += JSON.stringify(key) + ":" + value);
				}
				return seen.splice(seenIndex, 1), "{" + out + "}";
			}
		})(data);
	};
})), require_validate = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_validate(it, $keyword, $ruleType) {
		var out = "", $async = it.schema.$async === !0, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
		if (it.opts.strictKeywords) {
			var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
			if ($unknownKwd) {
				var $keywordsMsg = "unknown keyword: " + $unknownKwd;
				if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
				else throw Error($keywordsMsg);
			}
		}
		if (it.isTop && (out += " var validate = ", $async && (it.async = !0, out += "async "), out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", $id && (it.opts.sourceCode || it.opts.processCode) && (out += " " + ("/*# sourceURL=" + $id + " */") + " ")), typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
			var $keyword = "false schema", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $errorKeyword, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl;
			if (it.schema === !1) {
				it.isTop ? $breakOnError = !0 : out += " var " + $valid + " = false; ";
				var $$outStack = $$outStack || [];
				$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ", it.opts.messages !== !1 && (out += " , message: 'boolean schema is false' "), it.opts.verbose && (out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
				var __err = out;
				out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			} else it.isTop ? $async ? out += " return data; " : out += " validate.errors = null; return true; " : out += " var " + $valid + " = true; ";
			return it.isTop && (out += " }; return validate; "), out;
		}
		if (it.isTop) {
			var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
			if (it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema)), it.baseId = it.baseId || it.rootId, delete it.isTop, it.dataPathArr = [""], it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
				var $defaultMsg = "default is ignored in the schema root";
				if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
				else throw Error($defaultMsg);
			}
			out += " var vErrors = null; ", out += " var errors = 0;     ", out += " if (rootData === undefined) rootData = data; ";
		} else {
			var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
			if ($id && (it.baseId = it.resolve.url(it.baseId, $id)), $async && !it.async) throw Error("async schema in sync schema");
			out += " var errs_" + $lvl + " = errors;";
		}
		var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "", $errorKeyword, $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
		if ($typeSchema && it.opts.nullable && it.schema.nullable === !0 && ($typeIsArray ? $typeSchema.indexOf("null") == -1 && ($typeSchema = $typeSchema.concat("null")) : $typeSchema != "null" && ($typeSchema = [$typeSchema, "null"], $typeIsArray = !0)), $typeIsArray && $typeSchema.length == 1 && ($typeSchema = $typeSchema[0], $typeIsArray = !1), it.schema.$ref && $refKeywords) {
			if (it.opts.extendRefs == "fail") throw Error("$ref: validation keywords used in schema at path \"" + it.errSchemaPath + "\" (see option extendRefs)");
			it.opts.extendRefs !== !0 && ($refKeywords = !1, it.logger.warn("$ref: keywords ignored in schema at path \"" + it.errSchemaPath + "\""));
		}
		if (it.schema.$comment && it.opts.$comment && (out += " " + it.RULES.all.$comment.code(it, "$comment")), $typeSchema) {
			if (it.opts.coerceTypes) var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
			var $rulesGroup = it.RULES.types[$typeSchema];
			if ($coerceToTypes || $typeIsArray || $rulesGroup === !0 || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
				var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
				if (out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, !0) + ") { ", $coerceToTypes) {
					var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
					out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ", it.opts.coerceTypes == "array" && (out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } "), out += " if (" + $coerced + " !== undefined) ; ";
					var arr1 = $coerceToTypes;
					if (arr1) for (var $type, $i = -1, l1 = arr1.length - 1; $i < l1;) $type = arr1[$i += 1], $type == "string" ? out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; " : $type == "number" || $type == "integer" ? (out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ", $type == "integer" && (out += " && !(" + $data + " % 1)"), out += ")) " + $coerced + " = +" + $data + "; ") : $type == "boolean" ? out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; " : $type == "null" ? out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; " : it.opts.coerceTypes == "array" && $type == "array" && (out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ");
					out += " else {   ";
					var $$outStack = $$outStack || [];
					$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '", $typeIsArray ? out += "" + $typeSchema.join(",") : out += "" + $typeSchema, out += "' } ", it.opts.messages !== !1 && (out += " , message: 'should be ", $typeIsArray ? out += "" + $typeSchema.join(",") : out += "" + $typeSchema, out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
					var __err = out;
					out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } if (" + $coerced + " !== undefined) {  ";
					var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
					out += " " + $data + " = " + $coerced + "; ", $dataLvl || (out += "if (" + $parentData + " !== undefined)"), out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
				} else {
					var $$outStack = $$outStack || [];
					$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '", $typeIsArray ? out += "" + $typeSchema.join(",") : out += "" + $typeSchema, out += "' } ", it.opts.messages !== !1 && (out += " , message: 'should be ", $typeIsArray ? out += "" + $typeSchema.join(",") : out += "" + $typeSchema, out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
					var __err = out;
					out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
				}
				out += " } ";
			}
		}
		if (it.schema.$ref && !$refKeywords) out += " " + it.RULES.all.$ref.code(it, "$ref") + " ", $breakOnError && (out += " } if (errors === ", $top ? out += "0" : out += "errs_" + $lvl, out += ") { ", $closingBraces2 += "}");
		else {
			var arr2 = it.RULES;
			if (arr2) {
				for (var $rulesGroup, i2 = -1, l2 = arr2.length - 1; i2 < l2;) if ($rulesGroup = arr2[i2 += 1], $shouldUseGroup($rulesGroup)) {
					if ($rulesGroup.type && (out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { "), it.opts.useDefaults) {
						if ($rulesGroup.type == "object" && it.schema.properties) {
							var $schema = it.schema.properties, arr3 = Object.keys($schema);
							if (arr3) for (var $propertyKey, i3 = -1, l3 = arr3.length - 1; i3 < l3;) {
								$propertyKey = arr3[i3 += 1];
								var $sch = $schema[$propertyKey];
								if ($sch.default !== void 0) {
									var $passData = $data + it.util.getProperty($propertyKey);
									if (it.compositeRule) {
										if (it.opts.strictDefaults) {
											var $defaultMsg = "default is ignored for: " + $passData;
											if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
											else throw Error($defaultMsg);
										}
									} else out += " if (" + $passData + " === undefined ", it.opts.useDefaults == "empty" && (out += " || " + $passData + " === null || " + $passData + " === '' "), out += " ) " + $passData + " = ", it.opts.useDefaults == "shared" ? out += " " + it.useDefault($sch.default) + " " : out += " " + JSON.stringify($sch.default) + " ", out += "; ";
								}
							}
						} else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
							var arr4 = it.schema.items;
							if (arr4) {
								for (var $sch, $i = -1, l4 = arr4.length - 1; $i < l4;) if ($sch = arr4[$i += 1], $sch.default !== void 0) {
									var $passData = $data + "[" + $i + "]";
									if (it.compositeRule) {
										if (it.opts.strictDefaults) {
											var $defaultMsg = "default is ignored for: " + $passData;
											if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
											else throw Error($defaultMsg);
										}
									} else out += " if (" + $passData + " === undefined ", it.opts.useDefaults == "empty" && (out += " || " + $passData + " === null || " + $passData + " === '' "), out += " ) " + $passData + " = ", it.opts.useDefaults == "shared" ? out += " " + it.useDefault($sch.default) + " " : out += " " + JSON.stringify($sch.default) + " ", out += "; ";
								}
							}
						}
					}
					var arr5 = $rulesGroup.rules;
					if (arr5) {
						for (var $rule, i5 = -1, l5 = arr5.length - 1; i5 < l5;) if ($rule = arr5[i5 += 1], $shouldUseRule($rule)) {
							var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
							$code && (out += " " + $code + " ", $breakOnError && ($closingBraces1 += "}"));
						}
					}
					if ($breakOnError && (out += " " + $closingBraces1 + " ", $closingBraces1 = ""), $rulesGroup.type && (out += " } ", $typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes)) {
						out += " else { ";
						var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $$outStack = $$outStack || [];
						$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '", $typeIsArray ? out += "" + $typeSchema.join(",") : out += "" + $typeSchema, out += "' } ", it.opts.messages !== !1 && (out += " , message: 'should be ", $typeIsArray ? out += "" + $typeSchema.join(",") : out += "" + $typeSchema, out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
						var __err = out;
						out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } ";
					}
					$breakOnError && (out += " if (errors === ", $top ? out += "0" : out += "errs_" + $lvl, out += ") { ", $closingBraces2 += "}");
				}
			}
		}
		$breakOnError && (out += " " + $closingBraces2 + " "), $top ? ($async ? (out += " if (errors === 0) return data;           ", out += " else throw new ValidationError(vErrors); ") : (out += " validate.errors = vErrors; ", out += " return errors === 0;       "), out += " }; return validate;") : out += " var " + $valid + " = errors === errs_" + $lvl + ";";
		function $shouldUseGroup($rulesGroup) {
			for (var rules = $rulesGroup.rules, i = 0; i < rules.length; i++) if ($shouldUseRule(rules[i])) return !0;
		}
		function $shouldUseRule($rule) {
			return it.schema[$rule.keyword] !== void 0 || $rule.implements && $ruleImplementsSomeKeyword($rule);
		}
		function $ruleImplementsSomeKeyword($rule) {
			for (var impl = $rule.implements, i = 0; i < impl.length; i++) if (it.schema[impl[i]] !== void 0) return !0;
		}
		return out;
	};
})), require_compile = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var resolve = require_resolve(), util = require_util(), errorClasses = require_error_classes(), stableStringify = require_fast_json_stable_stringify(), validateGenerator = require_validate(), ucs2length = util.ucs2length, equal = require_fast_deep_equal(), ValidationError = errorClasses.Validation;
	module.exports = compile;
	function compile(schema, root, localRefs, baseId) {
		var self = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
		root ||= {
			schema,
			refVal,
			refs
		};
		var c = checkCompiling.call(this, schema, root, baseId), compilation = this._compilations[c.index];
		if (c.compiling) return compilation.callValidate = callValidate;
		var formats = this._formats, RULES = this.RULES;
		try {
			var v = localCompile(schema, root, localRefs, baseId);
			compilation.validate = v;
			var cv = compilation.callValidate;
			return cv && (cv.schema = v.schema, cv.errors = null, cv.refs = v.refs, cv.refVal = v.refVal, cv.root = v.root, cv.$async = v.$async, opts.sourceCode && (cv.source = v.source)), v;
		} finally {
			endCompiling.call(this, schema, root, baseId);
		}
		function callValidate() {
			var validate = compilation.validate, result = validate.apply(this, arguments);
			return callValidate.errors = validate.errors, result;
		}
		function localCompile(_schema, _root, localRefs, baseId) {
			var isRoot = !_root || _root && _root.schema == _schema;
			if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);
			var $async = _schema.$async === !0, sourceCode = validateGenerator({
				isTop: !0,
				schema: _schema,
				isRoot,
				baseId,
				root: _root,
				schemaPath: "",
				errSchemaPath: "#",
				errorPath: "\"\"",
				MissingRefError: errorClasses.MissingRef,
				RULES,
				validate: validateGenerator,
				util,
				resolve,
				resolveRef,
				usePattern,
				useDefault,
				useCustomRule,
				opts,
				formats,
				logger: self.logger,
				self
			});
			sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode, opts.processCode && (sourceCode = opts.processCode(sourceCode, _schema));
			var validate;
			try {
				validate = Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode)(self, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError), refVal[0] = validate;
			} catch (e) {
				throw self.logger.error("Error compiling schema, function code:", sourceCode), e;
			}
			return validate.schema = _schema, validate.errors = null, validate.refs = refs, validate.refVal = refVal, validate.root = isRoot ? validate : _root, $async && (validate.$async = !0), opts.sourceCode === !0 && (validate.source = {
				code: sourceCode,
				patterns,
				defaults
			}), validate;
		}
		function resolveRef(baseId, ref, isRoot) {
			ref = resolve.url(baseId, ref);
			var refIndex = refs[ref], _refVal, refCode;
			if (refIndex !== void 0) return _refVal = refVal[refIndex], refCode = "refVal[" + refIndex + "]", resolvedRef(_refVal, refCode);
			if (!isRoot && root.refs) {
				var rootRefId = root.refs[ref];
				if (rootRefId !== void 0) return _refVal = root.refVal[rootRefId], refCode = addLocalRef(ref, _refVal), resolvedRef(_refVal, refCode);
			}
			refCode = addLocalRef(ref);
			var v = resolve.call(self, localCompile, root, ref);
			if (v === void 0) {
				var localSchema = localRefs && localRefs[ref];
				localSchema && (v = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId));
			}
			if (v === void 0) removeLocalRef(ref);
			else return replaceLocalRef(ref, v), resolvedRef(v, refCode);
		}
		function addLocalRef(ref, v) {
			var refId = refVal.length;
			return refVal[refId] = v, refs[ref] = refId, "refVal" + refId;
		}
		function removeLocalRef(ref) {
			delete refs[ref];
		}
		function replaceLocalRef(ref, v) {
			var refId = refs[ref];
			refVal[refId] = v;
		}
		function resolvedRef(refVal, code) {
			return typeof refVal == "object" || typeof refVal == "boolean" ? {
				code,
				schema: refVal,
				inline: !0
			} : {
				code,
				$async: refVal && !!refVal.$async
			};
		}
		function usePattern(regexStr) {
			var index = patternsHash[regexStr];
			return index === void 0 && (index = patternsHash[regexStr] = patterns.length, patterns[index] = regexStr), "pattern" + index;
		}
		function useDefault(value) {
			switch (typeof value) {
				case "boolean":
				case "number": return "" + value;
				case "string": return util.toQuotedString(value);
				case "object":
					if (value === null) return "null";
					var valueStr = stableStringify(value), index = defaultsHash[valueStr];
					return index === void 0 && (index = defaultsHash[valueStr] = defaults.length, defaults[index] = value), "default" + index;
			}
		}
		function useCustomRule(rule, schema, parentSchema, it) {
			if (self._opts.validateSchema !== !1) {
				var deps = rule.definition.dependencies;
				if (deps && !deps.every(function(keyword) {
					return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
				})) throw Error("parent schema must have all required keywords: " + deps.join(","));
				var validateSchema = rule.definition.validateSchema;
				if (validateSchema && !validateSchema(schema)) {
					var message = "keyword schema is invalid: " + self.errorsText(validateSchema.errors);
					if (self._opts.validateSchema == "log") self.logger.error(message);
					else throw Error(message);
				}
			}
			var compile = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro, validate;
			if (compile) validate = compile.call(self, schema, parentSchema, it);
			else if (macro) validate = macro.call(self, schema, parentSchema, it), opts.validateSchema !== !1 && self.validateSchema(validate, !0);
			else if (inline) validate = inline.call(self, it, rule.keyword, schema, parentSchema);
			else if (validate = rule.definition.validate, !validate) return;
			if (validate === void 0) throw Error("custom keyword \"" + rule.keyword + "\"failed to compile");
			var index = customRules.length;
			return customRules[index] = validate, {
				code: "customRule" + index,
				validate
			};
		}
	}
	function checkCompiling(schema, root, baseId) {
		var index = compIndex.call(this, schema, root, baseId);
		return index >= 0 ? {
			index,
			compiling: !0
		} : (index = this._compilations.length, this._compilations[index] = {
			schema,
			root,
			baseId
		}, {
			index,
			compiling: !1
		});
	}
	function endCompiling(schema, root, baseId) {
		var i = compIndex.call(this, schema, root, baseId);
		i >= 0 && this._compilations.splice(i, 1);
	}
	function compIndex(schema, root, baseId) {
		for (var i = 0; i < this._compilations.length; i++) {
			var c = this._compilations[i];
			if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
		}
		return -1;
	}
	function patternCode(i, patterns) {
		return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
	}
	function defaultCode(i) {
		return "var default" + i + " = defaults[" + i + "];";
	}
	function refValCode(i, refVal) {
		return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
	}
	function customRuleCode(i) {
		return "var customRule" + i + " = customRules[" + i + "];";
	}
	function vars(arr, statement) {
		if (!arr.length) return "";
		for (var code = "", i = 0; i < arr.length; i++) code += statement(i, arr);
		return code;
	}
})), require_cache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Cache = module.exports = function Cache() {
		this._cache = {};
	};
	Cache.prototype.put = function Cache_put(key, value) {
		this._cache[key] = value;
	}, Cache.prototype.get = function Cache_get(key) {
		return this._cache[key];
	}, Cache.prototype.del = function Cache_del(key) {
		delete this._cache[key];
	}, Cache.prototype.clear = function Cache_clear() {
		this._cache = {};
	};
})), require_formats = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var util = require_util(), DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, DAYS = [
		0,
		31,
		28,
		31,
		30,
		31,
		30,
		31,
		31,
		30,
		31,
		30,
		31
	], TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/, JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
	module.exports = formats;
	function formats(mode) {
		return mode = mode == "full" ? "full" : "fast", util.copy(formats[mode]);
	}
	formats.fast = {
		date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
		time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
		"date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
		uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
		"uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
		"uri-template": URITEMPLATE,
		url: URL,
		email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
		hostname: HOSTNAME,
		ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
		ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
		regex,
		uuid: UUID,
		"json-pointer": JSON_POINTER,
		"json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
		"relative-json-pointer": RELATIVE_JSON_POINTER
	}, formats.full = {
		date,
		time,
		"date-time": date_time,
		uri,
		"uri-reference": URIREF,
		"uri-template": URITEMPLATE,
		url: URL,
		email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
		hostname: HOSTNAME,
		ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
		ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
		regex,
		uuid: UUID,
		"json-pointer": JSON_POINTER,
		"json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
		"relative-json-pointer": RELATIVE_JSON_POINTER
	};
	function isLeapYear(year) {
		return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
	}
	function date(str) {
		var matches = str.match(DATE);
		if (!matches) return !1;
		var year = +matches[1], month = +matches[2], day = +matches[3];
		return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
	}
	function time(str, full) {
		var matches = str.match(TIME);
		if (!matches) return !1;
		var hour = matches[1], minute = matches[2], second = matches[3], timeZone = matches[5];
		return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
	}
	var DATE_TIME_SEPARATOR = /t|\s/i;
	function date_time(str) {
		var dateTime = str.split(DATE_TIME_SEPARATOR);
		return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], !0);
	}
	var NOT_URI_FRAGMENT = /\/|:/;
	function uri(str) {
		return NOT_URI_FRAGMENT.test(str) && URI.test(str);
	}
	var Z_ANCHOR = /[^\\]\\Z/;
	function regex(str) {
		if (Z_ANCHOR.test(str)) return !1;
		try {
			return new RegExp(str), !0;
		} catch {
			return !1;
		}
	}
})), require_ref = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_ref(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $async, $refCode;
		if ($schema == "#" || $schema == "#/") it.isRoot ? ($async = it.async, $refCode = "validate") : ($async = it.root.schema.$async === !0, $refCode = "root.refVal[0]");
		else {
			var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
			if ($refVal === void 0) {
				var $message = it.MissingRefError.message(it.baseId, $schema);
				if (it.opts.missingRefs == "fail") {
					it.logger.error($message);
					var $$outStack = $$outStack || [];
					$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ", it.opts.messages !== !1 && (out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' "), it.opts.verbose && (out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
					var __err = out;
					out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", $breakOnError && (out += " if (false) { ");
				} else if (it.opts.missingRefs == "ignore") it.logger.warn($message), $breakOnError && (out += " if (true) { ");
				else throw new it.MissingRefError(it.baseId, $schema, $message);
			} else if ($refVal.inline) {
				var $it = it.util.copy(it);
				$it.level++;
				var $nextValid = "valid" + $it.level;
				$it.schema = $refVal.schema, $it.schemaPath = "", $it.errSchemaPath = $schema;
				var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
				out += " " + $code + " ", $breakOnError && (out += " if (" + $nextValid + ") { ");
			} else $async = $refVal.$async === !0 || it.async && $refVal.$async !== !1, $refCode = $refVal.code;
		}
		if ($refCode) {
			var $$outStack = $$outStack || [];
			$$outStack.push(out), out = "", it.opts.passContext ? out += " " + $refCode + ".call(this, " : out += " " + $refCode + "( ", out += " " + $data + ", (dataPath || '')", it.errorPath != "\"\"" && (out += " + " + it.errorPath);
			var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
			out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
			var __callValidate = out;
			if (out = $$outStack.pop(), $async) {
				if (!it.async) throw Error("async schema referenced by sync schema");
				$breakOnError && (out += " var " + $valid + "; "), out += " try { await " + __callValidate + "; ", $breakOnError && (out += " " + $valid + " = true; "), out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", $breakOnError && (out += " " + $valid + " = false; "), out += " } ", $breakOnError && (out += " if (" + $valid + ") { ");
			} else out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ", $breakOnError && (out += " else { ");
		}
		return out;
	};
})), require_allOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_allOf(it, $keyword, $ruleType) {
		var out = " ", $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level, $currentBaseId = $it.baseId, $allSchemasEmpty = !0, arr1 = $schema;
		if (arr1) for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1;) $sch = arr1[$i += 1], (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === !1 : it.util.schemaHasRules($sch, it.RULES.all)) && ($allSchemasEmpty = !1, $it.schema = $sch, $it.schemaPath = $schemaPath + "[" + $i + "]", $it.errSchemaPath = $errSchemaPath + "/" + $i, out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId, $breakOnError && (out += " if (" + $nextValid + ") { ", $closingBraces += "}"));
		return $breakOnError && ($allSchemasEmpty ? out += " if (true) { " : out += " " + $closingBraces.slice(0, -1) + " "), out;
	};
})), require_anyOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_anyOf(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		if ($schema.every(function($sch) {
			return it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === !1 : it.util.schemaHasRules($sch, it.RULES.all);
		})) {
			var $currentBaseId = $it.baseId;
			out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = !0;
			var arr1 = $schema;
			if (arr1) for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1;) $sch = arr1[$i += 1], $it.schema = $sch, $it.schemaPath = $schemaPath + "[" + $i + "]", $it.errSchemaPath = $errSchemaPath + "/" + $i, out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId, out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ", $closingBraces += "}";
			it.compositeRule = $it.compositeRule = $wasComposite, out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ", it.opts.messages !== !1 && (out += " , message: 'should match some schema in anyOf' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !it.compositeRule && $breakOnError && (it.async ? out += " throw new ValidationError(vErrors); " : out += " validate.errors = vErrors; return false; "), out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ", it.opts.allErrors && (out += " } ");
		} else $breakOnError && (out += " if (true) { ");
		return out;
	};
})), require_comment = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_comment(it, $keyword, $ruleType) {
		var out = " ", $schema = it.schema[$keyword], $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		it.opts.allErrors;
		var $comment = it.util.toQuotedString($schema);
		return it.opts.$comment === !0 ? out += " console.log(" + $comment + ");" : typeof it.opts.$comment == "function" && (out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);"), out;
	};
})), require_const = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_const(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $isData = it.opts.$data && $schema && $schema.$data;
		$isData && (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", "" + $lvl), $isData || (out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";"), out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ", it.opts.messages !== !1 && (out += " , message: 'should be equal to constant' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " }", $breakOnError && (out += " else { "), out;
	};
})), require_contains = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_contains(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level, $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === !1 : it.util.schemaHasRules($schema, it.RULES.all);
		if (out += "var " + $errs + " = errors;var " + $valid + ";", $nonEmptySchema) {
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = !0, $it.schema = $schema, $it.schemaPath = $schemaPath, $it.errSchemaPath = $errSchemaPath, out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ", $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, !0);
			var $passData = $data + "[" + $idx + "]";
			$it.dataPathArr[$dataNxt] = $idx;
			var $code = it.validate($it);
			$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", out += " if (" + $nextValid + ") break; }  ", it.compositeRule = $it.compositeRule = $wasComposite, out += " " + $closingBraces + " if (!" + $nextValid + ") {";
		} else out += " if (" + $data + ".length == 0) {";
		var $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ", it.opts.messages !== !1 && (out += " , message: 'should contain a valid item' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } else { ", $nonEmptySchema && (out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } "), it.opts.allErrors && (out += " } "), out;
	};
})), require_dependencies = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_dependencies(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level, $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
		for ($property in $schema) if ($property != "__proto__") {
			var $sch = $schema[$property], $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
			$deps[$property] = $sch;
		}
		out += "var " + $errs + " = errors;";
		var $currentErrorPath = it.errorPath;
		for (var $property in out += "var missing" + $lvl + ";", $propertyDeps) if ($deps = $propertyDeps[$property], $deps.length) {
			if (out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ", $ownProperties && (out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') "), $breakOnError) {
				out += " && ( ";
				var arr1 = $deps;
				if (arr1) for (var $propertyKey, $i = -1, l1 = arr1.length - 1; $i < l1;) {
					$propertyKey = arr1[$i += 1], $i && (out += " || ");
					var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
					out += " ( ( " + $useData + " === undefined ", $ownProperties && (out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') "), out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
				}
				out += ")) {  ";
				var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
				it.opts._errorDataPathProperty && (it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, !0) : $currentErrorPath + " + " + $propertyPath);
				var $$outStack = $$outStack || [];
				$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ", it.opts.messages !== !1 && (out += " , message: 'should have ", $deps.length == 1 ? out += "property " + it.util.escapeQuotes($deps[0]) : out += "properties " + it.util.escapeQuotes($deps.join(", ")), out += " when property " + it.util.escapeQuotes($property) + " is present' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
				var __err = out;
				out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			} else {
				out += " ) { ";
				var arr2 = $deps;
				if (arr2) for (var $propertyKey, i2 = -1, l2 = arr2.length - 1; i2 < l2;) {
					$propertyKey = arr2[i2 += 1];
					var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
					it.opts._errorDataPathProperty && (it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers)), out += " if ( " + $useData + " === undefined ", $ownProperties && (out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') "), out += ") {  var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ", it.opts.messages !== !1 && (out += " , message: 'should have ", $deps.length == 1 ? out += "property " + it.util.escapeQuotes($deps[0]) : out += "properties " + it.util.escapeQuotes($deps.join(", ")), out += " when property " + it.util.escapeQuotes($property) + " is present' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
				}
			}
			out += " }   ", $breakOnError && ($closingBraces += "}", out += " else { ");
		}
		it.errorPath = $currentErrorPath;
		var $currentBaseId = $it.baseId;
		for (var $property in $schemaDeps) {
			var $sch = $schemaDeps[$property];
			(it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === !1 : it.util.schemaHasRules($sch, it.RULES.all)) && (out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ", $ownProperties && (out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') "), out += ") { ", $it.schema = $sch, $it.schemaPath = $schemaPath + it.util.getProperty($property), $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property), out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId, out += " }  ", $breakOnError && (out += " if (" + $nextValid + ") { ", $closingBraces += "}"));
		}
		return $breakOnError && (out += "   " + $closingBraces + " if (" + $errs + " == errors) {"), out;
	};
})), require_enum = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_enum(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $isData = it.opts.$data && $schema && $schema.$data;
		$isData && (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", "" + $lvl);
		var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
		$isData || (out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";"), out += "var " + $valid + ";", $isData && (out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {"), out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }", $isData && (out += "  }  "), out += " if (!" + $valid + ") {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ", it.opts.messages !== !1 && (out += " , message: 'should be equal to one of the allowed values' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " }", $breakOnError && (out += " else { "), out;
	};
})), require_format = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_format(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || "");
		if (it.opts.format === !1) return $breakOnError && (out += " if (true) { "), out;
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		$isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema;
		var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
		if ($isData) {
			var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
			out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ", it.async && (out += " var async" + $lvl + " = " + $format + ".async; "), out += " " + $format + " = " + $format + ".validate; } if (  ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || "), out += " (", $unknownFormats != "ignore" && (out += " (" + $schemaValue + " && !" + $format + " ", $allowUnknown && (out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 "), out += ") || "), out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ", it.async ? out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) " : out += " " + $format + "(" + $data + ") ", out += " : " + $format + ".test(" + $data + "))))) {";
		} else {
			var $format = it.formats[$schema];
			if (!$format) {
				if ($unknownFormats == "ignore") return it.logger.warn("unknown format \"" + $schema + "\" ignored in schema at path \"" + it.errSchemaPath + "\""), $breakOnError && (out += " if (true) { "), out;
				if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) return $breakOnError && (out += " if (true) { "), out;
				throw Error("unknown format \"" + $schema + "\" is used in schema at path \"" + it.errSchemaPath + "\"");
			}
			var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate, $formatType = $isObject && $format.type || "string";
			if ($isObject) {
				var $async = $format.async === !0;
				$format = $format.validate;
			}
			if ($formatType != $ruleType) return $breakOnError && (out += " if (true) { "), out;
			if ($async) {
				if (!it.async) throw Error("async format in sync schema");
				var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
				out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
			} else {
				out += " if (! ";
				var $formatRef = "formats" + it.util.getProperty($schema);
				$isObject && ($formatRef += ".validate"), typeof $format == "function" ? out += " " + $formatRef + "(" + $data + ") " : out += " " + $formatRef + ".test(" + $data + ") ", out += ") { ";
			}
		}
		var $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ", $isData ? out += "" + $schemaValue : out += "" + it.util.toQuotedString($schema), out += "  } ", it.opts.messages !== !1 && (out += " , message: 'should match format \"", $isData ? out += "' + " + $schemaValue + " + '" : out += "" + it.util.escapeQuotes($schema), out += "\"' "), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + it.util.toQuotedString($schema), out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } ", $breakOnError && (out += " else { "), out;
	};
})), require_if = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_if(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $errs = "errs__" + $lvl, $it = it.util.copy(it);
		$it.level++;
		var $nextValid = "valid" + $it.level, $thenSch = it.schema.then, $elseSch = it.schema.else, $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === !1 : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === !1 : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
		if ($thenPresent || $elsePresent) {
			var $ifClause;
			$it.createErrors = !1, $it.schema = $schema, $it.schemaPath = $schemaPath, $it.errSchemaPath = $errSchemaPath, out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = !0, out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId, $it.createErrors = !0, out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ", it.compositeRule = $it.compositeRule = $wasComposite, $thenPresent ? (out += " if (" + $nextValid + ") {  ", $it.schema = it.schema.then, $it.schemaPath = it.schemaPath + ".then", $it.errSchemaPath = it.errSchemaPath + "/then", out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId, out += " " + $valid + " = " + $nextValid + "; ", $thenPresent && $elsePresent ? ($ifClause = "ifClause" + $lvl, out += " var " + $ifClause + " = 'then'; ") : $ifClause = "'then'", out += " } ", $elsePresent && (out += " else { ")) : out += " if (!" + $nextValid + ") { ", $elsePresent && ($it.schema = it.schema.else, $it.schemaPath = it.schemaPath + ".else", $it.errSchemaPath = it.errSchemaPath + "/else", out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId, out += " " + $valid + " = " + $nextValid + "; ", $thenPresent && $elsePresent ? ($ifClause = "ifClause" + $lvl, out += " var " + $ifClause + " = 'else'; ") : $ifClause = "'else'", out += " } "), out += " if (!" + $valid + ") {   var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ", it.opts.messages !== !1 && (out += " , message: 'should match \"' + " + $ifClause + " + '\" schema' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !it.compositeRule && $breakOnError && (it.async ? out += " throw new ValidationError(vErrors); " : out += " validate.errors = vErrors; return false; "), out += " }   ", $breakOnError && (out += " else { ");
		} else $breakOnError && (out += " if (true) { ");
		return out;
	};
})), require_items = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_items(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level, $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
		if (out += "var " + $errs + " = errors;var " + $valid + ";", Array.isArray($schema)) {
			var $additionalItems = it.schema.additionalItems;
			if ($additionalItems === !1) {
				out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
				var $currErrSchemaPath = $errSchemaPath;
				$errSchemaPath = it.errSchemaPath + "/additionalItems", out += "  if (!" + $valid + ") {   ";
				var $$outStack = $$outStack || [];
				$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ", it.opts.messages !== !1 && (out += " , message: 'should NOT have more than " + $schema.length + " items' "), it.opts.verbose && (out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
				var __err = out;
				out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } ", $errSchemaPath = $currErrSchemaPath, $breakOnError && ($closingBraces += "}", out += " else { ");
			}
			var arr1 = $schema;
			if (arr1) {
				for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1;) if ($sch = arr1[$i += 1], it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === !1 : it.util.schemaHasRules($sch, it.RULES.all)) {
					out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
					var $passData = $data + "[" + $i + "]";
					$it.schema = $sch, $it.schemaPath = $schemaPath + "[" + $i + "]", $it.errSchemaPath = $errSchemaPath + "/" + $i, $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, !0), $it.dataPathArr[$dataNxt] = $i;
					var $code = it.validate($it);
					$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", out += " }  ", $breakOnError && (out += " if (" + $nextValid + ") { ", $closingBraces += "}");
				}
			}
			if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === !1 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
				$it.schema = $additionalItems, $it.schemaPath = it.schemaPath + ".additionalItems", $it.errSchemaPath = it.errSchemaPath + "/additionalItems", out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ", $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, !0);
				var $passData = $data + "[" + $idx + "]";
				$it.dataPathArr[$dataNxt] = $idx;
				var $code = it.validate($it);
				$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", $breakOnError && (out += " if (!" + $nextValid + ") break; "), out += " } }  ", $breakOnError && (out += " if (" + $nextValid + ") { ", $closingBraces += "}");
			}
		} else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === !1 : it.util.schemaHasRules($schema, it.RULES.all)) {
			$it.schema = $schema, $it.schemaPath = $schemaPath, $it.errSchemaPath = $errSchemaPath, out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ", $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, !0);
			var $passData = $data + "[" + $idx + "]";
			$it.dataPathArr[$dataNxt] = $idx;
			var $code = it.validate($it);
			$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", $breakOnError && (out += " if (!" + $nextValid + ") break; "), out += " }";
		}
		return $breakOnError && (out += " " + $closingBraces + " if (" + $errs + " == errors) {"), out;
	};
})), require__limit = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate__limit(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $errorKeyword, $data = "data" + ($dataLvl || ""), $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		$isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema;
		var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
		if (!($isData || typeof $schema == "number" || $schema === void 0)) throw Error($keyword + " must be number");
		if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) throw Error($exclusiveKeyword + " must be number or boolean");
		if ($isDataExcl) {
			var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
			out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ", $schemaValueExcl = "schemaExcl" + $lvl, out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
			var $errorKeyword = $exclusiveKeyword, $$outStack = $$outStack || [];
			$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ", it.opts.messages !== !1 && (out += " , message: '" + $exclusiveKeyword + " should be boolean' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
			var __err = out;
			out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } else if ( ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || "), out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ", $schema === void 0 && ($errorKeyword = $exclusiveKeyword, $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword, $schemaValue = $schemaValueExcl, $isData = $isDataExcl);
		} else {
			var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
			if ($exclIsNumber && $isData) {
				var $opExpr = "'" + $opStr + "'";
				out += " if ( ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || "), out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
			} else {
				$exclIsNumber && $schema === void 0 ? ($exclusive = !0, $errorKeyword = $exclusiveKeyword, $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword, $schemaValue = $schemaExcl, $notOp += "=") : ($exclIsNumber && ($schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema)), $schemaExcl === ($exclIsNumber ? $schemaValue : !0) ? ($exclusive = !0, $errorKeyword = $exclusiveKeyword, $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword, $notOp += "=") : ($exclusive = !1, $opStr += "="));
				var $opExpr = "'" + $opStr + "'";
				out += " if ( ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || "), out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
			}
		}
		$errorKeyword ||= $keyword;
		var $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ", it.opts.messages !== !1 && (out += " , message: 'should be " + $opStr + " ", $isData ? out += "' + " + $schemaValue : out += "" + $schemaValue + "'"), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + $schema, out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } ", $breakOnError && (out += " else { "), out;
	};
})), require__limitItems = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate__limitItems(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $errorKeyword, $data = "data" + ($dataLvl || ""), $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema, !($isData || typeof $schema == "number")) throw Error($keyword + " must be number");
		var $op = $keyword == "maxItems" ? ">" : "<";
		out += "if ( ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || "), out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
		var $errorKeyword = $keyword, $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ", it.opts.messages !== !1 && (out += " , message: 'should NOT have ", $keyword == "maxItems" ? out += "more" : out += "fewer", out += " than ", $isData ? out += "' + " + $schemaValue + " + '" : out += "" + $schema, out += " items' "), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + $schema, out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += "} ", $breakOnError && (out += " else { "), out;
	};
})), require__limitLength = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate__limitLength(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $errorKeyword, $data = "data" + ($dataLvl || ""), $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema, !($isData || typeof $schema == "number")) throw Error($keyword + " must be number");
		var $op = $keyword == "maxLength" ? ">" : "<";
		out += "if ( ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || "), it.opts.unicode === !1 ? out += " " + $data + ".length " : out += " ucs2length(" + $data + ") ", out += " " + $op + " " + $schemaValue + ") { ";
		var $errorKeyword = $keyword, $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ", it.opts.messages !== !1 && (out += " , message: 'should NOT be ", $keyword == "maxLength" ? out += "longer" : out += "shorter", out += " than ", $isData ? out += "' + " + $schemaValue + " + '" : out += "" + $schema, out += " characters' "), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + $schema, out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += "} ", $breakOnError && (out += " else { "), out;
	};
})), require__limitProperties = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $errorKeyword, $data = "data" + ($dataLvl || ""), $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema, !($isData || typeof $schema == "number")) throw Error($keyword + " must be number");
		var $op = $keyword == "maxProperties" ? ">" : "<";
		out += "if ( ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || "), out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
		var $errorKeyword = $keyword, $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ", it.opts.messages !== !1 && (out += " , message: 'should NOT have ", $keyword == "maxProperties" ? out += "more" : out += "fewer", out += " than ", $isData ? out += "' + " + $schemaValue + " + '" : out += "" + $schema, out += " properties' "), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + $schema, out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += "} ", $breakOnError && (out += " else { "), out;
	};
})), require_multipleOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema, !($isData || typeof $schema == "number")) throw Error($keyword + " must be number");
		out += "var division" + $lvl + ";if (", $isData && (out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || "), out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ", it.opts.multipleOfPrecision ? out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " " : out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ", out += " ) ", $isData && (out += "  )  "), out += " ) {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ", it.opts.messages !== !1 && (out += " , message: 'should be multiple of ", $isData ? out += "' + " + $schemaValue : out += "" + $schemaValue + "'"), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + $schema, out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += "} ", $breakOnError && (out += " else { "), out;
	};
})), require_not = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_not(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $errs = "errs__" + $lvl, $it = it.util.copy(it);
		$it.level++;
		var $nextValid = "valid" + $it.level;
		if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === !1 : it.util.schemaHasRules($schema, it.RULES.all)) {
			$it.schema = $schema, $it.schemaPath = $schemaPath, $it.errSchemaPath = $errSchemaPath, out += " var " + $errs + " = errors;  ";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = !0, $it.createErrors = !1;
			var $allErrorsOption;
			$it.opts.allErrors && ($allErrorsOption = $it.opts.allErrors, $it.opts.allErrors = !1), out += " " + it.validate($it) + " ", $it.createErrors = !0, $allErrorsOption && ($it.opts.allErrors = $allErrorsOption), it.compositeRule = $it.compositeRule = $wasComposite, out += " if (" + $nextValid + ") {   ";
			var $$outStack = $$outStack || [];
			$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ", it.opts.messages !== !1 && (out += " , message: 'should NOT be valid' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
			var __err = out;
			out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ", it.opts.allErrors && (out += " } ");
		} else out += "  var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ", it.opts.messages !== !1 && (out += " , message: 'should NOT be valid' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", $breakOnError && (out += " if (false) { ");
		return out;
	};
})), require_oneOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_oneOf(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level, $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
		out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
		var $wasComposite = it.compositeRule;
		it.compositeRule = $it.compositeRule = !0;
		var arr1 = $schema;
		if (arr1) for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1;) $sch = arr1[$i += 1], (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === !1 : it.util.schemaHasRules($sch, it.RULES.all)) ? ($it.schema = $sch, $it.schemaPath = $schemaPath + "[" + $i + "]", $it.errSchemaPath = $errSchemaPath + "/" + $i, out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId) : out += " var " + $nextValid + " = true; ", $i && (out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ", $closingBraces += "}"), out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
		return it.compositeRule = $it.compositeRule = $wasComposite, out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ", it.opts.messages !== !1 && (out += " , message: 'should match exactly one schema in oneOf' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !it.compositeRule && $breakOnError && (it.async ? out += " throw new ValidationError(vErrors); " : out += " validate.errors = vErrors; return false; "), out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }", it.opts.allErrors && (out += " } "), out;
	};
})), require_pattern = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_pattern(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		$isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema;
		var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
		out += "if ( ", $isData && (out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || "), out += " !" + $regexp + ".test(" + $data + ") ) {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ", $isData ? out += "" + $schemaValue : out += "" + it.util.toQuotedString($schema), out += "  } ", it.opts.messages !== !1 && (out += " , message: 'should match pattern \"", $isData ? out += "' + " + $schemaValue + " + '" : out += "" + it.util.escapeQuotes($schema), out += "\"' "), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + it.util.toQuotedString($schema), out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
		var __err = out;
		return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += "} ", $breakOnError && (out += " else { "), out;
	};
})), require_properties = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_properties(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level, $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === !1, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId, $required = it.schema.required;
		if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
		function notProto(p) {
			return p !== "__proto__";
		}
		if (out += "var " + $errs + " = errors;var " + $nextValid + " = true;", $ownProperties && (out += " var " + $dataProperties + " = undefined;"), $checkAdditional) {
			if ($ownProperties ? out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; " : out += " for (var " + $key + " in " + $data + ") { ", $someProperties) {
				if (out += " var isAdditional" + $lvl + " = !(false ", $schemaKeys.length) if ($schemaKeys.length > 8) out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
				else {
					var arr1 = $schemaKeys;
					if (arr1) for (var $propertyKey, i1 = -1, l1 = arr1.length - 1; i1 < l1;) $propertyKey = arr1[i1 += 1], out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
				}
				if ($pPropertyKeys.length) {
					var arr2 = $pPropertyKeys;
					if (arr2) for (var $pProperty, $i = -1, l2 = arr2.length - 1; $i < l2;) $pProperty = arr2[$i += 1], out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
				}
				out += " ); if (isAdditional" + $lvl + ") { ";
			}
			if ($removeAdditional == "all") out += " delete " + $data + "[" + $key + "]; ";
			else {
				var $currentErrorPath = it.errorPath, $additionalProperty = "' + " + $key + " + '";
				if (it.opts._errorDataPathProperty && (it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers)), $noAdditional) if ($removeAdditional) out += " delete " + $data + "[" + $key + "]; ";
				else {
					out += " " + $nextValid + " = false; ";
					var $currErrSchemaPath = $errSchemaPath;
					$errSchemaPath = it.errSchemaPath + "/additionalProperties";
					var $$outStack = $$outStack || [];
					$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ", it.opts.messages !== !1 && (out += " , message: '", it.opts._errorDataPathProperty ? out += "is an invalid additional property" : out += "should NOT have additional properties", out += "' "), it.opts.verbose && (out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
					var __err = out;
					out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", $errSchemaPath = $currErrSchemaPath, $breakOnError && (out += " break; ");
				}
				else if ($additionalIsSchema) if ($removeAdditional == "failing") {
					out += " var " + $errs + " = errors;  ";
					var $wasComposite = it.compositeRule;
					it.compositeRule = $it.compositeRule = !0, $it.schema = $aProperties, $it.schemaPath = it.schemaPath + ".additionalProperties", $it.errSchemaPath = it.errSchemaPath + "/additionalProperties", $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
					var $passData = $data + "[" + $key + "]";
					$it.dataPathArr[$dataNxt] = $key;
					var $code = it.validate($it);
					$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ", it.compositeRule = $it.compositeRule = $wasComposite;
				} else {
					$it.schema = $aProperties, $it.schemaPath = it.schemaPath + ".additionalProperties", $it.errSchemaPath = it.errSchemaPath + "/additionalProperties", $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
					var $passData = $data + "[" + $key + "]";
					$it.dataPathArr[$dataNxt] = $key;
					var $code = it.validate($it);
					$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", $breakOnError && (out += " if (!" + $nextValid + ") break; ");
				}
				it.errorPath = $currentErrorPath;
			}
			$someProperties && (out += " } "), out += " }  ", $breakOnError && (out += " if (" + $nextValid + ") { ", $closingBraces += "}");
		}
		var $useDefaults = it.opts.useDefaults && !it.compositeRule;
		if ($schemaKeys.length) {
			var arr3 = $schemaKeys;
			if (arr3) for (var $propertyKey, i3 = -1, l3 = arr3.length - 1; i3 < l3;) {
				$propertyKey = arr3[i3 += 1];
				var $sch = $schema[$propertyKey];
				if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === !1 : it.util.schemaHasRules($sch, it.RULES.all)) {
					var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
					$it.schema = $sch, $it.schemaPath = $schemaPath + $prop, $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey), $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers), $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
					var $code = it.validate($it);
					if ($it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2) {
						$code = it.util.varReplace($code, $nextData, $passData);
						var $useData = $passData;
					} else {
						var $useData = $nextData;
						out += " var " + $nextData + " = " + $passData + "; ";
					}
					if ($hasDefault) out += " " + $code + " ";
					else {
						if ($requiredHash && $requiredHash[$propertyKey]) {
							out += " if ( " + $useData + " === undefined ", $ownProperties && (out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') "), out += ") { " + $nextValid + " = false; ";
							var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
							it.opts._errorDataPathProperty && (it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers)), $errSchemaPath = it.errSchemaPath + "/required";
							var $$outStack = $$outStack || [];
							$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ", it.opts.messages !== !1 && (out += " , message: '", it.opts._errorDataPathProperty ? out += "is a required property" : out += "should have required property \\'" + $missingProperty + "\\'", out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
							var __err = out;
							out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", $errSchemaPath = $currErrSchemaPath, it.errorPath = $currentErrorPath, out += " } else { ";
						} else $breakOnError ? (out += " if ( " + $useData + " === undefined ", $ownProperties && (out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') "), out += ") { " + $nextValid + " = true; } else { ") : (out += " if (" + $useData + " !== undefined ", $ownProperties && (out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') "), out += " ) { ");
						out += " " + $code + " } ";
					}
				}
				$breakOnError && (out += " if (" + $nextValid + ") { ", $closingBraces += "}");
			}
		}
		if ($pPropertyKeys.length) {
			var arr4 = $pPropertyKeys;
			if (arr4) for (var $pProperty, i4 = -1, l4 = arr4.length - 1; i4 < l4;) {
				$pProperty = arr4[i4 += 1];
				var $sch = $pProperties[$pProperty];
				if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === !1 : it.util.schemaHasRules($sch, it.RULES.all)) {
					$it.schema = $sch, $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty), $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty), $ownProperties ? out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; " : out += " for (var " + $key + " in " + $data + ") { ", out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ", $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
					var $passData = $data + "[" + $key + "]";
					$it.dataPathArr[$dataNxt] = $key;
					var $code = it.validate($it);
					$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", $breakOnError && (out += " if (!" + $nextValid + ") break; "), out += " } ", $breakOnError && (out += " else " + $nextValid + " = true; "), out += " }  ", $breakOnError && (out += " if (" + $nextValid + ") { ", $closingBraces += "}");
				}
			}
		}
		return $breakOnError && (out += " " + $closingBraces + " if (" + $errs + " == errors) {"), out;
	};
})), require_propertyNames = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		if (out += "var " + $errs + " = errors;", it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === !1 : it.util.schemaHasRules($schema, it.RULES.all)) {
			$it.schema = $schema, $it.schemaPath = $schemaPath, $it.errSchemaPath = $errSchemaPath;
			var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $nextData = "data" + ($it.dataLevel = it.dataLevel + 1), $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
			$ownProperties && (out += " var " + $dataProperties + " = undefined; "), $ownProperties ? out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; " : out += " for (var " + $key + " in " + $data + ") { ", out += " var startErrs" + $lvl + " = errors; ";
			var $passData = $key, $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = !0;
			var $code = it.validate($it);
			$it.baseId = $currentBaseId, it.util.varOccurences($code, $nextData) < 2 ? out += " " + it.util.varReplace($code, $nextData, $passData) + " " : out += " var " + $nextData + " = " + $passData + "; " + $code + " ", it.compositeRule = $it.compositeRule = $wasComposite, out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ", it.opts.messages !== !1 && (out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !it.compositeRule && $breakOnError && (it.async ? out += " throw new ValidationError(vErrors); " : out += " validate.errors = vErrors; return false; "), $breakOnError && (out += " break; "), out += " } }";
		}
		return $breakOnError && (out += " " + $closingBraces + " if (" + $errs + " == errors) {"), out;
	};
})), require_required = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_required(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $isData = it.opts.$data && $schema && $schema.$data;
		$isData && (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", "" + $lvl);
		var $vSchema = "schema" + $lvl;
		if (!$isData) if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
			var $required = [], arr1 = $schema;
			if (arr1) for (var $property, i1 = -1, l1 = arr1.length - 1; i1 < l1;) {
				$property = arr1[i1 += 1];
				var $propertySch = it.schema.properties[$property];
				$propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === !1 : it.util.schemaHasRules($propertySch, it.RULES.all)) || ($required[$required.length] = $property);
			}
		} else var $required = $schema;
		if ($isData || $required.length) {
			var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
			if ($breakOnError) if (out += " var missing" + $lvl + "; ", $loopRequired) {
				$isData || (out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ");
				var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
				it.opts._errorDataPathProperty && (it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers)), out += " var " + $valid + " = true; ", $isData && (out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {"), out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ", $ownProperties && (out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) "), out += "; if (!" + $valid + ") break; } ", $isData && (out += "  }  "), out += "  if (!" + $valid + ") {   ";
				var $$outStack = $$outStack || [];
				$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ", it.opts.messages !== !1 && (out += " , message: '", it.opts._errorDataPathProperty ? out += "is a required property" : out += "should have required property \\'" + $missingProperty + "\\'", out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
				var __err = out;
				out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } else { ";
			} else {
				out += " if ( ";
				var arr2 = $required;
				if (arr2) for (var $propertyKey, $i = -1, l2 = arr2.length - 1; $i < l2;) {
					$propertyKey = arr2[$i += 1], $i && (out += " || ");
					var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
					out += " ( ( " + $useData + " === undefined ", $ownProperties && (out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') "), out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
				}
				out += ") {  ";
				var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
				it.opts._errorDataPathProperty && (it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, !0) : $currentErrorPath + " + " + $propertyPath);
				var $$outStack = $$outStack || [];
				$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ", it.opts.messages !== !1 && (out += " , message: '", it.opts._errorDataPathProperty ? out += "is a required property" : out += "should have required property \\'" + $missingProperty + "\\'", out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
				var __err = out;
				out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } else { ";
			}
			else if ($loopRequired) {
				$isData || (out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ");
				var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
				it.opts._errorDataPathProperty && (it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers)), $isData && (out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ", it.opts.messages !== !1 && (out += " , message: '", it.opts._errorDataPathProperty ? out += "is a required property" : out += "should have required property \\'" + $missingProperty + "\\'", out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { "), out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ", $ownProperties && (out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) "), out += ") {  var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ", it.opts.messages !== !1 && (out += " , message: '", it.opts._errorDataPathProperty ? out += "is a required property" : out += "should have required property \\'" + $missingProperty + "\\'", out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", $isData && (out += "  }  ");
			} else {
				var arr3 = $required;
				if (arr3) for (var $propertyKey, i3 = -1, l3 = arr3.length - 1; i3 < l3;) {
					$propertyKey = arr3[i3 += 1];
					var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
					it.opts._errorDataPathProperty && (it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers)), out += " if ( " + $useData + " === undefined ", $ownProperties && (out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') "), out += ") {  var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ", it.opts.messages !== !1 && (out += " , message: '", it.opts._errorDataPathProperty ? out += "is a required property" : out += "should have required property \\'" + $missingProperty + "\\'", out += "' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
				}
			}
			it.errorPath = $currentErrorPath;
		} else $breakOnError && (out += " if (true) {");
		return out;
	};
})), require_uniqueItems = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema, ($schema || $isData) && it.opts.uniqueItems !== !1) {
			$isData && (out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { "), out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
			var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
			if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
			else {
				out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
				var $method = "checkDataType" + ($typeIsArray ? "s" : "");
				out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, !0) + ") continue; ", $typeIsArray && (out += " if (typeof item == 'string') item = '\"' + item; "), out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
			}
			out += " } ", $isData && (out += "  }  "), out += " if (!" + $valid + ") {   ";
			var $$outStack = $$outStack || [];
			$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ", it.opts.messages !== !1 && (out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), it.opts.verbose && (out += " , schema:  ", $isData ? out += "validate.schema" + $schemaPath : out += "" + $schema, out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
			var __err = out;
			out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", out += " } ", $breakOnError && (out += " else { ");
		} else $breakOnError && (out += " if (true) { ");
		return out;
	};
})), require_dotjs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		$ref: require_ref(),
		allOf: require_allOf(),
		anyOf: require_anyOf(),
		$comment: require_comment(),
		const: require_const(),
		contains: require_contains(),
		dependencies: require_dependencies(),
		enum: require_enum(),
		format: require_format(),
		if: require_if(),
		items: require_items(),
		maximum: require__limit(),
		minimum: require__limit(),
		maxItems: require__limitItems(),
		minItems: require__limitItems(),
		maxLength: require__limitLength(),
		minLength: require__limitLength(),
		maxProperties: require__limitProperties(),
		minProperties: require__limitProperties(),
		multipleOf: require_multipleOf(),
		not: require_not(),
		oneOf: require_oneOf(),
		pattern: require_pattern(),
		properties: require_properties(),
		propertyNames: require_propertyNames(),
		required: require_required(),
		uniqueItems: require_uniqueItems(),
		validate: require_validate()
	};
})), require_rules = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ruleModules = require_dotjs(), toHash = require_util().toHash;
	module.exports = function rules() {
		var RULES = [
			{
				type: "number",
				rules: [
					{ maximum: ["exclusiveMaximum"] },
					{ minimum: ["exclusiveMinimum"] },
					"multipleOf",
					"format"
				]
			},
			{
				type: "string",
				rules: [
					"maxLength",
					"minLength",
					"pattern",
					"format"
				]
			},
			{
				type: "array",
				rules: [
					"maxItems",
					"minItems",
					"items",
					"contains",
					"uniqueItems"
				]
			},
			{
				type: "object",
				rules: [
					"maxProperties",
					"minProperties",
					"required",
					"dependencies",
					"propertyNames",
					{ properties: ["additionalProperties", "patternProperties"] }
				]
			},
			{ rules: [
				"$ref",
				"const",
				"enum",
				"not",
				"anyOf",
				"oneOf",
				"allOf",
				"if"
			] }
		], ALL = ["type", "$comment"];
		return RULES.all = toHash(ALL), RULES.types = toHash([
			"number",
			"integer",
			"string",
			"array",
			"object",
			"boolean",
			"null"
		]), RULES.forEach(function(group) {
			group.rules = group.rules.map(function(keyword) {
				var implKeywords;
				if (typeof keyword == "object") {
					var key = Object.keys(keyword)[0];
					implKeywords = keyword[key], keyword = key, implKeywords.forEach(function(k) {
						ALL.push(k), RULES.all[k] = !0;
					});
				}
				return ALL.push(keyword), RULES.all[keyword] = {
					keyword,
					code: ruleModules[keyword],
					implements: implKeywords
				};
			}), RULES.all.$comment = {
				keyword: "$comment",
				code: ruleModules.$comment
			}, group.type && (RULES.types[group.type] = group);
		}), RULES.keywords = toHash(ALL.concat([
			"$schema",
			"$id",
			"id",
			"$data",
			"$async",
			"title",
			"description",
			"default",
			"definitions",
			"examples",
			"readOnly",
			"writeOnly",
			"contentMediaType",
			"contentEncoding",
			"additionalItems",
			"then",
			"else"
		])), RULES.custom = {}, RULES;
	};
})), require_data$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var KEYWORDS = [
		"multipleOf",
		"maximum",
		"exclusiveMaximum",
		"minimum",
		"exclusiveMinimum",
		"maxLength",
		"minLength",
		"pattern",
		"additionalItems",
		"maxItems",
		"minItems",
		"uniqueItems",
		"maxProperties",
		"minProperties",
		"required",
		"additionalProperties",
		"enum",
		"format",
		"const"
	];
	module.exports = function(metaSchema, keywordsJsonPointers) {
		for (var i = 0; i < keywordsJsonPointers.length; i++) {
			metaSchema = JSON.parse(JSON.stringify(metaSchema));
			var segments = keywordsJsonPointers[i].split("/"), keywords = metaSchema, j;
			for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];
			for (j = 0; j < KEYWORDS.length; j++) {
				var key = KEYWORDS[j], schema = keywords[key];
				schema && (keywords[key] = { anyOf: [schema, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] });
			}
		}
		return metaSchema;
	};
})), require_async = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MissingRefError = require_error_classes().MissingRef;
	module.exports = compileAsync;
	function compileAsync(schema, meta, callback) {
		var self = this;
		if (typeof this._opts.loadSchema != "function") throw Error("options.loadSchema should be a function");
		typeof meta == "function" && (callback = meta, meta = void 0);
		var p = loadMetaSchemaOf(schema).then(function() {
			var schemaObj = self._addSchema(schema, void 0, meta);
			return schemaObj.validate || _compileAsync(schemaObj);
		});
		return callback && p.then(function(v) {
			callback(null, v);
		}, callback), p;
		function loadMetaSchemaOf(sch) {
			var $schema = sch.$schema;
			return $schema && !self.getSchema($schema) ? compileAsync.call(self, { $ref: $schema }, !0) : Promise.resolve();
		}
		function _compileAsync(schemaObj) {
			try {
				return self._compile(schemaObj);
			} catch (e) {
				if (e instanceof MissingRefError) return loadMissingSchema(e);
				throw e;
			}
			function loadMissingSchema(e) {
				var ref = e.missingSchema;
				if (added(ref)) throw Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
				var schemaPromise = self._loadingSchemas[ref];
				return schemaPromise || (schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref), schemaPromise.then(removePromise, removePromise)), schemaPromise.then(function(sch) {
					if (!added(ref)) return loadMetaSchemaOf(sch).then(function() {
						added(ref) || self.addSchema(sch, ref, void 0, meta);
					});
				}).then(function() {
					return _compileAsync(schemaObj);
				});
				function removePromise() {
					delete self._loadingSchemas[ref];
				}
				function added(ref) {
					return self._refs[ref] || self._schemas[ref];
				}
			}
		}
	}
})), require_custom = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function generate_custom(it, $keyword, $ruleType) {
		var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $errorKeyword, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $errs = "errs__" + $lvl, $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		$isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", $schemaValue = "schema" + $lvl) : $schemaValue = $schema;
		var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "", $compile, $inline, $macro, $ruleValidate, $validateCode;
		if ($isData && $rDef.$data) {
			$validateCode = "keywordValidate" + $lvl;
			var $validateSchema = $rDef.validateSchema;
			out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
		} else {
			if ($ruleValidate = it.useCustomRule($rule, $schema, it.schema, it), !$ruleValidate) return;
			$schemaValue = "validate.schema" + $schemaPath, $validateCode = $ruleValidate.code, $compile = $rDef.compile, $inline = $rDef.inline, $macro = $rDef.macro;
		}
		var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
		if ($asyncKeyword && !it.async) throw Error("async keyword in sync schema");
		if ($inline || $macro || (out += "" + $ruleErrs + " = null;"), out += "var " + $errs + " = errors;var " + $valid + ";", $isData && $rDef.$data && ($closingBraces += "}", out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ", $validateSchema && ($closingBraces += "}", out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ")), $inline) $rDef.statements ? out += " " + $ruleValidate.validate + " " : out += " " + $valid + " = " + $ruleValidate.validate + "; ";
		else if ($macro) {
			var $it = it.util.copy(it), $closingBraces = "";
			$it.level++;
			var $nextValid = "valid" + $it.level;
			$it.schema = $ruleValidate.validate, $it.schemaPath = "";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = !0;
			var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
			it.compositeRule = $it.compositeRule = $wasComposite, out += " " + $code;
		} else {
			var $$outStack = $$outStack || [];
			$$outStack.push(out), out = "", out += "  " + $validateCode + ".call( ", it.opts.passContext ? out += "this" : out += "self", $compile || $rDef.schema === !1 ? out += " , " + $data + " " : out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ", out += " , (dataPath || '')", it.errorPath != "\"\"" && (out += " + " + it.errorPath);
			var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
			out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
			var def_callRuleValidate = out;
			out = $$outStack.pop(), $rDef.errors === !1 ? (out += " " + $valid + " = ", $asyncKeyword && (out += "await "), out += "" + def_callRuleValidate + "; ") : $asyncKeyword ? ($ruleErrs = "customErrors" + $lvl, out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ") : out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
		}
		if ($rDef.modifying && (out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];"), out += "" + $closingBraces, $rDef.valid) $breakOnError && (out += " if (true) { ");
		else {
			out += " if ( ", $rDef.valid === void 0 ? (out += " !", $macro ? out += "" + $nextValid : out += "" + $valid) : out += " " + !$rDef.valid + " ", out += ") { ", $errorKeyword = $rule.keyword;
			var $$outStack = $$outStack || [];
			$$outStack.push(out), out = "";
			var $$outStack = $$outStack || [];
			$$outStack.push(out), out = "", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ", it.opts.messages !== !1 && (out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } ");
			var __err = out;
			out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			var def_customError = out;
			out = $$outStack.pop(), $inline ? $rDef.errors ? $rDef.errors != "full" && (out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + ".schemaPath = \"" + $errSchemaPath + "\"; } ", it.opts.verbose && (out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; "), out += " } ") : $rDef.errors === !1 ? out += " " + def_customError + " " : (out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + ".schemaPath = \"" + $errSchemaPath + "\"; } ", it.opts.verbose && (out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; "), out += " } } ") : $macro ? (out += "   var err =   ", it.createErrors === !1 ? out += " {} " : (out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ", it.opts.messages !== !1 && (out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' "), it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), out += " } "), out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !it.compositeRule && $breakOnError && (it.async ? out += " throw new ValidationError(vErrors); " : out += " validate.errors = vErrors; return false; ")) : $rDef.errors === !1 ? out += " " + def_customError + " " : (out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + ".schemaPath = \"" + $errSchemaPath + "\";  ", it.opts.verbose && (out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; "), out += " } } else { " + def_customError + " } "), out += " } ", $breakOnError && (out += " else { ");
		}
		return out;
	};
})), require_json_schema_draft_07 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		$schema: "http://json-schema.org/draft-07/schema#",
		$id: "http://json-schema.org/draft-07/schema#",
		title: "Core schema meta-schema",
		definitions: {
			schemaArray: {
				type: "array",
				minItems: 1,
				items: { $ref: "#" }
			},
			nonNegativeInteger: {
				type: "integer",
				minimum: 0
			},
			nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] },
			simpleTypes: { enum: [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			stringArray: {
				type: "array",
				items: { type: "string" },
				uniqueItems: !0,
				default: []
			}
		},
		type: ["object", "boolean"],
		properties: {
			$id: {
				type: "string",
				format: "uri-reference"
			},
			$schema: {
				type: "string",
				format: "uri"
			},
			$ref: {
				type: "string",
				format: "uri-reference"
			},
			$comment: { type: "string" },
			title: { type: "string" },
			description: { type: "string" },
			default: !0,
			readOnly: {
				type: "boolean",
				default: !1
			},
			examples: {
				type: "array",
				items: !0
			},
			multipleOf: {
				type: "number",
				exclusiveMinimum: 0
			},
			maximum: { type: "number" },
			exclusiveMaximum: { type: "number" },
			minimum: { type: "number" },
			exclusiveMinimum: { type: "number" },
			maxLength: { $ref: "#/definitions/nonNegativeInteger" },
			minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
			pattern: {
				type: "string",
				format: "regex"
			},
			additionalItems: { $ref: "#" },
			items: {
				anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
				default: !0
			},
			maxItems: { $ref: "#/definitions/nonNegativeInteger" },
			minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
			uniqueItems: {
				type: "boolean",
				default: !1
			},
			contains: { $ref: "#" },
			maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
			minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
			required: { $ref: "#/definitions/stringArray" },
			additionalProperties: { $ref: "#" },
			definitions: {
				type: "object",
				additionalProperties: { $ref: "#" },
				default: {}
			},
			properties: {
				type: "object",
				additionalProperties: { $ref: "#" },
				default: {}
			},
			patternProperties: {
				type: "object",
				additionalProperties: { $ref: "#" },
				propertyNames: { format: "regex" },
				default: {}
			},
			dependencies: {
				type: "object",
				additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] }
			},
			propertyNames: { $ref: "#" },
			const: !0,
			enum: {
				type: "array",
				items: !0,
				minItems: 1,
				uniqueItems: !0
			},
			type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, {
				type: "array",
				items: { $ref: "#/definitions/simpleTypes" },
				minItems: 1,
				uniqueItems: !0
			}] },
			format: { type: "string" },
			contentMediaType: { type: "string" },
			contentEncoding: { type: "string" },
			if: { $ref: "#" },
			then: { $ref: "#" },
			else: { $ref: "#" },
			allOf: { $ref: "#/definitions/schemaArray" },
			anyOf: { $ref: "#/definitions/schemaArray" },
			oneOf: { $ref: "#/definitions/schemaArray" },
			not: { $ref: "#" }
		},
		default: !0
	};
})), require_definition_schema = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var metaSchema = require_json_schema_draft_07();
	module.exports = {
		$id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
		definitions: { simpleTypes: metaSchema.definitions.simpleTypes },
		type: "object",
		dependencies: {
			schema: ["validate"],
			$data: ["validate"],
			statements: ["inline"],
			valid: { not: { required: ["macro"] } }
		},
		properties: {
			type: metaSchema.properties.type,
			schema: { type: "boolean" },
			statements: { type: "boolean" },
			dependencies: {
				type: "array",
				items: { type: "string" }
			},
			metaSchema: { type: "object" },
			modifying: { type: "boolean" },
			valid: { type: "boolean" },
			$data: { type: "boolean" },
			async: { type: "boolean" },
			errors: { anyOf: [{ type: "boolean" }, { const: "full" }] }
		}
	};
})), require_keyword = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i, customRuleCode = require_custom(), definitionSchema = require_definition_schema();
	module.exports = {
		add: addKeyword,
		get: getKeyword,
		remove: removeKeyword,
		validate: validateKeyword
	};
	function addKeyword(keyword, definition) {
		var RULES = this.RULES;
		if (RULES.keywords[keyword]) throw Error("Keyword " + keyword + " is already defined");
		if (!IDENTIFIER.test(keyword)) throw Error("Keyword " + keyword + " is not a valid identifier");
		if (definition) {
			this.validateKeyword(definition, !0);
			var dataType = definition.type;
			if (Array.isArray(dataType)) for (var i = 0; i < dataType.length; i++) _addRule(keyword, dataType[i], definition);
			else _addRule(keyword, dataType, definition);
			var metaSchema = definition.metaSchema;
			metaSchema && (definition.$data && this._opts.$data && (metaSchema = { anyOf: [metaSchema, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] }), definition.validateSchema = this.compile(metaSchema, !0));
		}
		RULES.keywords[keyword] = RULES.all[keyword] = !0;
		function _addRule(keyword, dataType, definition) {
			for (var ruleGroup, i = 0; i < RULES.length; i++) {
				var rg = RULES[i];
				if (rg.type == dataType) {
					ruleGroup = rg;
					break;
				}
			}
			ruleGroup || (ruleGroup = {
				type: dataType,
				rules: []
			}, RULES.push(ruleGroup));
			var rule = {
				keyword,
				definition,
				custom: !0,
				code: customRuleCode,
				implements: definition.implements
			};
			ruleGroup.rules.push(rule), RULES.custom[keyword] = rule;
		}
		return this;
	}
	function getKeyword(keyword) {
		var rule = this.RULES.custom[keyword];
		return rule ? rule.definition : this.RULES.keywords[keyword] || !1;
	}
	function removeKeyword(keyword) {
		var RULES = this.RULES;
		delete RULES.keywords[keyword], delete RULES.all[keyword], delete RULES.custom[keyword];
		for (var i = 0; i < RULES.length; i++) for (var rules = RULES[i].rules, j = 0; j < rules.length; j++) if (rules[j].keyword == keyword) {
			rules.splice(j, 1);
			break;
		}
		return this;
	}
	function validateKeyword(definition, throwError) {
		validateKeyword.errors = null;
		var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, !0);
		if (v(definition)) return !0;
		if (validateKeyword.errors = v.errors, throwError) throw Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
		return !1;
	}
})), require_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		$schema: "http://json-schema.org/draft-07/schema#",
		$id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		description: "Meta-schema for $data reference (JSON Schema extension proposal)",
		type: "object",
		required: ["$data"],
		properties: { $data: {
			type: "string",
			anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
		} },
		additionalProperties: !1
	};
})), require_ajv = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var compileSchema = require_compile(), resolve = require_resolve(), Cache = require_cache(), SchemaObject = require_schema_obj(), stableStringify = require_fast_json_stable_stringify(), formats = require_formats(), rules = require_rules(), $dataMetaSchema = require_data$1(), util = require_util();
	module.exports = Ajv, Ajv.prototype.validate = validate, Ajv.prototype.compile = compile, Ajv.prototype.addSchema = addSchema, Ajv.prototype.addMetaSchema = addMetaSchema, Ajv.prototype.validateSchema = validateSchema, Ajv.prototype.getSchema = getSchema, Ajv.prototype.removeSchema = removeSchema, Ajv.prototype.addFormat = addFormat, Ajv.prototype.errorsText = errorsText, Ajv.prototype._addSchema = _addSchema, Ajv.prototype._compile = _compile, Ajv.prototype.compileAsync = require_async();
	var customKeyword = require_keyword();
	Ajv.prototype.addKeyword = customKeyword.add, Ajv.prototype.getKeyword = customKeyword.get, Ajv.prototype.removeKeyword = customKeyword.remove, Ajv.prototype.validateKeyword = customKeyword.validate;
	var errorClasses = require_error_classes();
	Ajv.ValidationError = errorClasses.Validation, Ajv.MissingRefError = errorClasses.MissingRef, Ajv.$dataMetaSchema = $dataMetaSchema;
	var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema", META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes",
		"strictDefaults"
	], META_SUPPORT_DATA = ["/properties"];
	function Ajv(opts) {
		if (!(this instanceof Ajv)) return new Ajv(opts);
		opts = this._opts = util.copy(opts) || {}, setLogger(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = formats(opts.format), this._cache = opts.cache || new Cache(), this._loadingSchemas = {}, this._compilations = [], this.RULES = rules(), this._getId = chooseGetId(opts), opts.loopRequired = opts.loopRequired || Infinity, opts.errorDataPath == "property" && (opts._errorDataPathProperty = !0), opts.serialize === void 0 && (opts.serialize = stableStringify), this._metaOpts = getMetaSchemaOptions(this), opts.formats && addInitialFormats(this), opts.keywords && addInitialKeywords(this), addDefaultMetaSchema(this), typeof opts.meta == "object" && this.addMetaSchema(opts.meta), opts.nullable && this.addKeyword("nullable", { metaSchema: { type: "boolean" } }), addInitialSchemas(this);
	}
	function validate(schemaKeyRef, data) {
		var v;
		if (typeof schemaKeyRef == "string") {
			if (v = this.getSchema(schemaKeyRef), !v) throw Error("no schema with key or ref \"" + schemaKeyRef + "\"");
		} else {
			var schemaObj = this._addSchema(schemaKeyRef);
			v = schemaObj.validate || this._compile(schemaObj);
		}
		var valid = v(data);
		return v.$async !== !0 && (this.errors = v.errors), valid;
	}
	function compile(schema, _meta) {
		var schemaObj = this._addSchema(schema, void 0, _meta);
		return schemaObj.validate || this._compile(schemaObj);
	}
	function addSchema(schema, key, _skipValidation, _meta) {
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
			return this;
		}
		var id = this._getId(schema);
		if (id !== void 0 && typeof id != "string") throw Error("schema id must be string");
		return key = resolve.normalizeId(key || id), checkUnique(this, key), this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, !0), this;
	}
	function addMetaSchema(schema, key, skipValidation) {
		return this.addSchema(schema, key, skipValidation, !0), this;
	}
	function validateSchema(schema, throwOrLogError) {
		var $schema = schema.$schema;
		if ($schema !== void 0 && typeof $schema != "string") throw Error("$schema must be a string");
		if ($schema = $schema || this._opts.defaultMeta || defaultMeta(this), !$schema) return this.logger.warn("meta-schema not available"), this.errors = null, !0;
		var valid = this.validate($schema, schema);
		if (!valid && throwOrLogError) {
			var message = "schema is invalid: " + this.errorsText();
			if (this._opts.validateSchema == "log") this.logger.error(message);
			else throw Error(message);
		}
		return valid;
	}
	function defaultMeta(self) {
		var meta = self._opts.meta;
		return self._opts.defaultMeta = typeof meta == "object" ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0, self._opts.defaultMeta;
	}
	function getSchema(keyRef) {
		var schemaObj = _getSchemaObj(this, keyRef);
		switch (typeof schemaObj) {
			case "object": return schemaObj.validate || this._compile(schemaObj);
			case "string": return this.getSchema(schemaObj);
			case "undefined": return _getSchemaFragment(this, keyRef);
		}
	}
	function _getSchemaFragment(self, ref) {
		var res = resolve.schema.call(self, { schema: {} }, ref);
		if (res) {
			var schema = res.schema, root = res.root, baseId = res.baseId, v = compileSchema.call(self, schema, root, void 0, baseId);
			return self._fragments[ref] = new SchemaObject({
				ref,
				fragment: !0,
				schema,
				root,
				baseId,
				validate: v
			}), v;
		}
	}
	function _getSchemaObj(self, keyRef) {
		return keyRef = resolve.normalizeId(keyRef), self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
	}
	function removeSchema(schemaKeyRef) {
		if (schemaKeyRef instanceof RegExp) return _removeAllSchemas(this, this._schemas, schemaKeyRef), _removeAllSchemas(this, this._refs, schemaKeyRef), this;
		switch (typeof schemaKeyRef) {
			case "undefined": return _removeAllSchemas(this, this._schemas), _removeAllSchemas(this, this._refs), this._cache.clear(), this;
			case "string":
				var schemaObj = _getSchemaObj(this, schemaKeyRef);
				return schemaObj && this._cache.del(schemaObj.cacheKey), delete this._schemas[schemaKeyRef], delete this._refs[schemaKeyRef], this;
			case "object":
				var serialize = this._opts.serialize, cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
				this._cache.del(cacheKey);
				var id = this._getId(schemaKeyRef);
				id && (id = resolve.normalizeId(id), delete this._schemas[id], delete this._refs[id]);
		}
		return this;
	}
	function _removeAllSchemas(self, schemas, regex) {
		for (var keyRef in schemas) {
			var schemaObj = schemas[keyRef];
			!schemaObj.meta && (!regex || regex.test(keyRef)) && (self._cache.del(schemaObj.cacheKey), delete schemas[keyRef]);
		}
	}
	function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
		if (typeof schema != "object" && typeof schema != "boolean") throw Error("schema should be object or boolean");
		var serialize = this._opts.serialize, cacheKey = serialize ? serialize(schema) : schema, cached = this._cache.get(cacheKey);
		if (cached) return cached;
		shouldAddSchema ||= this._opts.addUsedSchema !== !1;
		var id = resolve.normalizeId(this._getId(schema));
		id && shouldAddSchema && checkUnique(this, id);
		var willValidate = this._opts.validateSchema !== !1 && !skipValidation, recursiveMeta;
		willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)) && this.validateSchema(schema, !0);
		var schemaObj = new SchemaObject({
			id,
			schema,
			localRefs: resolve.ids.call(this, schema),
			cacheKey,
			meta
		});
		return id[0] != "#" && shouldAddSchema && (this._refs[id] = schemaObj), this._cache.put(cacheKey, schemaObj), willValidate && recursiveMeta && this.validateSchema(schema, !0), schemaObj;
	}
	function _compile(schemaObj, root) {
		if (schemaObj.compiling) return schemaObj.validate = callValidate, callValidate.schema = schemaObj.schema, callValidate.errors = null, callValidate.root = root || callValidate, schemaObj.schema.$async === !0 && (callValidate.$async = !0), callValidate;
		schemaObj.compiling = !0;
		var currentOpts;
		schemaObj.meta && (currentOpts = this._opts, this._opts = this._metaOpts);
		var v;
		try {
			v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
		} catch (e) {
			throw delete schemaObj.validate, e;
		} finally {
			schemaObj.compiling = !1, schemaObj.meta && (this._opts = currentOpts);
		}
		return schemaObj.validate = v, schemaObj.refs = v.refs, schemaObj.refVal = v.refVal, schemaObj.root = v.root, v;
		function callValidate() {
			var _validate = schemaObj.validate, result = _validate.apply(this, arguments);
			return callValidate.errors = _validate.errors, result;
		}
	}
	function chooseGetId(opts) {
		switch (opts.schemaId) {
			case "auto": return _get$IdOrId;
			case "id": return _getId;
			default: return _get$Id;
		}
	}
	function _getId(schema) {
		return schema.$id && this.logger.warn("schema $id ignored", schema.$id), schema.id;
	}
	function _get$Id(schema) {
		return schema.id && this.logger.warn("schema id ignored", schema.id), schema.$id;
	}
	function _get$IdOrId(schema) {
		if (schema.$id && schema.id && schema.$id != schema.id) throw Error("schema $id is different from id");
		return schema.$id || schema.id;
	}
	function errorsText(errors, options) {
		if (errors ||= this.errors, !errors) return "No errors";
		options ||= {};
		for (var separator = options.separator === void 0 ? ", " : options.separator, dataVar = options.dataVar === void 0 ? "data" : options.dataVar, text = "", i = 0; i < errors.length; i++) {
			var e = errors[i];
			e && (text += dataVar + e.dataPath + " " + e.message + separator);
		}
		return text.slice(0, -separator.length);
	}
	function addFormat(name, format) {
		return typeof format == "string" && (format = new RegExp(format)), this._formats[name] = format, this;
	}
	function addDefaultMetaSchema(self) {
		var $dataSchema;
		if (self._opts.$data && ($dataSchema = require_data(), self.addMetaSchema($dataSchema, $dataSchema.$id, !0)), self._opts.meta !== !1) {
			var metaSchema = require_json_schema_draft_07();
			self._opts.$data && (metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA)), self.addMetaSchema(metaSchema, META_SCHEMA_ID, !0), self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		}
	}
	function addInitialSchemas(self) {
		var optsSchemas = self._opts.schemas;
		if (optsSchemas) if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
		else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats(self) {
		for (var name in self._opts.formats) {
			var format = self._opts.formats[name];
			self.addFormat(name, format);
		}
	}
	function addInitialKeywords(self) {
		for (var name in self._opts.keywords) {
			var keyword = self._opts.keywords[name];
			self.addKeyword(name, keyword);
		}
	}
	function checkUnique(self, id) {
		if (self._schemas[id] || self._refs[id]) throw Error("schema with key or id \"" + id + "\" already exists");
	}
	function getMetaSchemaOptions(self) {
		for (var metaOpts = util.copy(self._opts), i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];
		return metaOpts;
	}
	function setLogger(self) {
		var logger = self._opts.logger;
		if (logger === !1) self.logger = {
			log: noop,
			warn: noop,
			error: noop
		};
		else {
			if (logger === void 0 && (logger = console), !(typeof logger == "object" && logger.log && logger.warn && logger.error)) throw Error("logger must implement log, warn and error methods");
			self.logger = logger;
		}
	}
	function noop() {}
})), id = "http://json-schema.org/draft-04/schema#", json_schema_draft_04_default = {
	id,
	$schema: "http://json-schema.org/draft-04/schema#",
	description: "Core schema meta-schema",
	definitions: {
		schemaArray: {
			type: "array",
			minItems: 1,
			items: { $ref: "#" }
		},
		positiveInteger: {
			type: "integer",
			minimum: 0
		},
		positiveIntegerDefault0: { allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }] },
		simpleTypes: { enum: [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		] },
		stringArray: {
			type: "array",
			items: { type: "string" },
			minItems: 1,
			uniqueItems: !0
		}
	},
	type: "object",
	properties: {
		id: { type: "string" },
		$schema: { type: "string" },
		title: { type: "string" },
		description: { type: "string" },
		default: {},
		multipleOf: {
			type: "number",
			minimum: 0,
			exclusiveMinimum: !0
		},
		maximum: { type: "number" },
		exclusiveMaximum: {
			type: "boolean",
			default: !1
		},
		minimum: { type: "number" },
		exclusiveMinimum: {
			type: "boolean",
			default: !1
		},
		maxLength: { $ref: "#/definitions/positiveInteger" },
		minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
		pattern: {
			type: "string",
			format: "regex"
		},
		additionalItems: {
			anyOf: [{ type: "boolean" }, { $ref: "#" }],
			default: {}
		},
		items: {
			anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
			default: {}
		},
		maxItems: { $ref: "#/definitions/positiveInteger" },
		minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
		uniqueItems: {
			type: "boolean",
			default: !1
		},
		maxProperties: { $ref: "#/definitions/positiveInteger" },
		minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
		required: { $ref: "#/definitions/stringArray" },
		additionalProperties: {
			anyOf: [{ type: "boolean" }, { $ref: "#" }],
			default: {}
		},
		definitions: {
			type: "object",
			additionalProperties: { $ref: "#" },
			default: {}
		},
		properties: {
			type: "object",
			additionalProperties: { $ref: "#" },
			default: {}
		},
		patternProperties: {
			type: "object",
			additionalProperties: { $ref: "#" },
			default: {}
		},
		dependencies: {
			type: "object",
			additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] }
		},
		enum: {
			type: "array",
			minItems: 1,
			uniqueItems: !0
		},
		type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, {
			type: "array",
			items: { $ref: "#/definitions/simpleTypes" },
			minItems: 1,
			uniqueItems: !0
		}] },
		format: { type: "string" },
		allOf: { $ref: "#/definitions/schemaArray" },
		anyOf: { $ref: "#/definitions/schemaArray" },
		oneOf: { $ref: "#/definitions/schemaArray" },
		not: { $ref: "#" }
	},
	dependencies: {
		exclusiveMaximum: ["maximum"],
		exclusiveMinimum: ["minimum"]
	},
	default: {}
}, import_ajv = /* @__PURE__ */ __toESM(require_ajv(), 1);
const DEFAULT_OPTIONS = ObjectFreeze([]);
let allOptions = null;
const DEFAULT_OPTIONS_ID = 0, AJV = new import_ajv.default({
	meta: !1,
	useDefaults: !0,
	validateSchema: !1,
	missingRefs: "ignore",
	verbose: !0,
	schemaId: "auto"
});
AJV.addMetaSchema(json_schema_draft_04_default), AJV._opts.defaultMeta = id;
function compileSchema(schema) {
	if (schema == null) return null;
	if (schema === !1) return !1;
	if (typeof schema != "object") throw TypeError("`rule.meta.schema` must be an array, object, or `false` if provided");
	if (ArrayIsArray(schema)) {
		if (schema.length === 0) return null;
		schema = {
			type: "array",
			items: schema,
			minItems: 0,
			maxItems: schema.length
		};
	}
	return wrapSchemaValidator(AJV.compile(schema));
}
function wrapSchemaValidator(validate) {
	return (options, ruleName) => {
		if (validate(options), validate.errors) throw Error(`Options validation failed for rule '${ruleName}':\nOptions:\n${JSONStringify(options, null, 2)}\nErrors:\n` + validate.errors.map((error) => {
			if (error.keyword === "additionalProperties" && error.schema === !1 && typeof error.parentSchema?.properties == "object" && typeof error.params?.additionalProperty == "string") {
				let expectedProperties = ObjectKeys(error.parentSchema.properties).map((property) => `"${property}"`);
				return `\tValue ${JSONStringify(error.data)} ${error.message}.\n\t\tUnexpected property "${error.params.additionalProperty}". Expected properties: ${expectedProperties.join(", ")}.`;
			}
			return `\tValue ${JSONStringify(error.data)} ${error.message}.`;
		}).join("\n"));
	};
}
function setOptions(optionsJson) {
	let details = JSONParse(optionsJson);
	allOptions = details.options;
	let { ruleIds } = details;
	for (let i = 1, len = allOptions.length; i < len; i++) allOptions[i] = processOptions(allOptions[i], registeredRules[ruleIds[i]]);
}
function processOptions(configOptions, ruleDetails) {
	let validator = ruleDetails.optionsSchemaValidator;
	if (validator === null) throw Error(`Rule '${ruleDetails.fullName}' does not accept options`);
	let { defaultOptions } = ruleDetails, options = defaultOptions === DEFAULT_OPTIONS ? configOptions : mergeOptions(configOptions, defaultOptions);
	return validator !== !1 && validator(options, ruleDetails.fullName), deepFreezeJsonArray(options), options;
}
function mergeOptions(configOptions, defaultOptions) {
	let merged = [], defaultOptionsLength = defaultOptions.length, configOptionsLength = configOptions.length, bothLength = MathMin(defaultOptionsLength, configOptionsLength), i = 0;
	for (; i < bothLength; i++) merged.push(mergeValues(configOptions[i], defaultOptions[i]));
	if (defaultOptionsLength > configOptionsLength) for (; i < defaultOptionsLength; i++) merged.push(deepCloneJsonValue(defaultOptions[i]));
	else for (; i < configOptionsLength; i++) merged.push(configOptions[i]);
	return merged;
}
function mergeValues(configValue, defaultValue) {
	if (typeof configValue != "object" || !configValue || ArrayIsArray(configValue) || typeof defaultValue != "object" || !defaultValue || ArrayIsArray(defaultValue)) return configValue;
	for (let key in defaultValue) ObjectHasOwn(configValue, key) ? configValue[key] = mergeValues(configValue[key], defaultValue[key]) : ObjectDefineProperty(configValue, key, {
		value: deepCloneJsonValue(defaultValue[key]),
		writable: !0,
		enumerable: !0,
		configurable: !0
	});
	return configValue;
}
function getErrorMessage(err) {
	try {
		if (err instanceof Error) {
			let { stack } = err;
			if (typeof stack == "string" && stack !== "") return stack;
		}
		let { message } = err;
		if (typeof message == "string" && message !== "") return message;
	} catch {}
	return "Unknown error";
}
const registeredRules = [], neverRunBeforeHook = () => !1;
async function loadPlugin(url, pluginName, pluginNameIsAlias) {
	try {
		let plugin = (await import(url)).default;
		return JSONStringify({ Success: registerPlugin(plugin, pluginName, pluginNameIsAlias) });
	} catch (err) {
		return JSONStringify({ Failure: getErrorMessage(err) });
	}
}
function registerPlugin(plugin, pluginName, pluginNameIsAlias) {
	pluginName = getPluginName(plugin, pluginName, pluginNameIsAlias);
	let offset = registeredRules.length, { rules } = plugin, ruleNames = ObjectKeys(rules), ruleNamesLen = ruleNames.length;
	for (let i = 0; i < ruleNamesLen; i++) {
		let ruleName = ruleNames[i], rule = rules[ruleName], fullRuleName = `${pluginName}/${ruleName}`, isFixable = !1, messages = null, defaultOptions = DEFAULT_OPTIONS, schemaValidator = null, ruleMeta = rule.meta;
		if (ruleMeta != null) {
			if (typeof ruleMeta != "object") throw TypeError("Invalid `rule.meta`");
			let { fixable } = ruleMeta;
			if (fixable != null) {
				if (fixable !== "code" && fixable !== "whitespace") throw TypeError("Invalid `rule.meta.fixable`");
				isFixable = !0;
			}
			schemaValidator = compileSchema(ruleMeta.schema);
			let inputDefaultOptions = ruleMeta.defaultOptions;
			if (inputDefaultOptions != null) {
				if (!ArrayIsArray(inputDefaultOptions)) throw TypeError("`rule.meta.defaultOptions` must be an array if provided");
				if (inputDefaultOptions.length !== 0) {
					if (defaultOptions = conformDefaultOptions(inputDefaultOptions), schemaValidator === null) throw Error(`Rule ${fullRuleName}:\nRules which accept options must provide a schema as \`rule.meta.schema\`, or disable schema validation with \`rule.meta.schema: false\` (not recommended).`);
					schemaValidator !== !1 && schemaValidator(defaultOptions, fullRuleName), deepFreezeJsonArray(defaultOptions);
				}
			}
			let inputMessages = ruleMeta.messages;
			if (inputMessages != null) {
				if (typeof inputMessages != "object") throw TypeError("`rule.meta.messages` must be an object if provided");
				messages = inputMessages;
			}
		}
		let ruleDetails = {
			fullName: fullRuleName,
			rule,
			context: null,
			isFixable,
			messages,
			defaultOptions,
			optionsSchemaValidator: schemaValidator,
			ruleIndex: 0,
			options: null,
			visitor: null,
			beforeHook: null,
			afterHook: null
		}, context = createContext(ruleDetails);
		if (ruleDetails.context = context, "createOnce" in rule) {
			let visitorWithHooks = rule.createOnce(context);
			if (typeof visitorWithHooks != "object" || !visitorWithHooks) throw TypeError("`createOnce` must return an object");
			let { before: beforeHook, after: afterHook, ...visitor } = visitorWithHooks;
			beforeHook = conformHookFn(beforeHook, "before"), afterHook = conformHookFn(afterHook, "after"), ObjectKeys(visitor).length === 0 && (beforeHook = neverRunBeforeHook, afterHook = null), ruleDetails.visitor = visitor, ruleDetails.beforeHook = beforeHook, ruleDetails.afterHook = afterHook;
		}
		registeredRules.push(ruleDetails);
	}
	return {
		name: pluginName,
		offset,
		ruleNames
	};
}
function getPluginName(plugin, pluginName, pluginNameIsAlias) {
	if (pluginNameIsAlias) return pluginName;
	let pluginMetaName = plugin.meta?.name;
	if (pluginMetaName != null) {
		if (typeof pluginMetaName != "string") throw TypeError("`plugin.meta.name` must be a string if defined");
		return normalizePluginName(pluginMetaName);
	}
	if (pluginName !== null) return pluginName;
	throw Error("Plugin must either define `meta.name`, be loaded from an NPM package with a `name` field in `package.json`, or be given an alias in config");
}
function normalizePluginName(name) {
	let slashIndex = name.indexOf("/");
	if (slashIndex === -1) return name.startsWith("eslint-plugin-") ? name.slice(14) : name;
	let scope = name.slice(0, slashIndex), rest = name.slice(slashIndex + 1);
	return rest === "eslint-plugin" ? scope : rest.startsWith("eslint-plugin-") ? `${scope}/${rest.slice(14)}` : name;
}
function conformDefaultOptions(defaultOptions) {
	let json, containsInfinity = !1;
	try {
		json = JSONStringify(defaultOptions, (key, value) => value === Infinity || value === -Infinity ? (containsInfinity = !0, value === Infinity ? POS_INFINITY_PLACEHOLDER : NEG_INFINITY_PLACEHOLDER) : value);
	} catch (err) {
		throw Error(`\`rule.meta.defaultOptions\` must be JSON-serializable: ${getErrorMessage(err)}`);
	}
	if (containsInfinity) {
		let plainJson = JSONStringify(defaultOptions);
		if (plainJson.includes(POS_INFINITY_PLACEHOLDER) || plainJson.includes(NEG_INFINITY_PLACEHOLDER)) throw Error(`\`rule.meta.defaultOptions\` cannot contain the strings "${POS_INFINITY_PLACEHOLDER}" or "${NEG_INFINITY_PLACEHOLDER}"`);
		json = json.replaceAll(POS_INFINITY_PLACEHOLDER_STR, "1e+400").replaceAll(NEG_INFINITY_PLACEHOLDER_STR, "-1e+400");
	}
	return JSONParse(json);
}
const POS_INFINITY_PLACEHOLDER = "$_$_$_POS_INFINITY_$_$_$", NEG_INFINITY_PLACEHOLDER = "$_$_$_NEG_INFINITY_$_$_$", POS_INFINITY_PLACEHOLDER_STR = JSONStringify(POS_INFINITY_PLACEHOLDER), NEG_INFINITY_PLACEHOLDER_STR = JSONStringify(NEG_INFINITY_PLACEHOLDER);
function conformHookFn(hookFn, hookName) {
	if (hookFn == null) return null;
	if (typeof hookFn != "function") throw TypeError(`\`${hookName}\` hook must be a function if provided`);
	return hookFn;
}
var require_assert = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function ok(value, message = "Assertion failed.") {
		if (!value) throw Error(message);
	}
	module.exports = ok;
})), require_ast_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u, lineBreakPattern = /\r\n|[\r\n\u2028\u2029]/u, shebangPattern = /^#!([^\r\n]+)/u;
	function createGlobalLinebreakMatcher() {
		return new RegExp(lineBreakPattern.source, "gu");
	}
	module.exports = {
		breakableTypePattern,
		lineBreakPattern,
		createGlobalLinebreakMatcher,
		shebangPattern
	};
})), require_ms = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25;
	module.exports = function(val, options) {
		options ||= {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	function parse(str) {
		if (str = String(str), !(str.length > 100)) {
			var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
			if (match) {
				var n = parseFloat(match[1]);
				switch ((match[2] || "ms").toLowerCase()) {
					case "years":
					case "year":
					case "yrs":
					case "yr":
					case "y": return n * y;
					case "weeks":
					case "week":
					case "w": return n * w;
					case "days":
					case "day":
					case "d": return n * d;
					case "hours":
					case "hour":
					case "hrs":
					case "hr":
					case "h": return n * h;
					case "minutes":
					case "minute":
					case "mins":
					case "min":
					case "m": return n * m;
					case "seconds":
					case "second":
					case "secs":
					case "sec":
					case "s": return n * s;
					case "milliseconds":
					case "millisecond":
					case "msecs":
					case "msec":
					case "ms": return n;
					default: return;
				}
			}
		}
	}
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		return msAbs >= d ? Math.round(ms / d) + "d" : msAbs >= h ? Math.round(ms / h) + "h" : msAbs >= m ? Math.round(ms / m) + "m" : msAbs >= s ? Math.round(ms / s) + "s" : ms + "ms";
	}
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		return msAbs >= d ? plural(ms, msAbs, d, "day") : msAbs >= h ? plural(ms, msAbs, h, "hour") : msAbs >= m ? plural(ms, msAbs, m, "minute") : msAbs >= s ? plural(ms, msAbs, s, "second") : ms + " ms";
	}
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
})), require_common = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setup(env) {
		createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = require_ms(), createDebug.destroy = destroy, Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		}), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		function createDebug(namespace) {
			let prevTime, enableOverride = null, namespacesCache, enabledCache;
			function debug(...args) {
				if (!debug.enabled) return;
				let self = debug, curr = Number(/* @__PURE__ */ new Date());
				self.diff = curr - (prevTime || curr), self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index++;
					let formatter = createDebug.formatters[format];
					if (typeof formatter == "function") {
						let val = args[index];
						match = formatter.call(self, val), args.splice(index, 1), index--;
					}
					return match;
				}), createDebug.formatArgs.call(self, args), (self.log || createDebug.log).apply(self, args);
			}
			return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
				enumerable: !0,
				configurable: !1,
				get: () => enableOverride === null ? (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache) : enableOverride,
				set: (v) => {
					enableOverride = v;
				}
			}), typeof createDebug.init == "function" && createDebug.init(debug), debug;
		}
		function extend(namespace, delimiter) {
			let newDebug = createDebug(this.namespace + (delimiter === void 0 ? ":" : delimiter) + namespace);
			return newDebug.log = this.log, newDebug;
		}
		function enable(namespaces) {
			createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
			let split = (typeof namespaces == "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (let ns of split) ns[0] === "-" ? createDebug.skips.push(ns.slice(1)) : createDebug.names.push(ns);
		}
		function matchesTemplate(search, template) {
			let searchIndex = 0, templateIndex = 0, starIndex = -1, matchIndex = 0;
			for (; searchIndex < search.length;) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) template[templateIndex] === "*" ? (starIndex = templateIndex, matchIndex = searchIndex, templateIndex++) : (searchIndex++, templateIndex++);
			else if (starIndex !== -1) templateIndex = starIndex + 1, matchIndex++, searchIndex = matchIndex;
			else return !1;
			for (; templateIndex < template.length && template[templateIndex] === "*";) templateIndex++;
			return templateIndex === template.length;
		}
		function disable() {
			let namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			return createDebug.enable(""), namespaces;
		}
		function enabled(name) {
			for (let skip of createDebug.skips) if (matchesTemplate(name, skip)) return !1;
			for (let ns of createDebug.names) if (matchesTemplate(name, ns)) return !0;
			return !1;
		}
		function coerce(val) {
			return val instanceof Error ? val.stack || val.message : val;
		}
		function destroy() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		return createDebug.enable(createDebug.load()), createDebug;
	}
	module.exports = setup;
})), require_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	exports.formatArgs = formatArgs, exports.save = save, exports.load = load, exports.useColors = useColors, exports.storage = localstorage(), exports.destroy = (() => {
		let warned = !1;
		return () => {
			warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
		};
	})(), exports.colors = /* @__PURE__ */ "#0000CC.#0000FF.#0033CC.#0033FF.#0066CC.#0066FF.#0099CC.#0099FF.#00CC00.#00CC33.#00CC66.#00CC99.#00CCCC.#00CCFF.#3300CC.#3300FF.#3333CC.#3333FF.#3366CC.#3366FF.#3399CC.#3399FF.#33CC00.#33CC33.#33CC66.#33CC99.#33CCCC.#33CCFF.#6600CC.#6600FF.#6633CC.#6633FF.#66CC00.#66CC33.#9900CC.#9900FF.#9933CC.#9933FF.#99CC00.#99CC33.#CC0000.#CC0033.#CC0066.#CC0099.#CC00CC.#CC00FF.#CC3300.#CC3333.#CC3366.#CC3399.#CC33CC.#CC33FF.#CC6600.#CC6633.#CC9900.#CC9933.#CCCC00.#CCCC33.#FF0000.#FF0033.#FF0066.#FF0099.#FF00CC.#FF00FF.#FF3300.#FF3333.#FF3366.#FF3399.#FF33CC.#FF33FF.#FF6600.#FF6633.#FF9900.#FF9933.#FFCC00.#FFCC33".split(".");
	function useColors() {
		if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
		if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
		let m;
		return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	function formatArgs(args) {
		if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), !this.useColors) return;
		let c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0, lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			match !== "%%" && (index++, match === "%c" && (lastC = index));
		}), args.splice(lastC, 0, c);
	}
	exports.log = console.debug || console.log || (() => {});
	function save(namespaces) {
		try {
			namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
		} catch {}
	}
	function load() {
		let r;
		try {
			r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch {}
		return !r && typeof process < "u" && "env" in process && (r = process.env.DEBUG), r;
	}
	function localstorage() {
		try {
			return localStorage;
		} catch {}
	}
	module.exports = require_common()(exports);
	let { formatters } = module.exports;
	formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
})), require_has_flag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = (flag, argv = process.argv) => {
		let prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
})), require_supports_color = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let os = __require("os"), tty$1 = __require("tty"), hasFlag = require_has_flag(), { env } = process, flagForceColor;
	hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? flagForceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (flagForceColor = 1);
	function envForceColor() {
		if ("FORCE_COLOR" in env) return env.FORCE_COLOR === "true" ? 1 : env.FORCE_COLOR === "false" ? 0 : env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
	function translateLevel(level) {
		return level === 0 ? !1 : {
			level,
			hasBasic: !0,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor(haveStream, { streamIsTTY, sniffFlags = !0 } = {}) {
		let noFlagForceColor = envForceColor();
		noFlagForceColor !== void 0 && (flagForceColor = noFlagForceColor);
		let forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
		if (forceColor === 0) return 0;
		if (sniffFlags) {
			if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
			if (hasFlag("color=256")) return 2;
		}
		if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
		let min = forceColor || 0;
		if (env.TERM === "dumb") return min;
		if (process.platform === "win32") {
			let osRelease = os.release().split(".");
			return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
		}
		if ("CI" in env) return [
			"TRAVIS",
			"CIRCLECI",
			"APPVEYOR",
			"GITLAB_CI",
			"GITHUB_ACTIONS",
			"BUILDKITE",
			"DRONE"
		].some((sign) => sign in env) || env.CI_NAME === "codeship" ? 1 : min;
		if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		if (env.COLORTERM === "truecolor") return 3;
		if ("TERM_PROGRAM" in env) {
			let version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env.TERM_PROGRAM) {
				case "iTerm.app": return version >= 3 ? 3 : 2;
				case "Apple_Terminal": return 2;
			}
		}
		return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
	}
	function getSupportLevel(stream, options = {}) {
		return translateLevel(supportsColor(stream, {
			streamIsTTY: stream && stream.isTTY,
			...options
		}));
	}
	module.exports = {
		supportsColor: getSupportLevel,
		stdout: getSupportLevel({ isTTY: tty$1.isatty(1) }),
		stderr: getSupportLevel({ isTTY: tty$1.isatty(2) })
	};
})), require_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let tty = __require("tty"), util = __require("util");
	exports.init = init, exports.log = log, exports.formatArgs = formatArgs, exports.save = save, exports.load = load, exports.useColors = useColors, exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		let supportsColor = require_supports_color();
		supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		]);
	} catch {}
	exports.inspectOpts = Object.keys(process.env).filter((key) => /^debug_/i.test(key)).reduce((obj, key) => {
		let prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase()), val = process.env[key];
		return val = /^(yes|on|true|enabled)$/i.test(val) ? !0 : /^(no|off|false|disabled)$/i.test(val) ? !1 : val === "null" ? null : Number(val), obj[prop] = val, obj;
	}, {});
	function useColors() {
		return "colors" in exports.inspectOpts ? !!exports.inspectOpts.colors : tty.isatty(process.stderr.fd);
	}
	function formatArgs(args) {
		let { namespace: name, useColors } = this;
		if (useColors) {
			let c = this.color, colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix), args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		return exports.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	function log(...args) {
		return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	function save(namespaces) {
		namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
	}
	function load() {
		return process.env.DEBUG;
	}
	function init(debug) {
		debug.inspectOpts = {};
		let keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	module.exports = require_common()(exports);
	let { formatters } = module.exports;
	formatters.o = function(v) {
		return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	}, formatters.O = function(v) {
		return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
	};
})), require_src = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? module.exports = require_browser() : module.exports = require_node();
})), require_debug_helpers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let debug = require_src()("eslint:code-path");
	/* c8 ignore next */
	function getId(segment) {
		return segment.id + (segment.reachable ? "" : "!");
	}
	function nodeToString(node, label) {
		let suffix = label ? `:${label}` : "";
		switch (node.type) {
			case "Identifier": return `${node.type}${suffix} (${node.name})`;
			case "Literal": return `${node.type}${suffix} (${node.value})`;
			default: return `${node.type}${suffix}`;
		}
	}
	module.exports = {
		enabled: debug.enabled,
		dump: debug,
		dumpState: debug.enabled ? function(node, state, leaving) {
			for (let i = 0; i < state.currentSegments.length; ++i) {
				let segInternal = state.currentSegments[i].internal;
				if (leaving) {
					let last = segInternal.nodes.length - 1;
					last >= 0 && segInternal.nodes[last] === nodeToString(node, "enter") ? segInternal.nodes[last] = nodeToString(node, void 0) : segInternal.nodes.push(nodeToString(node, "exit"));
				} else segInternal.nodes.push(nodeToString(node, "enter"));
			}
			debug([`${state.currentSegments.map(getId).join(",")})`, `${node.type}${leaving ? ":exit" : ""}`].join(" "));
		} : debug,
		dumpDot: debug.enabled ? function(codePath) {
			let text = "\ndigraph {\nnode[shape=box,style=\"rounded,filled\",fillcolor=white];\ninitial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
			codePath.returnedSegments.length > 0 && (text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n"), codePath.thrownSegments.length > 0 && (text += "thrown[label=\"\",shape=circle,width=0.3,height=0.3,fixedsize=true];\n");
			let traceMap = Object.create(null), arrows = this.makeDotArrows(codePath, traceMap);
			for (let id in traceMap) {
				let segment = traceMap[id];
				text += `${id}[`, segment.reachable ? text += "label=\"" : text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n", segment.internal.nodes.length > 0 ? text += segment.internal.nodes.join("\\n") : text += "????", text += "\"];\n";
			}
			text += `${arrows}\n`, text += "}", debug("DOT", text);
		} : debug,
		makeDotArrows(codePath, traceMap) {
			let stack = [[codePath.initialSegment, 0]], done = traceMap || Object.create(null), lastId = codePath.initialSegment.id, text = `initial->${codePath.initialSegment.id}`;
			for (; stack.length > 0;) {
				let item = stack.pop(), segment = item[0], index = item[1];
				if (done[segment.id] && index === 0) continue;
				done[segment.id] = segment;
				let nextSegment = segment.allNextSegments[index];
				nextSegment && (lastId === segment.id ? text += `->${nextSegment.id}` : text += `;\n${segment.id}->${nextSegment.id}`, lastId = nextSegment.id, stack.unshift([segment, 1 + index]), stack.push([nextSegment, 0]));
			}
			return codePath.returnedSegments.forEach((finalSegment) => {
				lastId === finalSegment.id ? text += "->final" : text += `;\n${finalSegment.id}->final`, lastId = null;
			}), codePath.thrownSegments.forEach((finalSegment) => {
				lastId === finalSegment.id ? text += "->thrown" : text += `;\n${finalSegment.id}->thrown`, lastId = null;
			}), `${text};`;
		}
	};
})), require_code_path_segment = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let debug = require_debug_helpers();
	function isReachable(segment) {
		return segment.reachable;
	}
	module.exports = class CodePathSegment {
		constructor(id, allPrevSegments, reachable) {
			/* c8 ignore start */
			this.id = id, this.nextSegments = [], this.prevSegments = allPrevSegments.filter(isReachable), this.allNextSegments = [], this.allPrevSegments = allPrevSegments, this.reachable = reachable, Object.defineProperty(this, "internal", { value: {
				used: !1,
				loopedPrevSegments: []
			} }), debug.enabled && (this.internal.nodes = []);
		}
		isLoopedPrevSegment(segment) {
			return this.internal.loopedPrevSegments.includes(segment);
		}
		static newRoot(id) {
			return new CodePathSegment(id, [], !0);
		}
		static newNext(id, allPrevSegments) {
			return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));
		}
		static newUnreachable(id, allPrevSegments) {
			let segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), !1);
			return CodePathSegment.markUsed(segment), segment;
		}
		static newDisconnected(id, allPrevSegments) {
			return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
		}
		static markUsed(segment) {
			if (segment.internal.used) return;
			segment.internal.used = !0;
			let i;
			if (segment.reachable) for (i = 0; i < segment.allPrevSegments.length; ++i) {
				let prevSegment = segment.allPrevSegments[i];
				prevSegment.allNextSegments.push(segment), prevSegment.nextSegments.push(segment);
			}
			else for (i = 0; i < segment.allPrevSegments.length; ++i) segment.allPrevSegments[i].allNextSegments.push(segment);
		}
		static markPrevSegmentAsLooped(segment, prevSegment) {
			segment.internal.loopedPrevSegments.push(prevSegment);
		}
		static flattenUnusedSegments(segments) {
			let done = /* @__PURE__ */ new Set();
			for (let i = 0; i < segments.length; ++i) {
				let segment = segments[i];
				if (!done.has(segment)) if (segment.internal.used) done.add(segment);
				else for (let j = 0; j < segment.allPrevSegments.length; ++j) {
					let prevSegment = segment.allPrevSegments[j];
					done.has(prevSegment) || done.add(prevSegment);
				}
			}
			return [...done];
		}
	};
})), require_fork_context = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let assert = require_assert(), CodePathSegment = require_code_path_segment();
	function isReachable(segment) {
		return segment.reachable;
	}
	function createSegments(context, startIndex, endIndex, create) {
		let list = context.segmentsList, normalizedBegin = startIndex >= 0 ? startIndex : list.length + startIndex, normalizedEnd = endIndex >= 0 ? endIndex : list.length + endIndex, segments = [];
		for (let i = 0; i < context.count; ++i) {
			let allPrevSegments = [];
			for (let j = normalizedBegin; j <= normalizedEnd; ++j) allPrevSegments.push(list[j][i]);
			segments.push(create(context.idGenerator.next(), allPrevSegments));
		}
		return segments;
	}
	function mergeExtraSegments(context, segments) {
		let currentSegments = segments;
		for (; currentSegments.length > context.count;) {
			let merged = [];
			for (let i = 0, length = Math.floor(currentSegments.length / 2); i < length; ++i) merged.push(CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));
			currentSegments = merged;
		}
		return currentSegments;
	}
	module.exports = class ForkContext {
		constructor(idGenerator, upper, count) {
			this.idGenerator = idGenerator, this.upper = upper, this.count = count, this.segmentsList = [];
		}
		get head() {
			let list = this.segmentsList;
			return list.length === 0 ? [] : list.at(-1);
		}
		get empty() {
			return this.segmentsList.length === 0;
		}
		get reachable() {
			let segments = this.head;
			return segments.length > 0 && segments.some(isReachable);
		}
		makeNext(startIndex, endIndex) {
			return createSegments(this, startIndex, endIndex, CodePathSegment.newNext);
		}
		makeUnreachable(startIndex, endIndex) {
			return createSegments(this, startIndex, endIndex, CodePathSegment.newUnreachable);
		}
		makeDisconnected(startIndex, endIndex) {
			return createSegments(this, startIndex, endIndex, CodePathSegment.newDisconnected);
		}
		add(segments) {
			assert(segments.length >= this.count, `${segments.length} >= ${this.count}`), this.segmentsList.push(mergeExtraSegments(this, segments));
		}
		replaceHead(replacementHeadSegments) {
			assert(replacementHeadSegments.length >= this.count, `${replacementHeadSegments.length} >= ${this.count}`), this.segmentsList.splice(-1, 1, mergeExtraSegments(this, replacementHeadSegments));
		}
		addAll(otherForkContext) {
			assert(otherForkContext.count === this.count), this.segmentsList.push(...otherForkContext.segmentsList);
		}
		clear() {
			this.segmentsList = [];
		}
		static newRoot(idGenerator) {
			let context = new ForkContext(idGenerator, null, 1);
			return context.add([CodePathSegment.newRoot(idGenerator.next())]), context;
		}
		static newEmpty(parentContext, shouldForkLeavingPath) {
			return new ForkContext(parentContext.idGenerator, parentContext, (shouldForkLeavingPath ? 2 : 1) * parentContext.count);
		}
	};
})), require_code_path_state = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let CodePathSegment = require_code_path_segment(), ForkContext = require_fork_context();
	var BreakContext = class {
		constructor(upperContext, breakable, label, forkContext) {
			this.upper = upperContext, this.breakable = breakable, this.label = label, this.brokenForkContext = ForkContext.newEmpty(forkContext);
		}
	}, ChainContext = class {
		constructor(upperContext) {
			this.upper = upperContext, this.choiceContextCount = 0;
		}
	}, ChoiceContext = class {
		constructor(upperContext, kind, isForkingAsResult, forkContext) {
			this.upper = upperContext, this.kind = kind, this.isForkingAsResult = isForkingAsResult, this.trueForkContext = ForkContext.newEmpty(forkContext), this.falseForkContext = ForkContext.newEmpty(forkContext), this.nullishForkContext = ForkContext.newEmpty(forkContext), this.processed = !1;
		}
	}, LoopContextBase = class {
		constructor(upperContext, type, label, breakContext) {
			this.upper = upperContext, this.type = type, this.label = label, this.brokenForkContext = breakContext.brokenForkContext;
		}
	}, WhileLoopContext = class extends LoopContextBase {
		constructor(upperContext, label, breakContext) {
			super(upperContext, "WhileStatement", label, breakContext), this.test = void 0, this.continueDestSegments = null;
		}
	}, DoWhileLoopContext = class extends LoopContextBase {
		constructor(upperContext, label, breakContext, forkContext) {
			super(upperContext, "DoWhileStatement", label, breakContext), this.test = void 0, this.entrySegments = null, this.continueForkContext = ForkContext.newEmpty(forkContext);
		}
	}, ForLoopContext = class extends LoopContextBase {
		constructor(upperContext, label, breakContext) {
			super(upperContext, "ForStatement", label, breakContext), this.test = void 0, this.endOfInitSegments = null, this.testSegments = null, this.endOfTestSegments = null, this.updateSegments = null, this.endOfUpdateSegments = null, this.continueDestSegments = null;
		}
	}, ForInLoopContext = class extends LoopContextBase {
		constructor(upperContext, label, breakContext) {
			super(upperContext, "ForInStatement", label, breakContext), this.prevSegments = null, this.leftSegments = null, this.endOfLeftSegments = null, this.continueDestSegments = null;
		}
	}, ForOfLoopContext = class extends LoopContextBase {
		constructor(upperContext, label, breakContext) {
			super(upperContext, "ForOfStatement", label, breakContext), this.prevSegments = null, this.leftSegments = null, this.endOfLeftSegments = null, this.continueDestSegments = null;
		}
	}, SwitchContext = class {
		constructor(upperContext, hasCase) {
			this.upper = upperContext, this.hasCase = hasCase, this.defaultSegments = null, this.defaultBodySegments = null, this.foundEmptyDefault = !1, this.lastIsDefault = !1, this.forkCount = 0;
		}
	}, TryContext = class {
		constructor(upperContext, hasFinalizer, forkContext) {
			this.upper = upperContext, this.hasFinalizer = hasFinalizer, this.position = "try", this.returnedForkContext = hasFinalizer ? ForkContext.newEmpty(forkContext) : null, this.thrownForkContext = ForkContext.newEmpty(forkContext), this.lastOfTryIsReachable = !1, this.lastOfCatchIsReachable = !1;
		}
	};
	function addToReturnedOrThrown(dest, others, all, segments) {
		for (let i = 0; i < segments.length; ++i) {
			let segment = segments[i];
			dest.push(segment), others.includes(segment) || all.push(segment);
		}
	}
	function getContinueContext(state, label) {
		if (!label) return state.loopContext;
		let context = state.loopContext;
		for (; context;) {
			if (context.label === label) return context;
			context = context.upper;
		}
		/* c8 ignore next */
		return null;
	}
	function getBreakContext(state, label) {
		let context = state.breakContext;
		for (; context;) {
			if (label ? context.label === label : context.breakable) return context;
			context = context.upper;
		}
		/* c8 ignore next */
		return null;
	}
	function getReturnContext(state) {
		let context = state.tryContext;
		for (; context;) {
			if (context.hasFinalizer && context.position !== "finally") return context;
			context = context.upper;
		}
		return state;
	}
	function getThrowContext(state) {
		let context = state.tryContext;
		for (; context;) {
			if (context.position === "try" || context.hasFinalizer && context.position === "catch") return context;
			context = context.upper;
		}
		return state;
	}
	function removeFromArray(elements, value) {
		elements.splice(elements.indexOf(value), 1);
	}
	function disconnectSegments(prevSegments, nextSegments) {
		for (let i = 0; i < prevSegments.length; ++i) {
			let prevSegment = prevSegments[i], nextSegment = nextSegments[i];
			removeFromArray(prevSegment.nextSegments, nextSegment), removeFromArray(prevSegment.allNextSegments, nextSegment), removeFromArray(nextSegment.prevSegments, prevSegment), removeFromArray(nextSegment.allPrevSegments, prevSegment);
		}
	}
	function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {
		let fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments), toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments), end = Math.min(fromSegments.length, toSegments.length);
		for (let i = 0; i < end; ++i) {
			let fromSegment = fromSegments[i], toSegment = toSegments[i];
			toSegment.reachable && fromSegment.nextSegments.push(toSegment), fromSegment.reachable && toSegment.prevSegments.push(fromSegment), fromSegment.allNextSegments.push(toSegment), toSegment.allPrevSegments.push(fromSegment), toSegment.allPrevSegments.length >= 2 && CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment), state.notifyLooped(fromSegment, toSegment);
		}
	}
	function finalizeTestSegmentsOfFor(context, choiceContext, head) {
		choiceContext.processed || (choiceContext.trueForkContext.add(head), choiceContext.falseForkContext.add(head), choiceContext.nullishForkContext.add(head)), context.test !== !0 && context.brokenForkContext.addAll(choiceContext.falseForkContext), context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
	}
	var CodePathState = class {
		constructor(idGenerator, onLooped) {
			this.idGenerator = idGenerator, this.notifyLooped = onLooped, this.forkContext = ForkContext.newRoot(idGenerator), this.choiceContext = null, this.switchContext = null, this.tryContext = null, this.loopContext = null, this.breakContext = null, this.chainContext = null, this.currentSegments = [], this.initialSegment = this.forkContext.head[0], this.finalSegments = [], this.returnedForkContext = [], this.thrownForkContext = [];
			let final = this.finalSegments, returned = this.returnedForkContext, thrown = this.thrownForkContext;
			returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final), thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
		}
		get headSegments() {
			return this.forkContext.head;
		}
		get parentForkContext() {
			let current = this.forkContext;
			return current && current.upper;
		}
		pushForkContext(forkLeavingPath) {
			return this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath), this.forkContext;
		}
		popForkContext() {
			let lastContext = this.forkContext;
			return this.forkContext = lastContext.upper, this.forkContext.replaceHead(lastContext.makeNext(0, -1)), lastContext;
		}
		forkPath() {
			this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
		}
		forkBypassPath() {
			this.forkContext.add(this.parentForkContext.head);
		}
		pushChoiceContext(kind, isForkingAsResult) {
			this.choiceContext = new ChoiceContext(this.choiceContext, kind, isForkingAsResult, this.forkContext);
		}
		popChoiceContext() {
			let poppedChoiceContext = this.choiceContext, forkContext = this.forkContext, head = forkContext.head;
			switch (this.choiceContext = poppedChoiceContext.upper, poppedChoiceContext.kind) {
				case "&&":
				case "||":
				case "??":
					if (poppedChoiceContext.processed || (poppedChoiceContext.trueForkContext.add(head), poppedChoiceContext.falseForkContext.add(head), poppedChoiceContext.nullishForkContext.add(head)), poppedChoiceContext.isForkingAsResult) {
						let parentContext = this.choiceContext;
						return parentContext.trueForkContext.addAll(poppedChoiceContext.trueForkContext), parentContext.falseForkContext.addAll(poppedChoiceContext.falseForkContext), parentContext.nullishForkContext.addAll(poppedChoiceContext.nullishForkContext), parentContext.processed = !0, poppedChoiceContext;
					}
					break;
				case "test":
					poppedChoiceContext.processed ? (poppedChoiceContext.falseForkContext.clear(), poppedChoiceContext.falseForkContext.add(head)) : (poppedChoiceContext.trueForkContext.clear(), poppedChoiceContext.trueForkContext.add(head));
					break;
				case "loop": return poppedChoiceContext;
				default: throw Error("unreachable");
			}
			let combinedForkContext = poppedChoiceContext.trueForkContext;
			return combinedForkContext.addAll(poppedChoiceContext.falseForkContext), forkContext.replaceHead(combinedForkContext.makeNext(0, -1)), poppedChoiceContext;
		}
		makeLogicalRight() {
			let currentChoiceContext = this.choiceContext, forkContext = this.forkContext;
			if (currentChoiceContext.processed) {
				let prevForkContext;
				switch (currentChoiceContext.kind) {
					case "&&":
						prevForkContext = currentChoiceContext.trueForkContext;
						break;
					case "||":
						prevForkContext = currentChoiceContext.falseForkContext;
						break;
					case "??":
						prevForkContext = currentChoiceContext.nullishForkContext;
						break;
					default: throw Error("unreachable");
				}
				forkContext.replaceHead(prevForkContext.makeNext(0, -1)), prevForkContext.clear(), currentChoiceContext.processed = !1;
			} else {
				switch (currentChoiceContext.kind) {
					case "&&":
						currentChoiceContext.falseForkContext.add(forkContext.head), currentChoiceContext.nullishForkContext.add(forkContext.head);
						break;
					case "||":
						currentChoiceContext.trueForkContext.add(forkContext.head);
						break;
					case "??":
						currentChoiceContext.trueForkContext.add(forkContext.head), currentChoiceContext.falseForkContext.add(forkContext.head);
						break;
					default: throw Error("unreachable");
				}
				forkContext.replaceHead(forkContext.makeNext(-1, -1));
			}
		}
		makeIfConsequent() {
			let context = this.choiceContext, forkContext = this.forkContext;
			context.processed || (context.trueForkContext.add(forkContext.head), context.falseForkContext.add(forkContext.head), context.nullishForkContext.add(forkContext.head)), context.processed = !1, forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));
		}
		makeIfAlternate() {
			let context = this.choiceContext, forkContext = this.forkContext;
			context.trueForkContext.clear(), context.trueForkContext.add(forkContext.head), context.processed = !0, forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));
		}
		pushChainContext() {
			this.chainContext = new ChainContext(this.chainContext);
		}
		popChainContext() {
			let context = this.chainContext;
			this.chainContext = context.upper;
			for (let i = context.choiceContextCount; i > 0; --i) this.popChoiceContext();
		}
		makeOptionalNode() {
			this.chainContext && (this.chainContext.choiceContextCount += 1, this.pushChoiceContext("??", !1));
		}
		makeOptionalRight() {
			this.chainContext && this.makeLogicalRight();
		}
		pushSwitchContext(hasCase, label) {
			this.switchContext = new SwitchContext(this.switchContext, hasCase), this.pushBreakContext(!0, label);
		}
		popSwitchContext() {
			let context = this.switchContext;
			this.switchContext = context.upper;
			let forkContext = this.forkContext, brokenForkContext = this.popBreakContext().brokenForkContext;
			if (context.forkCount === 0) {
				brokenForkContext.empty || (brokenForkContext.add(forkContext.makeNext(-1, -1)), forkContext.replaceHead(brokenForkContext.makeNext(0, -1)));
				return;
			}
			let lastSegments = forkContext.head;
			this.forkBypassPath();
			let lastCaseSegments = forkContext.head;
			brokenForkContext.add(lastSegments), context.lastIsDefault || (context.defaultBodySegments ? (disconnectSegments(context.defaultSegments, context.defaultBodySegments), makeLooped(this, lastCaseSegments, context.defaultBodySegments)) : brokenForkContext.add(lastCaseSegments));
			for (let i = 0; i < context.forkCount; ++i) this.forkContext = this.forkContext.upper;
			this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
		}
		makeSwitchCaseBody(isCaseBodyEmpty, isDefaultCase) {
			let context = this.switchContext;
			if (!context.hasCase) return;
			let parentForkContext = this.forkContext, forkContext = this.pushForkContext();
			forkContext.add(parentForkContext.makeNext(0, -1)), isDefaultCase ? (context.defaultSegments = parentForkContext.head, isCaseBodyEmpty ? context.foundEmptyDefault = !0 : context.defaultBodySegments = forkContext.head) : !isCaseBodyEmpty && context.foundEmptyDefault && (context.foundEmptyDefault = !1, context.defaultBodySegments = forkContext.head), context.lastIsDefault = isDefaultCase, context.forkCount += 1;
		}
		pushTryContext(hasFinalizer) {
			this.tryContext = new TryContext(this.tryContext, hasFinalizer, this.forkContext);
		}
		popTryContext() {
			let context = this.tryContext;
			if (this.tryContext = context.upper, context.position === "catch") {
				this.popForkContext();
				return;
			}
			let originalReturnedForkContext = context.returnedForkContext, originalThrownForkContext = context.thrownForkContext;
			if (originalReturnedForkContext.empty && originalThrownForkContext.empty) return;
			let headSegments = this.forkContext.head;
			this.forkContext = this.forkContext.upper;
			let normalSegments = headSegments.slice(0, headSegments.length / 2 | 0), leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
			originalReturnedForkContext.empty || getReturnContext(this).returnedForkContext.add(leavingSegments), originalThrownForkContext.empty || getThrowContext(this).thrownForkContext.add(leavingSegments), this.forkContext.replaceHead(normalSegments), !context.lastOfTryIsReachable && !context.lastOfCatchIsReachable && this.forkContext.makeUnreachable();
		}
		makeCatchBlock() {
			let context = this.tryContext, forkContext = this.forkContext, originalThrownForkContext = context.thrownForkContext;
			context.position = "catch", context.thrownForkContext = ForkContext.newEmpty(forkContext), context.lastOfTryIsReachable = forkContext.reachable, originalThrownForkContext.add(forkContext.head);
			let thrownSegments = originalThrownForkContext.makeNext(0, -1);
			this.pushForkContext(), this.forkBypassPath(), this.forkContext.add(thrownSegments);
		}
		makeFinallyBlock() {
			let context = this.tryContext, forkContext = this.forkContext, originalReturnedForkContext = context.returnedForkContext, originalThrownForContext = context.thrownForkContext, headOfLeavingSegments = forkContext.head;
			if (context.position === "catch" ? (this.popForkContext(), forkContext = this.forkContext, context.lastOfCatchIsReachable = forkContext.reachable) : context.lastOfTryIsReachable = forkContext.reachable, context.position = "finally", originalReturnedForkContext.empty && originalThrownForContext.empty) return;
			let segments = forkContext.makeNext(-1, -1);
			for (let i = 0; i < forkContext.count; ++i) {
				let prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
				for (let j = 0; j < originalReturnedForkContext.segmentsList.length; ++j) prevSegsOfLeavingSegment.push(originalReturnedForkContext.segmentsList[j][i]);
				for (let j = 0; j < originalThrownForContext.segmentsList.length; ++j) prevSegsOfLeavingSegment.push(originalThrownForContext.segmentsList[j][i]);
				segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
			}
			this.pushForkContext(!0), this.forkContext.add(segments);
		}
		makeFirstThrowablePathInTryBlock() {
			let forkContext = this.forkContext;
			if (!forkContext.reachable) return;
			let context = getThrowContext(this);
			context === this || context.position !== "try" || !context.thrownForkContext.empty || (context.thrownForkContext.add(forkContext.head), forkContext.replaceHead(forkContext.makeNext(-1, -1)));
		}
		pushLoopContext(type, label) {
			let forkContext = this.forkContext, breakContext = this.pushBreakContext(!0, label);
			switch (type) {
				case "WhileStatement":
					this.pushChoiceContext("loop", !1), this.loopContext = new WhileLoopContext(this.loopContext, label, breakContext);
					break;
				case "DoWhileStatement":
					this.pushChoiceContext("loop", !1), this.loopContext = new DoWhileLoopContext(this.loopContext, label, breakContext, forkContext);
					break;
				case "ForStatement":
					this.pushChoiceContext("loop", !1), this.loopContext = new ForLoopContext(this.loopContext, label, breakContext);
					break;
				case "ForInStatement":
					this.loopContext = new ForInLoopContext(this.loopContext, label, breakContext);
					break;
				case "ForOfStatement":
					this.loopContext = new ForOfLoopContext(this.loopContext, label, breakContext);
					break;
				default: throw Error(`unknown type: "${type}"`);
			}
		}
		popLoopContext() {
			let context = this.loopContext;
			this.loopContext = context.upper;
			let forkContext = this.forkContext, brokenForkContext = this.popBreakContext().brokenForkContext;
			switch (context.type) {
				case "WhileStatement":
				case "ForStatement":
					this.popChoiceContext(), makeLooped(this, forkContext.head, context.continueDestSegments);
					break;
				case "DoWhileStatement": {
					let choiceContext = this.popChoiceContext();
					choiceContext.processed || (choiceContext.trueForkContext.add(forkContext.head), choiceContext.falseForkContext.add(forkContext.head)), context.test !== !0 && brokenForkContext.addAll(choiceContext.falseForkContext);
					let segmentsList = choiceContext.trueForkContext.segmentsList;
					for (let i = 0; i < segmentsList.length; ++i) makeLooped(this, segmentsList[i], context.entrySegments);
					break;
				}
				case "ForInStatement":
				case "ForOfStatement":
					brokenForkContext.add(forkContext.head), makeLooped(this, forkContext.head, context.leftSegments);
					break;
				default: throw Error("unreachable");
			}
			brokenForkContext.empty ? forkContext.replaceHead(forkContext.makeUnreachable(-1, -1)) : forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
		}
		makeWhileTest(test) {
			let context = this.loopContext, forkContext = this.forkContext, testSegments = forkContext.makeNext(0, -1);
			context.test = test, context.continueDestSegments = testSegments, forkContext.replaceHead(testSegments);
		}
		makeWhileBody() {
			let context = this.loopContext, choiceContext = this.choiceContext, forkContext = this.forkContext;
			choiceContext.processed || (choiceContext.trueForkContext.add(forkContext.head), choiceContext.falseForkContext.add(forkContext.head)), context.test !== !0 && context.brokenForkContext.addAll(choiceContext.falseForkContext), forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
		}
		makeDoWhileBody() {
			let context = this.loopContext, forkContext = this.forkContext, bodySegments = forkContext.makeNext(-1, -1);
			context.entrySegments = bodySegments, forkContext.replaceHead(bodySegments);
		}
		makeDoWhileTest(test) {
			let context = this.loopContext, forkContext = this.forkContext;
			if (context.test = test, !context.continueForkContext.empty) {
				context.continueForkContext.add(forkContext.head);
				let testSegments = context.continueForkContext.makeNext(0, -1);
				forkContext.replaceHead(testSegments);
			}
		}
		makeForTest(test) {
			let context = this.loopContext, forkContext = this.forkContext, endOfInitSegments = forkContext.head, testSegments = forkContext.makeNext(-1, -1);
			context.test = test, context.endOfInitSegments = endOfInitSegments, context.continueDestSegments = context.testSegments = testSegments, forkContext.replaceHead(testSegments);
		}
		makeForUpdate() {
			let context = this.loopContext, choiceContext = this.choiceContext, forkContext = this.forkContext;
			context.testSegments ? finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head) : context.endOfInitSegments = forkContext.head;
			let updateSegments = forkContext.makeDisconnected(-1, -1);
			context.continueDestSegments = context.updateSegments = updateSegments, forkContext.replaceHead(updateSegments);
		}
		makeForBody() {
			let context = this.loopContext, choiceContext = this.choiceContext, forkContext = this.forkContext;
			context.updateSegments ? (context.endOfUpdateSegments = forkContext.head, context.testSegments && makeLooped(this, context.endOfUpdateSegments, context.testSegments)) : context.testSegments ? finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head) : context.endOfInitSegments = forkContext.head;
			let bodySegments = context.endOfTestSegments;
			if (!bodySegments) {
				let prevForkContext = ForkContext.newEmpty(forkContext);
				prevForkContext.add(context.endOfInitSegments), context.endOfUpdateSegments && prevForkContext.add(context.endOfUpdateSegments), bodySegments = prevForkContext.makeNext(0, -1);
			}
			context.continueDestSegments = context.continueDestSegments || bodySegments, forkContext.replaceHead(bodySegments);
		}
		makeForInOfLeft() {
			let context = this.loopContext, forkContext = this.forkContext, leftSegments = forkContext.makeDisconnected(-1, -1);
			context.prevSegments = forkContext.head, context.leftSegments = context.continueDestSegments = leftSegments, forkContext.replaceHead(leftSegments);
		}
		makeForInOfRight() {
			let context = this.loopContext, forkContext = this.forkContext, temp = ForkContext.newEmpty(forkContext);
			temp.add(context.prevSegments);
			let rightSegments = temp.makeNext(-1, -1);
			context.endOfLeftSegments = forkContext.head, forkContext.replaceHead(rightSegments);
		}
		makeForInOfBody() {
			let context = this.loopContext, forkContext = this.forkContext, temp = ForkContext.newEmpty(forkContext);
			temp.add(context.endOfLeftSegments);
			let bodySegments = temp.makeNext(-1, -1);
			makeLooped(this, forkContext.head, context.leftSegments), context.brokenForkContext.add(forkContext.head), forkContext.replaceHead(bodySegments);
		}
		pushBreakContext(breakable, label) {
			return this.breakContext = new BreakContext(this.breakContext, breakable, label, this.forkContext), this.breakContext;
		}
		popBreakContext() {
			let context = this.breakContext, forkContext = this.forkContext;
			if (this.breakContext = context.upper, !context.breakable) {
				let brokenForkContext = context.brokenForkContext;
				brokenForkContext.empty || (brokenForkContext.add(forkContext.head), forkContext.replaceHead(brokenForkContext.makeNext(0, -1)));
			}
			return context;
		}
		makeBreak(label) {
			let forkContext = this.forkContext;
			if (!forkContext.reachable) return;
			let context = getBreakContext(this, label);
			/* c8 ignore next */
			context && context.brokenForkContext.add(forkContext.head), forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
		}
		makeContinue(label) {
			let forkContext = this.forkContext;
			if (!forkContext.reachable) return;
			let context = getContinueContext(this, label);
			context && (context.continueDestSegments ? (makeLooped(this, forkContext.head, context.continueDestSegments), (context.type === "ForInStatement" || context.type === "ForOfStatement") && context.brokenForkContext.add(forkContext.head)) : context.continueForkContext.add(forkContext.head)), forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
		}
		makeReturn() {
			let forkContext = this.forkContext;
			forkContext.reachable && (getReturnContext(this).returnedForkContext.add(forkContext.head), forkContext.replaceHead(forkContext.makeUnreachable(-1, -1)));
		}
		makeThrow() {
			let forkContext = this.forkContext;
			forkContext.reachable && (getThrowContext(this).thrownForkContext.add(forkContext.head), forkContext.replaceHead(forkContext.makeUnreachable(-1, -1)));
		}
		makeFinal() {
			let segments = this.currentSegments;
			segments.length > 0 && segments[0].reachable && this.returnedForkContext.add(segments);
		}
	};
	module.exports = CodePathState;
})), require_id_generator = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var IdGenerator = class {
		constructor(prefix) {
			this.prefix = String(prefix), this.n = 0;
		}
		next() {
			return this.n = 1 + this.n | 0, this.n < 0 && (this.n = 1), this.prefix + this.n;
		}
	};
	module.exports = IdGenerator;
})), require_code_path = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let CodePathState = require_code_path_state(), IdGenerator = require_id_generator();
	var CodePath = class {
		constructor({ id, origin, upper, onLooped }) {
			this.id = id, this.origin = origin, this.upper = upper, this.childCodePaths = [], Object.defineProperty(this, "internal", { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }), upper && upper.childCodePaths.push(this);
		}
		static getState(codePath) {
			return codePath.internal;
		}
		get initialSegment() {
			return this.internal.initialSegment;
		}
		get finalSegments() {
			return this.internal.finalSegments;
		}
		get returnedSegments() {
			return this.internal.returnedForkContext;
		}
		get thrownSegments() {
			return this.internal.thrownForkContext;
		}
		traverseSegments(optionsOrCallback, callback) {
			let resolvedOptions, resolvedCallback;
			typeof optionsOrCallback == "function" ? (resolvedCallback = optionsOrCallback, resolvedOptions = {}) : (resolvedOptions = optionsOrCallback || {}, resolvedCallback = callback);
			let startSegment = resolvedOptions.first || this.internal.initialSegment, lastSegment = resolvedOptions.last, record, index, end, segment = null, visited = /* @__PURE__ */ new Set(), stack = [[startSegment, 0]], skipped = /* @__PURE__ */ new Set(), broken = !1, controller = {
				skip() {
					skipped.add(segment);
				},
				break() {
					broken = !0;
				}
			};
			function isVisited(prevSegment) {
				return visited.has(prevSegment) || segment.isLoopedPrevSegment(prevSegment);
			}
			function isSkipped(prevSegment) {
				return skipped.has(prevSegment) || segment.isLoopedPrevSegment(prevSegment);
			}
			for (; stack.length > 0;) {
				if (record = stack.at(-1), segment = record[0], index = record[1], index === 0) {
					if (visited.has(segment)) {
						stack.pop();
						continue;
					}
					if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
						stack.pop();
						continue;
					}
					if (visited.add(segment), skipped.size > 0 && segment.prevSegments.length > 0 && segment.prevSegments.every(isSkipped)) skipped.add(segment);
					else if (resolvedCallback.call(this, segment, controller), segment === lastSegment && controller.skip(), broken) break;
				}
				end = segment.nextSegments.length - 1, index < end ? (record[1] += 1, stack.push([segment.nextSegments[index], 0])) : index === end ? (record[0] = segment.nextSegments[index], record[1] = 0) : stack.pop();
			}
		}
	};
	module.exports = CodePath;
})), require_code_path_analyzer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let assert = require_assert(), { breakableTypePattern } = require_ast_utils(), CodePath = require_code_path(), CodePathSegment = require_code_path_segment(), IdGenerator = require_id_generator(), debug = require_debug_helpers();
	function isCaseNode(node) {
		return !!node.test;
	}
	function isPropertyDefinitionValue(node) {
		let parent = node.parent;
		return parent && parent.type === "PropertyDefinition" && parent.value === node;
	}
	function isHandledLogicalOperator(operator) {
		return operator === "&&" || operator === "||" || operator === "??";
	}
	function isLogicalAssignmentOperator(operator) {
		return operator === "&&=" || operator === "||=" || operator === "??=";
	}
	function getLabel(node) {
		return node.parent.type === "LabeledStatement" ? node.parent.label.name : null;
	}
	function isForkingByTrueOrFalse(node) {
		let parent = node.parent;
		switch (parent.type) {
			case "ConditionalExpression":
			case "IfStatement":
			case "WhileStatement":
			case "DoWhileStatement":
			case "ForStatement": return parent.test === node;
			case "LogicalExpression": return isHandledLogicalOperator(parent.operator);
			case "AssignmentExpression": return isLogicalAssignmentOperator(parent.operator);
			default: return !1;
		}
	}
	function getBooleanValueIfSimpleConstant(node) {
		if (node.type === "Literal") return !!node.value;
	}
	function isIdentifierReference(node) {
		let parent = node.parent;
		switch (parent.type) {
			case "LabeledStatement":
			case "BreakStatement":
			case "ContinueStatement":
			case "ArrayPattern":
			case "RestElement":
			case "ImportSpecifier":
			case "ImportDefaultSpecifier":
			case "ImportNamespaceSpecifier":
			case "CatchClause": return !1;
			case "FunctionDeclaration":
			case "FunctionExpression":
			case "ArrowFunctionExpression":
			case "ClassDeclaration":
			case "ClassExpression":
			case "VariableDeclarator": return parent.id !== node;
			case "Property":
			case "PropertyDefinition":
			case "MethodDefinition": return parent.key !== node || parent.computed || parent.shorthand;
			case "AssignmentPattern": return parent.key !== node;
			default: return !0;
		}
	}
	function forwardCurrentToHead(analyzer, node) {
		let codePath = analyzer.codePath, state = CodePath.getState(codePath), currentSegments = state.currentSegments, headSegments = state.headSegments, end = Math.max(currentSegments.length, headSegments.length), i, currentSegment, headSegment;
		for (i = 0; i < end; ++i) if (currentSegment = currentSegments[i], headSegment = headSegments[i], currentSegment !== headSegment && currentSegment) {
			let eventName = currentSegment.reachable ? "onCodePathSegmentEnd" : "onUnreachableCodePathSegmentEnd";
			debug.dump(`${eventName} ${currentSegment.id}`), analyzer.emit(eventName, [currentSegment, node]);
		}
		for (state.currentSegments = headSegments, i = 0; i < end; ++i) if (currentSegment = currentSegments[i], headSegment = headSegments[i], currentSegment !== headSegment && headSegment) {
			let eventName = headSegment.reachable ? "onCodePathSegmentStart" : "onUnreachableCodePathSegmentStart";
			debug.dump(`${eventName} ${headSegment.id}`), CodePathSegment.markUsed(headSegment), analyzer.emit(eventName, [headSegment, node]);
		}
	}
	function leaveFromCurrentSegment(analyzer, node) {
		let state = CodePath.getState(analyzer.codePath), currentSegments = state.currentSegments;
		for (let i = 0; i < currentSegments.length; ++i) {
			let currentSegment = currentSegments[i], eventName = currentSegment.reachable ? "onCodePathSegmentEnd" : "onUnreachableCodePathSegmentEnd";
			debug.dump(`${eventName} ${currentSegment.id}`), analyzer.emit(eventName, [currentSegment, node]);
		}
		state.currentSegments = [];
	}
	function preprocess(analyzer, node) {
		let codePath = analyzer.codePath, state = CodePath.getState(codePath), parent = node.parent;
		switch (parent.type) {
			case "CallExpression":
				parent.optional === !0 && parent.arguments.length >= 1 && parent.arguments[0] === node && state.makeOptionalRight();
				break;
			case "MemberExpression":
				parent.optional === !0 && parent.property === node && state.makeOptionalRight();
				break;
			case "LogicalExpression":
				parent.right === node && isHandledLogicalOperator(parent.operator) && state.makeLogicalRight();
				break;
			case "AssignmentExpression":
				parent.right === node && isLogicalAssignmentOperator(parent.operator) && state.makeLogicalRight();
				break;
			case "ConditionalExpression":
			case "IfStatement":
				parent.consequent === node ? state.makeIfConsequent() : parent.alternate === node && state.makeIfAlternate();
				break;
			case "SwitchCase":
				parent.consequent[0] === node && state.makeSwitchCaseBody(!1, !parent.test);
				break;
			case "TryStatement":
				parent.handler === node ? state.makeCatchBlock() : parent.finalizer === node && state.makeFinallyBlock();
				break;
			case "WhileStatement":
				parent.test === node ? state.makeWhileTest(getBooleanValueIfSimpleConstant(node)) : (assert(parent.body === node), state.makeWhileBody());
				break;
			case "DoWhileStatement":
				parent.body === node ? state.makeDoWhileBody() : (assert(parent.test === node), state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node)));
				break;
			case "ForStatement":
				parent.test === node ? state.makeForTest(getBooleanValueIfSimpleConstant(node)) : parent.update === node ? state.makeForUpdate() : parent.body === node && state.makeForBody();
				break;
			case "ForInStatement":
			case "ForOfStatement":
				parent.left === node ? state.makeForInOfLeft() : parent.right === node ? state.makeForInOfRight() : (assert(parent.body === node), state.makeForInOfBody());
				break;
			case "AssignmentPattern":
				parent.right === node && (state.pushForkContext(), state.forkBypassPath(), state.forkPath());
				break;
			default: break;
		}
	}
	function processCodePathToEnter(analyzer, node) {
		let codePath = analyzer.codePath, state = codePath && CodePath.getState(codePath), parent = node.parent;
		function startCodePath(origin) {
			codePath && (forwardCurrentToHead(analyzer, node), debug.dumpState(node, state, !1)), codePath = analyzer.codePath = new CodePath({
				id: analyzer.idGenerator.next(),
				origin,
				upper: codePath,
				onLooped: analyzer.onLooped
			}), state = CodePath.getState(codePath), debug.dump(`onCodePathStart ${codePath.id}`), analyzer.emit("onCodePathStart", [codePath, node]);
		}
		switch (isPropertyDefinitionValue(node) && startCodePath("class-field-initializer"), node.type) {
			case "Program":
				startCodePath("program");
				break;
			case "FunctionDeclaration":
			case "FunctionExpression":
			case "ArrowFunctionExpression":
				startCodePath("function");
				break;
			case "StaticBlock":
				startCodePath("class-static-block");
				break;
			case "ChainExpression":
				state.pushChainContext();
				break;
			case "CallExpression":
				node.optional === !0 && state.makeOptionalNode();
				break;
			case "MemberExpression":
				node.optional === !0 && state.makeOptionalNode();
				break;
			case "LogicalExpression":
				isHandledLogicalOperator(node.operator) && state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
				break;
			case "AssignmentExpression":
				isLogicalAssignmentOperator(node.operator) && state.pushChoiceContext(node.operator.slice(0, -1), isForkingByTrueOrFalse(node));
				break;
			case "ConditionalExpression":
			case "IfStatement":
				state.pushChoiceContext("test", !1);
				break;
			case "SwitchStatement":
				state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));
				break;
			case "TryStatement":
				state.pushTryContext(!!node.finalizer);
				break;
			case "SwitchCase":
				parent.discriminant !== node && parent.cases[0] !== node && state.forkPath();
				break;
			case "WhileStatement":
			case "DoWhileStatement":
			case "ForStatement":
			case "ForInStatement":
			case "ForOfStatement":
				state.pushLoopContext(node.type, getLabel(node));
				break;
			case "LabeledStatement":
				breakableTypePattern.test(node.body.type) || state.pushBreakContext(!1, node.label.name);
				break;
			default: break;
		}
		forwardCurrentToHead(analyzer, node), debug.dumpState(node, state, !1);
	}
	function processCodePathToExit(analyzer, node) {
		let codePath = analyzer.codePath, state = CodePath.getState(codePath), dontForward = !1;
		switch (node.type) {
			case "ChainExpression":
				state.popChainContext();
				break;
			case "IfStatement":
			case "ConditionalExpression":
				state.popChoiceContext();
				break;
			case "LogicalExpression":
				isHandledLogicalOperator(node.operator) && state.popChoiceContext();
				break;
			case "AssignmentExpression":
				isLogicalAssignmentOperator(node.operator) && state.popChoiceContext();
				break;
			case "SwitchStatement":
				state.popSwitchContext();
				break;
			case "SwitchCase":
				node.consequent.length === 0 && state.makeSwitchCaseBody(!0, !node.test), state.forkContext.reachable && (dontForward = !0);
				break;
			case "TryStatement":
				state.popTryContext();
				break;
			case "BreakStatement":
				forwardCurrentToHead(analyzer, node), state.makeBreak(node.label && node.label.name), dontForward = !0;
				break;
			case "ContinueStatement":
				forwardCurrentToHead(analyzer, node), state.makeContinue(node.label && node.label.name), dontForward = !0;
				break;
			case "ReturnStatement":
				forwardCurrentToHead(analyzer, node), state.makeReturn(), dontForward = !0;
				break;
			case "ThrowStatement":
				forwardCurrentToHead(analyzer, node), state.makeThrow(), dontForward = !0;
				break;
			case "Identifier":
				isIdentifierReference(node) && (state.makeFirstThrowablePathInTryBlock(), dontForward = !0);
				break;
			case "CallExpression":
			case "ImportExpression":
			case "MemberExpression":
			case "NewExpression":
			case "YieldExpression":
				state.makeFirstThrowablePathInTryBlock();
				break;
			case "WhileStatement":
			case "DoWhileStatement":
			case "ForStatement":
			case "ForInStatement":
			case "ForOfStatement":
				state.popLoopContext();
				break;
			case "AssignmentPattern":
				state.popForkContext();
				break;
			case "LabeledStatement":
				breakableTypePattern.test(node.body.type) || state.popBreakContext();
				break;
			default: break;
		}
		dontForward || forwardCurrentToHead(analyzer, node), debug.dumpState(node, state, !0);
	}
	function postprocess(analyzer, node) {
		function endCodePath() {
			let codePath = analyzer.codePath;
			CodePath.getState(codePath).makeFinal(), leaveFromCurrentSegment(analyzer, node), debug.dump(`onCodePathEnd ${codePath.id}`), analyzer.emit("onCodePathEnd", [codePath, node]), debug.dumpDot(codePath), codePath = analyzer.codePath = analyzer.codePath.upper, codePath && debug.dumpState(node, CodePath.getState(codePath), !0);
		}
		switch (node.type) {
			case "Program":
			case "FunctionDeclaration":
			case "FunctionExpression":
			case "ArrowFunctionExpression":
			case "StaticBlock":
				endCodePath();
				break;
			case "CallExpression":
				node.optional === !0 && node.arguments.length === 0 && CodePath.getState(analyzer.codePath).makeOptionalRight();
				break;
			default: break;
		}
		isPropertyDefinitionValue(node) && endCodePath();
	}
	var CodePathAnalyzer = class {
		constructor(eventGenerator) {
			this.original = eventGenerator, this.emit = eventGenerator.emit, this.codePath = null, this.idGenerator = new IdGenerator("s"), this.currentNode = null, this.onLooped = this.onLooped.bind(this);
		}
		enterNode(node) {
			this.currentNode = node, node.parent && preprocess(this, node), processCodePathToEnter(this, node), this.original.enterNode(node), this.currentNode = null;
		}
		leaveNode(node) {
			this.currentNode = node, processCodePathToExit(this, node), this.original.leaveNode(node), postprocess(this, node), this.currentNode = null;
		}
		onLooped(fromSegment, toSegment) {
			fromSegment.reachable && toSegment.reachable && (debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`), this.emit("onCodePathSegmentLoop", [
				fromSegment,
				toSegment,
				this.currentNode
			]));
		}
	};
	module.exports = CodePathAnalyzer;
})), require_traverser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let vk = require_eslint_visitor_keys(), debug = require_src()("eslint:traverser");
	function noop() {}
	function isNode(x) {
		return typeof x == "object" && !!x && typeof x.type == "string";
	}
	function getVisitorKeys(visitorKeys, node) {
		let keys = visitorKeys[node.type];
		return keys || (keys = vk.getKeys(node), debug("Unknown node type \"%s\": Estimated visitor keys %j", node.type, keys)), keys;
	}
	module.exports = class Traverser {
		constructor() {
			this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = null, this._enter = null, this._leave = null;
		}
		current() {
			return this._current;
		}
		parents() {
			return this._parents.slice(0);
		}
		break() {
			this._broken = !0;
		}
		skip() {
			this._skipped = !0;
		}
		traverse(node, options) {
			this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = options.visitorKeys || vk.KEYS, this._enter = options.enter || noop, this._leave = options.leave || noop, this._traverse(node, null);
		}
		_traverse(node, parent) {
			if (isNode(node)) {
				if (this._current = node, this._skipped = !1, this._enter(node, parent), !this._skipped && !this._broken) {
					let keys = getVisitorKeys(this._visitorKeys, node);
					if (keys.length >= 1) {
						this._parents.push(node);
						for (let i = 0; i < keys.length && !this._broken; ++i) {
							let child = node[keys[i]];
							if (Array.isArray(child)) for (let j = 0; j < child.length && !this._broken; ++j) this._traverse(child[j], node);
							else this._traverse(child, node);
						}
						this._parents.pop();
					}
				}
				this._broken || this._leave(node, parent), this._current = parent;
			}
		}
		static getKeys(node) {
			return vk.getKeys(node);
		}
		static traverse(node, options) {
			new Traverser().traverse(node, options);
		}
		static get DEFAULT_VISITOR_KEYS() {
			return vk.KEYS;
		}
	};
}));
const NODE_TYPE_IDS_MAP = new Map([
	["DebuggerStatement", 0],
	["EmptyStatement", 1],
	["Literal", 2],
	["PrivateIdentifier", 3],
	["Super", 4],
	["TemplateElement", 5],
	["ThisExpression", 6],
	["JSXClosingFragment", 7],
	["JSXEmptyExpression", 8],
	["JSXIdentifier", 9],
	["JSXOpeningFragment", 10],
	["JSXText", 11],
	["TSAnyKeyword", 12],
	["TSBigIntKeyword", 13],
	["TSBooleanKeyword", 14],
	["TSIntrinsicKeyword", 15],
	["TSJSDocUnknownType", 16],
	["TSNeverKeyword", 17],
	["TSNullKeyword", 18],
	["TSNumberKeyword", 19],
	["TSObjectKeyword", 20],
	["TSStringKeyword", 21],
	["TSSymbolKeyword", 22],
	["TSThisType", 23],
	["TSUndefinedKeyword", 24],
	["TSUnknownKeyword", 25],
	["TSVoidKeyword", 26],
	["AccessorProperty", 27],
	["ArrayExpression", 28],
	["ArrayPattern", 29],
	["ArrowFunctionExpression", 30],
	["AssignmentExpression", 31],
	["AssignmentPattern", 32],
	["AwaitExpression", 33],
	["BinaryExpression", 34],
	["BlockStatement", 35],
	["BreakStatement", 36],
	["CallExpression", 37],
	["CatchClause", 38],
	["ChainExpression", 39],
	["ClassBody", 40],
	["ClassDeclaration", 41],
	["ClassExpression", 42],
	["ConditionalExpression", 43],
	["ContinueStatement", 44],
	["Decorator", 45],
	["DoWhileStatement", 46],
	["ExportAllDeclaration", 47],
	["ExportDefaultDeclaration", 48],
	["ExportNamedDeclaration", 49],
	["ExportSpecifier", 50],
	["ExpressionStatement", 51],
	["ForInStatement", 52],
	["ForOfStatement", 53],
	["ForStatement", 54],
	["FunctionDeclaration", 55],
	["FunctionExpression", 56],
	["Identifier", 57],
	["IfStatement", 58],
	["ImportAttribute", 59],
	["ImportDeclaration", 60],
	["ImportDefaultSpecifier", 61],
	["ImportExpression", 62],
	["ImportNamespaceSpecifier", 63],
	["ImportSpecifier", 64],
	["LabeledStatement", 65],
	["LogicalExpression", 66],
	["MemberExpression", 67],
	["MetaProperty", 68],
	["MethodDefinition", 69],
	["NewExpression", 70],
	["ObjectExpression", 71],
	["ObjectPattern", 72],
	["ParenthesizedExpression", 73],
	["Program", 74],
	["Property", 75],
	["PropertyDefinition", 76],
	["RestElement", 77],
	["ReturnStatement", 78],
	["SequenceExpression", 79],
	["SpreadElement", 80],
	["StaticBlock", 81],
	["SwitchCase", 82],
	["SwitchStatement", 83],
	["TaggedTemplateExpression", 84],
	["TemplateLiteral", 85],
	["ThrowStatement", 86],
	["TryStatement", 87],
	["UnaryExpression", 88],
	["UpdateExpression", 89],
	["V8IntrinsicExpression", 90],
	["VariableDeclaration", 91],
	["VariableDeclarator", 92],
	["WhileStatement", 93],
	["WithStatement", 94],
	["YieldExpression", 95],
	["JSXAttribute", 96],
	["JSXClosingElement", 97],
	["JSXElement", 98],
	["JSXExpressionContainer", 99],
	["JSXFragment", 100],
	["JSXMemberExpression", 101],
	["JSXNamespacedName", 102],
	["JSXOpeningElement", 103],
	["JSXSpreadAttribute", 104],
	["JSXSpreadChild", 105],
	["TSAbstractAccessorProperty", 106],
	["TSAbstractMethodDefinition", 107],
	["TSAbstractPropertyDefinition", 108],
	["TSArrayType", 109],
	["TSAsExpression", 110],
	["TSCallSignatureDeclaration", 111],
	["TSClassImplements", 112],
	["TSConditionalType", 113],
	["TSConstructSignatureDeclaration", 114],
	["TSConstructorType", 115],
	["TSDeclareFunction", 116],
	["TSEmptyBodyFunctionExpression", 117],
	["TSEnumBody", 118],
	["TSEnumDeclaration", 119],
	["TSEnumMember", 120],
	["TSExportAssignment", 121],
	["TSExternalModuleReference", 122],
	["TSFunctionType", 123],
	["TSImportEqualsDeclaration", 124],
	["TSImportType", 125],
	["TSIndexSignature", 126],
	["TSIndexedAccessType", 127],
	["TSInferType", 128],
	["TSInstantiationExpression", 129],
	["TSInterfaceBody", 130],
	["TSInterfaceDeclaration", 131],
	["TSInterfaceHeritage", 132],
	["TSIntersectionType", 133],
	["TSJSDocNonNullableType", 134],
	["TSJSDocNullableType", 135],
	["TSLiteralType", 136],
	["TSMappedType", 137],
	["TSMethodSignature", 138],
	["TSModuleBlock", 139],
	["TSModuleDeclaration", 140],
	["TSNamedTupleMember", 141],
	["TSNamespaceExportDeclaration", 142],
	["TSNonNullExpression", 143],
	["TSOptionalType", 144],
	["TSParameterProperty", 145],
	["TSParenthesizedType", 146],
	["TSPropertySignature", 147],
	["TSQualifiedName", 148],
	["TSRestType", 149],
	["TSSatisfiesExpression", 150],
	["TSTemplateLiteralType", 151],
	["TSTupleType", 152],
	["TSTypeAliasDeclaration", 153],
	["TSTypeAnnotation", 154],
	["TSTypeAssertion", 155],
	["TSTypeLiteral", 156],
	["TSTypeOperator", 157],
	["TSTypeParameter", 158],
	["TSTypeParameterDeclaration", 159],
	["TSTypeParameterInstantiation", 160],
	["TSTypePredicate", 161],
	["TSTypeQuery", 162],
	["TSTypeReference", 163],
	["TSUnionType", 164],
	["onCodePathStart", 165],
	["onCodePathEnd", 166],
	["onCodePathSegmentStart", 167],
	["onCodePathSegmentEnd", 168],
	["onUnreachableCodePathSegmentStart", 169],
	["onUnreachableCodePathSegmentEnd", 170],
	["onCodePathSegmentLoop", 171]
]), STATEMENT_NODE_TYPE_IDS = [
	0,
	1,
	35,
	36,
	41,
	44,
	46,
	47,
	48,
	49,
	51,
	52,
	53,
	54,
	55,
	58,
	60,
	65,
	78,
	83,
	86,
	87,
	91,
	93,
	94,
	111,
	114,
	119,
	124,
	131,
	140,
	142,
	153,
	159
], DECLARATION_NODE_TYPE_IDS = [
	41,
	47,
	48,
	49,
	55,
	60,
	91,
	111,
	114,
	119,
	124,
	131,
	140,
	142,
	153,
	159
], PATTERN_NODE_TYPE_IDS = [
	2,
	6,
	8,
	28,
	29,
	30,
	31,
	32,
	33,
	34,
	37,
	39,
	42,
	43,
	56,
	57,
	62,
	66,
	67,
	68,
	70,
	71,
	72,
	73,
	79,
	84,
	85,
	88,
	89,
	90,
	95,
	101,
	110,
	117,
	129,
	143,
	150,
	156
], EXPRESSION_NODE_TYPE_IDS = [
	2,
	6,
	8,
	28,
	30,
	31,
	33,
	34,
	37,
	39,
	42,
	43,
	56,
	57,
	62,
	66,
	67,
	68,
	70,
	71,
	73,
	79,
	84,
	85,
	88,
	89,
	90,
	95,
	101,
	110,
	117,
	129,
	143,
	150,
	156
], FUNCTION_NODE_TYPE_IDS = [
	30,
	55,
	56
], ancestors = [];
function walkNode(node, visitors) {
	if (node != null) if (Array.isArray(node)) {
		let len = node.length;
		for (let i = 0; i < len; i++) walkNode(node[i], visitors);
	} else switch (node.type) {
		case "DebuggerStatement":
			walkDebuggerStatement(node, visitors);
			break;
		case "EmptyStatement":
			walkEmptyStatement(node, visitors);
			break;
		case "Literal":
			walkLiteral(node, visitors);
			break;
		case "PrivateIdentifier":
			walkPrivateIdentifier(node, visitors);
			break;
		case "Super":
			walkSuper(node, visitors);
			break;
		case "TemplateElement":
			walkTemplateElement(node, visitors);
			break;
		case "ThisExpression":
			walkThisExpression(node, visitors);
			break;
		case "JSXClosingFragment":
			walkJSXClosingFragment(node, visitors);
			break;
		case "JSXEmptyExpression":
			walkJSXEmptyExpression(node, visitors);
			break;
		case "JSXIdentifier":
			walkJSXIdentifier(node, visitors);
			break;
		case "JSXOpeningFragment":
			walkJSXOpeningFragment(node, visitors);
			break;
		case "JSXText":
			walkJSXText(node, visitors);
			break;
		case "TSAnyKeyword":
			walkTSAnyKeyword(node, visitors);
			break;
		case "TSBigIntKeyword":
			walkTSBigIntKeyword(node, visitors);
			break;
		case "TSBooleanKeyword":
			walkTSBooleanKeyword(node, visitors);
			break;
		case "TSIntrinsicKeyword":
			walkTSIntrinsicKeyword(node, visitors);
			break;
		case "TSJSDocUnknownType":
			walkTSJSDocUnknownType(node, visitors);
			break;
		case "TSNeverKeyword":
			walkTSNeverKeyword(node, visitors);
			break;
		case "TSNullKeyword":
			walkTSNullKeyword(node, visitors);
			break;
		case "TSNumberKeyword":
			walkTSNumberKeyword(node, visitors);
			break;
		case "TSObjectKeyword":
			walkTSObjectKeyword(node, visitors);
			break;
		case "TSStringKeyword":
			walkTSStringKeyword(node, visitors);
			break;
		case "TSSymbolKeyword":
			walkTSSymbolKeyword(node, visitors);
			break;
		case "TSThisType":
			walkTSThisType(node, visitors);
			break;
		case "TSUndefinedKeyword":
			walkTSUndefinedKeyword(node, visitors);
			break;
		case "TSUnknownKeyword":
			walkTSUnknownKeyword(node, visitors);
			break;
		case "TSVoidKeyword":
			walkTSVoidKeyword(node, visitors);
			break;
		case "AccessorProperty":
			walkAccessorProperty(node, visitors);
			break;
		case "ArrayExpression":
			walkArrayExpression(node, visitors);
			break;
		case "ArrayPattern":
			walkArrayPattern(node, visitors);
			break;
		case "ArrowFunctionExpression":
			walkArrowFunctionExpression(node, visitors);
			break;
		case "AssignmentExpression":
			walkAssignmentExpression(node, visitors);
			break;
		case "AssignmentPattern":
			walkAssignmentPattern(node, visitors);
			break;
		case "AwaitExpression":
			walkAwaitExpression(node, visitors);
			break;
		case "BinaryExpression":
			walkBinaryExpression(node, visitors);
			break;
		case "BlockStatement":
			walkBlockStatement(node, visitors);
			break;
		case "BreakStatement":
			walkBreakStatement(node, visitors);
			break;
		case "CallExpression":
			walkCallExpression(node, visitors);
			break;
		case "CatchClause":
			walkCatchClause(node, visitors);
			break;
		case "ChainExpression":
			walkChainExpression(node, visitors);
			break;
		case "ClassBody":
			walkClassBody(node, visitors);
			break;
		case "ClassDeclaration":
			walkClassDeclaration(node, visitors);
			break;
		case "ClassExpression":
			walkClassExpression(node, visitors);
			break;
		case "ConditionalExpression":
			walkConditionalExpression(node, visitors);
			break;
		case "ContinueStatement":
			walkContinueStatement(node, visitors);
			break;
		case "Decorator":
			walkDecorator(node, visitors);
			break;
		case "DoWhileStatement":
			walkDoWhileStatement(node, visitors);
			break;
		case "ExportAllDeclaration":
			walkExportAllDeclaration(node, visitors);
			break;
		case "ExportDefaultDeclaration":
			walkExportDefaultDeclaration(node, visitors);
			break;
		case "ExportNamedDeclaration":
			walkExportNamedDeclaration(node, visitors);
			break;
		case "ExportSpecifier":
			walkExportSpecifier(node, visitors);
			break;
		case "ExpressionStatement":
			walkExpressionStatement(node, visitors);
			break;
		case "ForInStatement":
			walkForInStatement(node, visitors);
			break;
		case "ForOfStatement":
			walkForOfStatement(node, visitors);
			break;
		case "ForStatement":
			walkForStatement(node, visitors);
			break;
		case "FunctionDeclaration":
			walkFunctionDeclaration(node, visitors);
			break;
		case "FunctionExpression":
			walkFunctionExpression(node, visitors);
			break;
		case "Identifier":
			walkIdentifier(node, visitors);
			break;
		case "IfStatement":
			walkIfStatement(node, visitors);
			break;
		case "ImportAttribute":
			walkImportAttribute(node, visitors);
			break;
		case "ImportDeclaration":
			walkImportDeclaration(node, visitors);
			break;
		case "ImportDefaultSpecifier":
			walkImportDefaultSpecifier(node, visitors);
			break;
		case "ImportExpression":
			walkImportExpression(node, visitors);
			break;
		case "ImportNamespaceSpecifier":
			walkImportNamespaceSpecifier(node, visitors);
			break;
		case "ImportSpecifier":
			walkImportSpecifier(node, visitors);
			break;
		case "LabeledStatement":
			walkLabeledStatement(node, visitors);
			break;
		case "LogicalExpression":
			walkLogicalExpression(node, visitors);
			break;
		case "MemberExpression":
			walkMemberExpression(node, visitors);
			break;
		case "MetaProperty":
			walkMetaProperty(node, visitors);
			break;
		case "MethodDefinition":
			walkMethodDefinition(node, visitors);
			break;
		case "NewExpression":
			walkNewExpression(node, visitors);
			break;
		case "ObjectExpression":
			walkObjectExpression(node, visitors);
			break;
		case "ObjectPattern":
			walkObjectPattern(node, visitors);
			break;
		case "ParenthesizedExpression":
			walkParenthesizedExpression(node, visitors);
			break;
		case "Program":
			walkProgram(node, visitors);
			break;
		case "Property":
			walkProperty(node, visitors);
			break;
		case "PropertyDefinition":
			walkPropertyDefinition(node, visitors);
			break;
		case "RestElement":
			walkRestElement(node, visitors);
			break;
		case "ReturnStatement":
			walkReturnStatement(node, visitors);
			break;
		case "SequenceExpression":
			walkSequenceExpression(node, visitors);
			break;
		case "SpreadElement":
			walkSpreadElement(node, visitors);
			break;
		case "StaticBlock":
			walkStaticBlock(node, visitors);
			break;
		case "SwitchCase":
			walkSwitchCase(node, visitors);
			break;
		case "SwitchStatement":
			walkSwitchStatement(node, visitors);
			break;
		case "TaggedTemplateExpression":
			walkTaggedTemplateExpression(node, visitors);
			break;
		case "TemplateLiteral":
			walkTemplateLiteral(node, visitors);
			break;
		case "ThrowStatement":
			walkThrowStatement(node, visitors);
			break;
		case "TryStatement":
			walkTryStatement(node, visitors);
			break;
		case "UnaryExpression":
			walkUnaryExpression(node, visitors);
			break;
		case "UpdateExpression":
			walkUpdateExpression(node, visitors);
			break;
		case "V8IntrinsicExpression":
			walkV8IntrinsicExpression(node, visitors);
			break;
		case "VariableDeclaration":
			walkVariableDeclaration(node, visitors);
			break;
		case "VariableDeclarator":
			walkVariableDeclarator(node, visitors);
			break;
		case "WhileStatement":
			walkWhileStatement(node, visitors);
			break;
		case "WithStatement":
			walkWithStatement(node, visitors);
			break;
		case "YieldExpression":
			walkYieldExpression(node, visitors);
			break;
		case "JSXAttribute":
			walkJSXAttribute(node, visitors);
			break;
		case "JSXClosingElement":
			walkJSXClosingElement(node, visitors);
			break;
		case "JSXElement":
			walkJSXElement(node, visitors);
			break;
		case "JSXExpressionContainer":
			walkJSXExpressionContainer(node, visitors);
			break;
		case "JSXFragment":
			walkJSXFragment(node, visitors);
			break;
		case "JSXMemberExpression":
			walkJSXMemberExpression(node, visitors);
			break;
		case "JSXNamespacedName":
			walkJSXNamespacedName(node, visitors);
			break;
		case "JSXOpeningElement":
			walkJSXOpeningElement(node, visitors);
			break;
		case "JSXSpreadAttribute":
			walkJSXSpreadAttribute(node, visitors);
			break;
		case "JSXSpreadChild":
			walkJSXSpreadChild(node, visitors);
			break;
		case "TSAbstractAccessorProperty":
			walkTSAbstractAccessorProperty(node, visitors);
			break;
		case "TSAbstractMethodDefinition":
			walkTSAbstractMethodDefinition(node, visitors);
			break;
		case "TSAbstractPropertyDefinition":
			walkTSAbstractPropertyDefinition(node, visitors);
			break;
		case "TSArrayType":
			walkTSArrayType(node, visitors);
			break;
		case "TSAsExpression":
			walkTSAsExpression(node, visitors);
			break;
		case "TSCallSignatureDeclaration":
			walkTSCallSignatureDeclaration(node, visitors);
			break;
		case "TSClassImplements":
			walkTSClassImplements(node, visitors);
			break;
		case "TSConditionalType":
			walkTSConditionalType(node, visitors);
			break;
		case "TSConstructSignatureDeclaration":
			walkTSConstructSignatureDeclaration(node, visitors);
			break;
		case "TSConstructorType":
			walkTSConstructorType(node, visitors);
			break;
		case "TSDeclareFunction":
			walkTSDeclareFunction(node, visitors);
			break;
		case "TSEmptyBodyFunctionExpression":
			walkTSEmptyBodyFunctionExpression(node, visitors);
			break;
		case "TSEnumBody":
			walkTSEnumBody(node, visitors);
			break;
		case "TSEnumDeclaration":
			walkTSEnumDeclaration(node, visitors);
			break;
		case "TSEnumMember":
			walkTSEnumMember(node, visitors);
			break;
		case "TSExportAssignment":
			walkTSExportAssignment(node, visitors);
			break;
		case "TSExternalModuleReference":
			walkTSExternalModuleReference(node, visitors);
			break;
		case "TSFunctionType":
			walkTSFunctionType(node, visitors);
			break;
		case "TSImportEqualsDeclaration":
			walkTSImportEqualsDeclaration(node, visitors);
			break;
		case "TSImportType":
			walkTSImportType(node, visitors);
			break;
		case "TSIndexSignature":
			walkTSIndexSignature(node, visitors);
			break;
		case "TSIndexedAccessType":
			walkTSIndexedAccessType(node, visitors);
			break;
		case "TSInferType":
			walkTSInferType(node, visitors);
			break;
		case "TSInstantiationExpression":
			walkTSInstantiationExpression(node, visitors);
			break;
		case "TSInterfaceBody":
			walkTSInterfaceBody(node, visitors);
			break;
		case "TSInterfaceDeclaration":
			walkTSInterfaceDeclaration(node, visitors);
			break;
		case "TSInterfaceHeritage":
			walkTSInterfaceHeritage(node, visitors);
			break;
		case "TSIntersectionType":
			walkTSIntersectionType(node, visitors);
			break;
		case "TSJSDocNonNullableType":
			walkTSJSDocNonNullableType(node, visitors);
			break;
		case "TSJSDocNullableType":
			walkTSJSDocNullableType(node, visitors);
			break;
		case "TSLiteralType":
			walkTSLiteralType(node, visitors);
			break;
		case "TSMappedType":
			walkTSMappedType(node, visitors);
			break;
		case "TSMethodSignature":
			walkTSMethodSignature(node, visitors);
			break;
		case "TSModuleBlock":
			walkTSModuleBlock(node, visitors);
			break;
		case "TSModuleDeclaration":
			walkTSModuleDeclaration(node, visitors);
			break;
		case "TSNamedTupleMember":
			walkTSNamedTupleMember(node, visitors);
			break;
		case "TSNamespaceExportDeclaration":
			walkTSNamespaceExportDeclaration(node, visitors);
			break;
		case "TSNonNullExpression":
			walkTSNonNullExpression(node, visitors);
			break;
		case "TSOptionalType":
			walkTSOptionalType(node, visitors);
			break;
		case "TSParameterProperty":
			walkTSParameterProperty(node, visitors);
			break;
		case "TSParenthesizedType":
			walkTSParenthesizedType(node, visitors);
			break;
		case "TSPropertySignature":
			walkTSPropertySignature(node, visitors);
			break;
		case "TSQualifiedName":
			walkTSQualifiedName(node, visitors);
			break;
		case "TSRestType":
			walkTSRestType(node, visitors);
			break;
		case "TSSatisfiesExpression":
			walkTSSatisfiesExpression(node, visitors);
			break;
		case "TSTemplateLiteralType":
			walkTSTemplateLiteralType(node, visitors);
			break;
		case "TSTupleType":
			walkTSTupleType(node, visitors);
			break;
		case "TSTypeAliasDeclaration":
			walkTSTypeAliasDeclaration(node, visitors);
			break;
		case "TSTypeAnnotation":
			walkTSTypeAnnotation(node, visitors);
			break;
		case "TSTypeAssertion":
			walkTSTypeAssertion(node, visitors);
			break;
		case "TSTypeLiteral":
			walkTSTypeLiteral(node, visitors);
			break;
		case "TSTypeOperator":
			walkTSTypeOperator(node, visitors);
			break;
		case "TSTypeParameter":
			walkTSTypeParameter(node, visitors);
			break;
		case "TSTypeParameterDeclaration":
			walkTSTypeParameterDeclaration(node, visitors);
			break;
		case "TSTypeParameterInstantiation":
			walkTSTypeParameterInstantiation(node, visitors);
			break;
		case "TSTypePredicate":
			walkTSTypePredicate(node, visitors);
			break;
		case "TSTypeQuery":
			walkTSTypeQuery(node, visitors);
			break;
		case "TSTypeReference":
			walkTSTypeReference(node, visitors);
			break;
		case "TSUnionType":
			walkTSUnionType(node, visitors);
			break;
	}
}
function walkDebuggerStatement(node, visitors) {
	let visit = visitors[0];
	visit !== null && visit(node);
}
function walkEmptyStatement(node, visitors) {
	let visit = visitors[1];
	visit !== null && visit(node);
}
function walkLiteral(node, visitors) {
	let visit = visitors[2];
	visit !== null && visit(node);
}
function walkPrivateIdentifier(node, visitors) {
	let visit = visitors[3];
	visit !== null && visit(node);
}
function walkSuper(node, visitors) {
	let visit = visitors[4];
	visit !== null && visit(node);
}
function walkTemplateElement(node, visitors) {
	let visit = visitors[5];
	visit !== null && visit(node);
}
function walkThisExpression(node, visitors) {
	let visit = visitors[6];
	visit !== null && visit(node);
}
function walkJSXClosingFragment(node, visitors) {
	let visit = visitors[7];
	visit !== null && visit(node);
}
function walkJSXEmptyExpression(node, visitors) {
	let visit = visitors[8];
	visit !== null && visit(node);
}
function walkJSXIdentifier(node, visitors) {
	let visit = visitors[9];
	visit !== null && visit(node);
}
function walkJSXOpeningFragment(node, visitors) {
	let visit = visitors[10];
	visit !== null && visit(node);
}
function walkJSXText(node, visitors) {
	let visit = visitors[11];
	visit !== null && visit(node);
}
function walkTSAnyKeyword(node, visitors) {
	let visit = visitors[12];
	visit !== null && visit(node);
}
function walkTSBigIntKeyword(node, visitors) {
	let visit = visitors[13];
	visit !== null && visit(node);
}
function walkTSBooleanKeyword(node, visitors) {
	let visit = visitors[14];
	visit !== null && visit(node);
}
function walkTSIntrinsicKeyword(node, visitors) {
	let visit = visitors[15];
	visit !== null && visit(node);
}
function walkTSJSDocUnknownType(node, visitors) {
	let visit = visitors[16];
	visit !== null && visit(node);
}
function walkTSNeverKeyword(node, visitors) {
	let visit = visitors[17];
	visit !== null && visit(node);
}
function walkTSNullKeyword(node, visitors) {
	let visit = visitors[18];
	visit !== null && visit(node);
}
function walkTSNumberKeyword(node, visitors) {
	let visit = visitors[19];
	visit !== null && visit(node);
}
function walkTSObjectKeyword(node, visitors) {
	let visit = visitors[20];
	visit !== null && visit(node);
}
function walkTSStringKeyword(node, visitors) {
	let visit = visitors[21];
	visit !== null && visit(node);
}
function walkTSSymbolKeyword(node, visitors) {
	let visit = visitors[22];
	visit !== null && visit(node);
}
function walkTSThisType(node, visitors) {
	let visit = visitors[23];
	visit !== null && visit(node);
}
function walkTSUndefinedKeyword(node, visitors) {
	let visit = visitors[24];
	visit !== null && visit(node);
}
function walkTSUnknownKeyword(node, visitors) {
	let visit = visitors[25];
	visit !== null && visit(node);
}
function walkTSVoidKeyword(node, visitors) {
	let visit = visitors[26];
	visit !== null && visit(node);
}
function walkAccessorProperty(node, visitors) {
	let enterExit = visitors[27], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkArrayExpression(node, visitors) {
	let enterExit = visitors[28], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.elements, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkArrayPattern(node, visitors) {
	let enterExit = visitors[29], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.elements, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkArrowFunctionExpression(node, visitors) {
	let enterExit = visitors[30], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkAssignmentExpression(node, visitors) {
	let enterExit = visitors[31], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkAssignmentPattern(node, visitors) {
	let enterExit = visitors[32], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.left, visitors), walkNode(node.right, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkAwaitExpression(node, visitors) {
	let enterExit = visitors[33], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkBinaryExpression(node, visitors) {
	let enterExit = visitors[34], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkBlockStatement(node, visitors) {
	let enterExit = visitors[35], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkBreakStatement(node, visitors) {
	let enterExit = visitors[36], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.label, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkCallExpression(node, visitors) {
	let enterExit = visitors[37], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.callee, visitors), walkNode(node.typeArguments, visitors), walkNode(node.arguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkCatchClause(node, visitors) {
	let enterExit = visitors[38], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.param, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkChainExpression(node, visitors) {
	let enterExit = visitors[39], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkClassBody(node, visitors) {
	let enterExit = visitors[40], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkClassDeclaration(node, visitors) {
	let enterExit = visitors[41], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.superClass, visitors), walkNode(node.superTypeArguments, visitors), walkNode(node.implements, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkClassExpression(node, visitors) {
	let enterExit = visitors[42], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.superClass, visitors), walkNode(node.superTypeArguments, visitors), walkNode(node.implements, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkConditionalExpression(node, visitors) {
	let enterExit = visitors[43], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.consequent, visitors), walkNode(node.alternate, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkContinueStatement(node, visitors) {
	let enterExit = visitors[44], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.label, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkDecorator(node, visitors) {
	let enterExit = visitors[45], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkDoWhileStatement(node, visitors) {
	let enterExit = visitors[46], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.body, visitors), walkNode(node.test, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportAllDeclaration(node, visitors) {
	let enterExit = visitors[47], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.exported, visitors), walkNode(node.source, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportDefaultDeclaration(node, visitors) {
	let enterExit = visitors[48], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.declaration, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportNamedDeclaration(node, visitors) {
	let enterExit = visitors[49], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.declaration, visitors), walkNode(node.specifiers, visitors), walkNode(node.source, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExportSpecifier(node, visitors) {
	let enterExit = visitors[50], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.local, visitors), walkNode(node.exported, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkExpressionStatement(node, visitors) {
	let enterExit = visitors[51], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkForInStatement(node, visitors) {
	let enterExit = visitors[52], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkForOfStatement(node, visitors) {
	let enterExit = visitors[53], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkForStatement(node, visitors) {
	let enterExit = visitors[54], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.init, visitors), walkNode(node.test, visitors), walkNode(node.update, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkFunctionDeclaration(node, visitors) {
	let enterExit = visitors[55], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkFunctionExpression(node, visitors) {
	let enterExit = visitors[56], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkIdentifier(node, visitors) {
	let enterExit = visitors[57], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkIfStatement(node, visitors) {
	let enterExit = visitors[58], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.consequent, visitors), walkNode(node.alternate, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportAttribute(node, visitors) {
	let enterExit = visitors[59], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportDeclaration(node, visitors) {
	let enterExit = visitors[60], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.specifiers, visitors), walkNode(node.source, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportDefaultSpecifier(node, visitors) {
	let enterExit = visitors[61], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.local, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportExpression(node, visitors) {
	let enterExit = visitors[62], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.source, visitors), walkNode(node.options, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportNamespaceSpecifier(node, visitors) {
	let enterExit = visitors[63], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.local, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkImportSpecifier(node, visitors) {
	let enterExit = visitors[64], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.imported, visitors), walkNode(node.local, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkLabeledStatement(node, visitors) {
	let enterExit = visitors[65], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.label, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkLogicalExpression(node, visitors) {
	let enterExit = visitors[66], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkMemberExpression(node, visitors) {
	let enterExit = visitors[67], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.object, visitors), walkNode(node.property, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkMetaProperty(node, visitors) {
	let enterExit = visitors[68], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.meta, visitors), walkNode(node.property, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkMethodDefinition(node, visitors) {
	let enterExit = visitors[69], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkNewExpression(node, visitors) {
	let enterExit = visitors[70], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.callee, visitors), walkNode(node.typeArguments, visitors), walkNode(node.arguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkObjectExpression(node, visitors) {
	let enterExit = visitors[71], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.properties, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkObjectPattern(node, visitors) {
	let enterExit = visitors[72], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.properties, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkParenthesizedExpression(node, visitors) {
	let enterExit = visitors[73], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkProgram(node, visitors) {
	let enterExit = visitors[74], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkProperty(node, visitors) {
	let enterExit = visitors[75], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkPropertyDefinition(node, visitors) {
	let enterExit = visitors[76], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkRestElement(node, visitors) {
	let enterExit = visitors[77], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.argument, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkReturnStatement(node, visitors) {
	let enterExit = visitors[78], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSequenceExpression(node, visitors) {
	let enterExit = visitors[79], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expressions, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSpreadElement(node, visitors) {
	let enterExit = visitors[80], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkStaticBlock(node, visitors) {
	let enterExit = visitors[81], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSwitchCase(node, visitors) {
	let enterExit = visitors[82], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.consequent, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkSwitchStatement(node, visitors) {
	let enterExit = visitors[83], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.discriminant, visitors), walkNode(node.cases, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTaggedTemplateExpression(node, visitors) {
	let enterExit = visitors[84], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.tag, visitors), walkNode(node.typeArguments, visitors), walkNode(node.quasi, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTemplateLiteral(node, visitors) {
	let enterExit = visitors[85], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.quasis, visitors), walkNode(node.expressions, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkThrowStatement(node, visitors) {
	let enterExit = visitors[86], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTryStatement(node, visitors) {
	let enterExit = visitors[87], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.block, visitors), walkNode(node.handler, visitors), walkNode(node.finalizer, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkUnaryExpression(node, visitors) {
	let enterExit = visitors[88], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkUpdateExpression(node, visitors) {
	let enterExit = visitors[89], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkV8IntrinsicExpression(node, visitors) {
	let enterExit = visitors[90], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.arguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkVariableDeclaration(node, visitors) {
	let enterExit = visitors[91], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.declarations, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkVariableDeclarator(node, visitors) {
	let enterExit = visitors[92], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.init, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkWhileStatement(node, visitors) {
	let enterExit = visitors[93], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.test, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkWithStatement(node, visitors) {
	let enterExit = visitors[94], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.object, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkYieldExpression(node, visitors) {
	let enterExit = visitors[95], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXAttribute(node, visitors) {
	let enterExit = visitors[96], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXClosingElement(node, visitors) {
	let enterExit = visitors[97], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.name, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXElement(node, visitors) {
	let enterExit = visitors[98], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.openingElement, visitors), walkNode(node.children, visitors), walkNode(node.closingElement, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXExpressionContainer(node, visitors) {
	let enterExit = visitors[99], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXFragment(node, visitors) {
	let enterExit = visitors[100], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.openingFragment, visitors), walkNode(node.children, visitors), walkNode(node.closingFragment, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXMemberExpression(node, visitors) {
	let enterExit = visitors[101], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.object, visitors), walkNode(node.property, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXNamespacedName(node, visitors) {
	let enterExit = visitors[102], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.namespace, visitors), walkNode(node.name, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXOpeningElement(node, visitors) {
	let enterExit = visitors[103], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.typeArguments, visitors), walkNode(node.attributes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXSpreadAttribute(node, visitors) {
	let enterExit = visitors[104], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.argument, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkJSXSpreadChild(node, visitors) {
	let enterExit = visitors[105], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAbstractAccessorProperty(node, visitors) {
	let enterExit = visitors[106], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAbstractMethodDefinition(node, visitors) {
	let enterExit = visitors[107], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.value, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAbstractPropertyDefinition(node, visitors) {
	let enterExit = visitors[108], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSArrayType(node, visitors) {
	let enterExit = visitors[109], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.elementType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSAsExpression(node, visitors) {
	let enterExit = visitors[110], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSCallSignatureDeclaration(node, visitors) {
	let enterExit = visitors[111], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSClassImplements(node, visitors) {
	let enterExit = visitors[112], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSConditionalType(node, visitors) {
	let enterExit = visitors[113], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.checkType, visitors), walkNode(node.extendsType, visitors), walkNode(node.trueType, visitors), walkNode(node.falseType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSConstructSignatureDeclaration(node, visitors) {
	let enterExit = visitors[114], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSConstructorType(node, visitors) {
	let enterExit = visitors[115], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSDeclareFunction(node, visitors) {
	let enterExit = visitors[116], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEmptyBodyFunctionExpression(node, visitors) {
	let enterExit = visitors[117], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEnumBody(node, visitors) {
	let enterExit = visitors[118], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.members, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEnumDeclaration(node, visitors) {
	let enterExit = visitors[119], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSEnumMember(node, visitors) {
	let enterExit = visitors[120], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.initializer, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSExportAssignment(node, visitors) {
	let enterExit = visitors[121], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSExternalModuleReference(node, visitors) {
	let enterExit = visitors[122], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSFunctionType(node, visitors) {
	let enterExit = visitors[123], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSImportEqualsDeclaration(node, visitors) {
	let enterExit = visitors[124], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.moduleReference, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSImportType(node, visitors) {
	let enterExit = visitors[125], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.source, visitors), walkNode(node.options, visitors), walkNode(node.qualifier, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSIndexSignature(node, visitors) {
	let enterExit = visitors[126], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.parameters, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSIndexedAccessType(node, visitors) {
	let enterExit = visitors[127], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.objectType, visitors), walkNode(node.indexType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInferType(node, visitors) {
	let enterExit = visitors[128], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeParameter, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInstantiationExpression(node, visitors) {
	let enterExit = visitors[129], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInterfaceBody(node, visitors) {
	let enterExit = visitors[130], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInterfaceDeclaration(node, visitors) {
	let enterExit = visitors[131], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.extends, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSInterfaceHeritage(node, visitors) {
	let enterExit = visitors[132], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSIntersectionType(node, visitors) {
	let enterExit = visitors[133], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.types, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSJSDocNonNullableType(node, visitors) {
	let enterExit = visitors[134], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSJSDocNullableType(node, visitors) {
	let enterExit = visitors[135], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSLiteralType(node, visitors) {
	let enterExit = visitors[136], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.literal, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSMappedType(node, visitors) {
	let enterExit = visitors[137], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.constraint, visitors), walkNode(node.nameType, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSMethodSignature(node, visitors) {
	let enterExit = visitors[138], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.typeParameters, visitors), walkNode(node.params, visitors), walkNode(node.returnType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSModuleBlock(node, visitors) {
	let enterExit = visitors[139], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSModuleDeclaration(node, visitors) {
	let enterExit = visitors[140], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.body, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSNamedTupleMember(node, visitors) {
	let enterExit = visitors[141], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.label, visitors), walkNode(node.elementType, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSNamespaceExportDeclaration(node, visitors) {
	let enterExit = visitors[142], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSNonNullExpression(node, visitors) {
	let enterExit = visitors[143], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSOptionalType(node, visitors) {
	let enterExit = visitors[144], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSParameterProperty(node, visitors) {
	let enterExit = visitors[145], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.decorators, visitors), walkNode(node.parameter, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSParenthesizedType(node, visitors) {
	let enterExit = visitors[146], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSPropertySignature(node, visitors) {
	let enterExit = visitors[147], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.key, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSQualifiedName(node, visitors) {
	let enterExit = visitors[148], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.left, visitors), walkNode(node.right, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSRestType(node, visitors) {
	let enterExit = visitors[149], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSSatisfiesExpression(node, visitors) {
	let enterExit = visitors[150], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.expression, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTemplateLiteralType(node, visitors) {
	let enterExit = visitors[151], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.quasis, visitors), walkNode(node.types, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTupleType(node, visitors) {
	let enterExit = visitors[152], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.elementTypes, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeAliasDeclaration(node, visitors) {
	let enterExit = visitors[153], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.id, visitors), walkNode(node.typeParameters, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeAnnotation(node, visitors) {
	let enterExit = visitors[154], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeAssertion(node, visitors) {
	let enterExit = visitors[155], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), walkNode(node.expression, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeLiteral(node, visitors) {
	let enterExit = visitors[156], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.members, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeOperator(node, visitors) {
	let enterExit = visitors[157], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeParameter(node, visitors) {
	let enterExit = visitors[158], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.name, visitors), walkNode(node.constraint, visitors), walkNode(node.default, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeParameterDeclaration(node, visitors) {
	let enterExit = visitors[159], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.params, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeParameterInstantiation(node, visitors) {
	let enterExit = visitors[160], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.params, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypePredicate(node, visitors) {
	let enterExit = visitors[161], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.parameterName, visitors), walkNode(node.typeAnnotation, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeQuery(node, visitors) {
	let enterExit = visitors[162], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.exprName, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSTypeReference(node, visitors) {
	let enterExit = visitors[163], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.typeName, visitors), walkNode(node.typeArguments, visitors), ancestors.shift(), exit !== null && exit(node);
}
function walkTSUnionType(node, visitors) {
	let enterExit = visitors[164], exit = null, enter;
	enterExit !== null && ({enter, exit} = enterExit, enter !== null && enter(node)), ancestors.unshift(node), walkNode(node.types, visitors), ancestors.shift(), exit !== null && exit(node);
}
var import_code_path_analyzer = /* @__PURE__ */ __toESM(require_code_path_analyzer(), 1), import_traverser = /* @__PURE__ */ __toESM(require_traverser(), 1);
const stepTypeIds = [], stepData = [];
function resetCfgWalk() {
	stepTypeIds.length = 0, stepData.length = 0;
}
function walkProgramWithCfg(ast, visitors) {
	prepareSteps(ast);
	let stepsLen = stepTypeIds.length;
	for (let i = 0; i < stepsLen; i++) {
		let typeId = stepTypeIds[i];
		if (typeId < 165) {
			let node = stepData[i], visit = visitors[typeId];
			if (typeId < 27) visit !== null && visit(node);
			else {
				if (visit !== null) {
					let { enter } = visit;
					enter !== null && enter(node);
				}
				ancestors.unshift(node);
			}
		} else if (typeId >= 256) {
			typeId -= 256;
			let node = stepData[i];
			ancestors.shift();
			let enterExit = visitors[typeId];
			if (enterExit !== null) {
				let { exit } = enterExit;
				exit !== null && exit(node);
			}
		} else {
			let visit = visitors[typeId];
			visit !== null && visit.apply(void 0, stepData[i]);
		}
	}
	stepTypeIds.length = 0, stepData.length = 0;
}
function prepareSteps(ast) {
	let analyzer = new import_code_path_analyzer.default({
		enterNode(node) {
			let typeId = NODE_TYPE_IDS_MAP.get(node.type);
			stepTypeIds.push(typeId), stepData.push(node);
		},
		leaveNode(node) {
			let typeId = NODE_TYPE_IDS_MAP.get(node.type);
			typeId >= 27 && (stepTypeIds.push(typeId + 256), stepData.push(node));
		},
		emit(eventName, args) {
			let typeId = NODE_TYPE_IDS_MAP.get(eventName);
			stepTypeIds.push(typeId), stepData.push(args);
		}
	});
	import_traverser.default.traverse(ast, {
		enter(node) {
			analyzer.enterNode(node);
		},
		leave(node) {
			analyzer.leaveNode(node);
		},
		visitorKeys: keys_default
	});
}
const { matches: esqueryMatches, parse: esqueryParse } = (/* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(e, t) {
		typeof exports == "object" && module !== void 0 ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e ||= self).esquery = t();
	})(exports, (function() {
		function e(t) {
			return (e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
				return typeof e;
			} : function(e) {
				return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
			})(t);
		}
		function t(e, t) {
			return function(e) {
				if (Array.isArray(e)) return e;
			}(e) || function(e, t) {
				var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
				if (r != null) {
					var n, o, a, i, s = [], u = !0, l = !1;
					try {
						if (a = (r = r.call(e)).next, t === 0) {
							if (Object(r) !== r) return;
							u = !1;
						} else for (; !(u = (n = a.call(r)).done) && (s.push(n.value), s.length !== t); u = !0);
					} catch (e) {
						l = !0, o = e;
					} finally {
						try {
							if (!u && r.return != null && (i = r.return(), Object(i) !== i)) return;
						} finally {
							if (l) throw o;
						}
					}
					return s;
				}
			}(e, t) || n(e, t) || function() {
				throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
			}();
		}
		function r(e) {
			return function(e) {
				if (Array.isArray(e)) return o(e);
			}(e) || function(e) {
				if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
			}(e) || n(e) || function() {
				throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
			}();
		}
		function n(e, t) {
			if (e) {
				if (typeof e == "string") return o(e, t);
				var r = Object.prototype.toString.call(e).slice(8, -1);
				return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? o(e, t) : void 0;
			}
		}
		function o(e, t) {
			(t == null || t > e.length) && (t = e.length);
			for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
			return n;
		}
		function a(e, t) {
			return e(t = { exports: {} }, t.exports), t.exports;
		}
		var i = a((function(e, t) {
			(function e(t) {
				var r, n, o, a, i, s;
				function u(e) {
					var t, r, n = {};
					for (t in e) e.hasOwnProperty(t) && (r = e[t], n[t] = typeof r == "object" && r ? u(r) : r);
					return n;
				}
				function l(e, t) {
					this.parent = e, this.key = t;
				}
				function c(e, t, r, n) {
					this.node = e, this.path = t, this.wrap = r, this.ref = n;
				}
				function f() {}
				function p(e) {
					return typeof e == "object" && !!e && typeof e.type == "string";
				}
				function h(e, t) {
					return (e === r.ObjectExpression || e === r.ObjectPattern) && t === "properties";
				}
				function y(e, t) {
					for (var r = e.length - 1; r >= 0; --r) if (e[r].node === t) return !0;
					return !1;
				}
				function d(e, t) {
					return new f().traverse(e, t);
				}
				function m(e, t) {
					var r;
					return r = function(e, t) {
						var r, n, o, a;
						for (n = e.length, o = 0; n;) t(e[a = o + (r = n >>> 1)]) ? n = r : (o = a + 1, n -= r + 1);
						return o;
					}(t, (function(t) {
						return t.range[0] > e.range[0];
					})), e.extendedRange = [e.range[0], e.range[1]], r !== t.length && (e.extendedRange[1] = t[r].range[0]), --r >= 0 && (e.extendedRange[0] = t[r].range[1]), e;
				}
				return r = {
					AssignmentExpression: "AssignmentExpression",
					AssignmentPattern: "AssignmentPattern",
					ArrayExpression: "ArrayExpression",
					ArrayPattern: "ArrayPattern",
					ArrowFunctionExpression: "ArrowFunctionExpression",
					AwaitExpression: "AwaitExpression",
					BlockStatement: "BlockStatement",
					BinaryExpression: "BinaryExpression",
					BreakStatement: "BreakStatement",
					CallExpression: "CallExpression",
					CatchClause: "CatchClause",
					ChainExpression: "ChainExpression",
					ClassBody: "ClassBody",
					ClassDeclaration: "ClassDeclaration",
					ClassExpression: "ClassExpression",
					ComprehensionBlock: "ComprehensionBlock",
					ComprehensionExpression: "ComprehensionExpression",
					ConditionalExpression: "ConditionalExpression",
					ContinueStatement: "ContinueStatement",
					DebuggerStatement: "DebuggerStatement",
					DirectiveStatement: "DirectiveStatement",
					DoWhileStatement: "DoWhileStatement",
					EmptyStatement: "EmptyStatement",
					ExportAllDeclaration: "ExportAllDeclaration",
					ExportDefaultDeclaration: "ExportDefaultDeclaration",
					ExportNamedDeclaration: "ExportNamedDeclaration",
					ExportSpecifier: "ExportSpecifier",
					ExpressionStatement: "ExpressionStatement",
					ForStatement: "ForStatement",
					ForInStatement: "ForInStatement",
					ForOfStatement: "ForOfStatement",
					FunctionDeclaration: "FunctionDeclaration",
					FunctionExpression: "FunctionExpression",
					GeneratorExpression: "GeneratorExpression",
					Identifier: "Identifier",
					IfStatement: "IfStatement",
					ImportExpression: "ImportExpression",
					ImportDeclaration: "ImportDeclaration",
					ImportDefaultSpecifier: "ImportDefaultSpecifier",
					ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
					ImportSpecifier: "ImportSpecifier",
					Literal: "Literal",
					LabeledStatement: "LabeledStatement",
					LogicalExpression: "LogicalExpression",
					MemberExpression: "MemberExpression",
					MetaProperty: "MetaProperty",
					MethodDefinition: "MethodDefinition",
					ModuleSpecifier: "ModuleSpecifier",
					NewExpression: "NewExpression",
					ObjectExpression: "ObjectExpression",
					ObjectPattern: "ObjectPattern",
					PrivateIdentifier: "PrivateIdentifier",
					Program: "Program",
					Property: "Property",
					PropertyDefinition: "PropertyDefinition",
					RestElement: "RestElement",
					ReturnStatement: "ReturnStatement",
					SequenceExpression: "SequenceExpression",
					SpreadElement: "SpreadElement",
					Super: "Super",
					SwitchStatement: "SwitchStatement",
					SwitchCase: "SwitchCase",
					TaggedTemplateExpression: "TaggedTemplateExpression",
					TemplateElement: "TemplateElement",
					TemplateLiteral: "TemplateLiteral",
					ThisExpression: "ThisExpression",
					ThrowStatement: "ThrowStatement",
					TryStatement: "TryStatement",
					UnaryExpression: "UnaryExpression",
					UpdateExpression: "UpdateExpression",
					VariableDeclaration: "VariableDeclaration",
					VariableDeclarator: "VariableDeclarator",
					WhileStatement: "WhileStatement",
					WithStatement: "WithStatement",
					YieldExpression: "YieldExpression"
				}, o = {
					AssignmentExpression: ["left", "right"],
					AssignmentPattern: ["left", "right"],
					ArrayExpression: ["elements"],
					ArrayPattern: ["elements"],
					ArrowFunctionExpression: ["params", "body"],
					AwaitExpression: ["argument"],
					BlockStatement: ["body"],
					BinaryExpression: ["left", "right"],
					BreakStatement: ["label"],
					CallExpression: ["callee", "arguments"],
					CatchClause: ["param", "body"],
					ChainExpression: ["expression"],
					ClassBody: ["body"],
					ClassDeclaration: [
						"id",
						"superClass",
						"body"
					],
					ClassExpression: [
						"id",
						"superClass",
						"body"
					],
					ComprehensionBlock: ["left", "right"],
					ComprehensionExpression: [
						"blocks",
						"filter",
						"body"
					],
					ConditionalExpression: [
						"test",
						"consequent",
						"alternate"
					],
					ContinueStatement: ["label"],
					DebuggerStatement: [],
					DirectiveStatement: [],
					DoWhileStatement: ["body", "test"],
					EmptyStatement: [],
					ExportAllDeclaration: ["source"],
					ExportDefaultDeclaration: ["declaration"],
					ExportNamedDeclaration: [
						"declaration",
						"specifiers",
						"source"
					],
					ExportSpecifier: ["exported", "local"],
					ExpressionStatement: ["expression"],
					ForStatement: [
						"init",
						"test",
						"update",
						"body"
					],
					ForInStatement: [
						"left",
						"right",
						"body"
					],
					ForOfStatement: [
						"left",
						"right",
						"body"
					],
					FunctionDeclaration: [
						"id",
						"params",
						"body"
					],
					FunctionExpression: [
						"id",
						"params",
						"body"
					],
					GeneratorExpression: [
						"blocks",
						"filter",
						"body"
					],
					Identifier: [],
					IfStatement: [
						"test",
						"consequent",
						"alternate"
					],
					ImportExpression: ["source"],
					ImportDeclaration: ["specifiers", "source"],
					ImportDefaultSpecifier: ["local"],
					ImportNamespaceSpecifier: ["local"],
					ImportSpecifier: ["imported", "local"],
					Literal: [],
					LabeledStatement: ["label", "body"],
					LogicalExpression: ["left", "right"],
					MemberExpression: ["object", "property"],
					MetaProperty: ["meta", "property"],
					MethodDefinition: ["key", "value"],
					ModuleSpecifier: [],
					NewExpression: ["callee", "arguments"],
					ObjectExpression: ["properties"],
					ObjectPattern: ["properties"],
					PrivateIdentifier: [],
					Program: ["body"],
					Property: ["key", "value"],
					PropertyDefinition: ["key", "value"],
					RestElement: ["argument"],
					ReturnStatement: ["argument"],
					SequenceExpression: ["expressions"],
					SpreadElement: ["argument"],
					Super: [],
					SwitchStatement: ["discriminant", "cases"],
					SwitchCase: ["test", "consequent"],
					TaggedTemplateExpression: ["tag", "quasi"],
					TemplateElement: [],
					TemplateLiteral: ["quasis", "expressions"],
					ThisExpression: [],
					ThrowStatement: ["argument"],
					TryStatement: [
						"block",
						"handler",
						"finalizer"
					],
					UnaryExpression: ["argument"],
					UpdateExpression: ["argument"],
					VariableDeclaration: ["declarations"],
					VariableDeclarator: ["id", "init"],
					WhileStatement: ["test", "body"],
					WithStatement: ["object", "body"],
					YieldExpression: ["argument"]
				}, n = {
					Break: a = {},
					Skip: i = {},
					Remove: s = {}
				}, l.prototype.replace = function(e) {
					this.parent[this.key] = e;
				}, l.prototype.remove = function() {
					return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
				}, f.prototype.path = function() {
					var e, t, r, n, o;
					function a(e, t) {
						if (Array.isArray(t)) for (r = 0, n = t.length; r < n; ++r) e.push(t[r]);
						else e.push(t);
					}
					if (!this.__current.path) return null;
					for (o = [], e = 2, t = this.__leavelist.length; e < t; ++e) a(o, this.__leavelist[e].path);
					return a(o, this.__current.path), o;
				}, f.prototype.type = function() {
					return this.current().type || this.__current.wrap;
				}, f.prototype.parents = function() {
					var e, t, r;
					for (r = [], e = 1, t = this.__leavelist.length; e < t; ++e) r.push(this.__leavelist[e].node);
					return r;
				}, f.prototype.current = function() {
					return this.__current.node;
				}, f.prototype.__execute = function(e, t) {
					var r, n;
					return n = void 0, r = this.__current, this.__current = t, this.__state = null, e && (n = e.call(this, t.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = r, n;
				}, f.prototype.notify = function(e) {
					this.__state = e;
				}, f.prototype.skip = function() {
					this.notify(i);
				}, f.prototype.break = function() {
					this.notify(a);
				}, f.prototype.remove = function() {
					this.notify(s);
				}, f.prototype.__initialize = function(e, t) {
					this.visitor = t, this.root = e, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, t.fallback === "iteration" ? this.__fallback = Object.keys : typeof t.fallback == "function" && (this.__fallback = t.fallback), this.__keys = o, t.keys && (this.__keys = Object.assign(Object.create(this.__keys), t.keys));
				}, f.prototype.traverse = function(e, t) {
					var r, n, o, s, u, l, f, d, m, x, v, g;
					for (this.__initialize(e, t), g = {}, r = this.__worklist, n = this.__leavelist, r.push(new c(e, null, null, null)), n.push(new c(null, null, null, null)); r.length;) if ((o = r.pop()) !== g) {
						if (o.node) {
							if (l = this.__execute(t.enter, o), this.__state === a || l === a) return;
							if (r.push(g), n.push(o), this.__state === i || l === i) continue;
							if (u = (s = o.node).type || o.wrap, !(x = this.__keys[u])) {
								if (!this.__fallback) throw Error("Unknown node type " + u + ".");
								x = this.__fallback(s);
							}
							for (d = x.length; --d >= 0;) if (v = s[f = x[d]]) {
								if (Array.isArray(v)) {
									for (m = v.length; --m >= 0;) if (v[m] && !y(n, v[m])) {
										if (h(u, x[d])) o = new c(v[m], [f, m], "Property", null);
										else {
											if (!p(v[m])) continue;
											o = new c(v[m], [f, m], null, null);
										}
										r.push(o);
									}
								} else if (p(v)) {
									if (y(n, v)) continue;
									r.push(new c(v, f, null, null));
								}
							}
						}
					} else if (o = n.pop(), l = this.__execute(t.leave, o), this.__state === a || l === a) return;
				}, f.prototype.replace = function(e, t) {
					var r, n, o, u, f, y, d, m, x, v, g, A, E;
					function b(e) {
						var t, n, o, a;
						if (e.ref.remove()) {
							for (n = e.ref.key, a = e.ref.parent, t = r.length; t--;) if ((o = r[t]).ref && o.ref.parent === a) {
								if (o.ref.key < n) break;
								--o.ref.key;
							}
						}
					}
					for (this.__initialize(e, t), g = {}, r = this.__worklist, n = this.__leavelist, y = new c(e, null, null, new l(A = { root: e }, "root")), r.push(y), n.push(y); r.length;) if ((y = r.pop()) !== g) {
						if ((f = this.__execute(t.enter, y)) !== void 0 && f !== a && f !== i && f !== s && (y.ref.replace(f), y.node = f), this.__state !== s && f !== s || (b(y), y.node = null), this.__state === a || f === a) return A.root;
						if ((o = y.node) && (r.push(g), n.push(y), this.__state !== i && f !== i)) {
							if (u = o.type || y.wrap, !(x = this.__keys[u])) {
								if (!this.__fallback) throw Error("Unknown node type " + u + ".");
								x = this.__fallback(o);
							}
							for (d = x.length; --d >= 0;) if (v = o[E = x[d]]) if (Array.isArray(v)) {
								for (m = v.length; --m >= 0;) if (v[m]) {
									if (h(u, x[d])) y = new c(v[m], [E, m], "Property", new l(v, m));
									else {
										if (!p(v[m])) continue;
										y = new c(v[m], [E, m], null, new l(v, m));
									}
									r.push(y);
								}
							} else p(v) && r.push(new c(v, E, null, new l(o, E)));
						}
					} else if (y = n.pop(), (f = this.__execute(t.leave, y)) !== void 0 && f !== a && f !== i && f !== s && y.ref.replace(f), this.__state !== s && f !== s || b(y), this.__state === a || f === a) return A.root;
					return A.root;
				}, t.Syntax = r, t.traverse = d, t.replace = function(e, t) {
					return new f().replace(e, t);
				}, t.attachComments = function(e, t, r) {
					var o, a, i, s, l = [];
					if (!e.range) throw Error("attachComments needs range information");
					if (!r.length) {
						if (t.length) {
							for (i = 0, a = t.length; i < a; i += 1) (o = u(t[i])).extendedRange = [0, e.range[0]], l.push(o);
							e.leadingComments = l;
						}
						return e;
					}
					for (i = 0, a = t.length; i < a; i += 1) l.push(m(u(t[i]), r));
					return s = 0, d(e, { enter: function(e) {
						for (var t; s < l.length && !((t = l[s]).extendedRange[1] > e.range[0]);) t.extendedRange[1] === e.range[0] ? (e.leadingComments ||= [], e.leadingComments.push(t), l.splice(s, 1)) : s += 1;
						return s === l.length ? n.Break : l[s].extendedRange[0] > e.range[1] ? n.Skip : void 0;
					} }), s = 0, d(e, { leave: function(e) {
						for (var t; s < l.length && (t = l[s], !(e.range[1] < t.extendedRange[0]));) e.range[1] === t.extendedRange[0] ? (e.trailingComments ||= [], e.trailingComments.push(t), l.splice(s, 1)) : s += 1;
						return s === l.length ? n.Break : l[s].extendedRange[0] > e.range[1] ? n.Skip : void 0;
					} }), e;
				}, t.VisitorKeys = o, t.VisitorOption = n, t.Controller = f, t.cloneEnvironment = function() {
					return e({});
				}, t;
			})(t);
		})), s = a((function(e) {
			e.exports &&= function() {
				function e(t, r, n, o) {
					this.message = t, this.expected = r, this.found = n, this.location = o, this.name = "SyntaxError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, e);
				}
				return function(e, t) {
					function r() {
						this.constructor = e;
					}
					r.prototype = t.prototype, e.prototype = new r();
				}(e, Error), e.buildMessage = function(e, t) {
					var r = {
						literal: function(e) {
							return "\"" + o(e.text) + "\"";
						},
						class: function(e) {
							var t, r = "";
							for (t = 0; t < e.parts.length; t++) r += e.parts[t] instanceof Array ? a(e.parts[t][0]) + "-" + a(e.parts[t][1]) : a(e.parts[t]);
							return "[" + (e.inverted ? "^" : "") + r + "]";
						},
						any: function(e) {
							return "any character";
						},
						end: function(e) {
							return "end of input";
						},
						other: function(e) {
							return e.description;
						}
					};
					function n(e) {
						return e.charCodeAt(0).toString(16).toUpperCase();
					}
					function o(e) {
						return e.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (function(e) {
							return "\\x0" + n(e);
						})).replace(/[\x10-\x1F\x7F-\x9F]/g, (function(e) {
							return "\\x" + n(e);
						}));
					}
					function a(e) {
						return e.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (function(e) {
							return "\\x0" + n(e);
						})).replace(/[\x10-\x1F\x7F-\x9F]/g, (function(e) {
							return "\\x" + n(e);
						}));
					}
					return "Expected " + function(e) {
						var t, n, o, a = Array(e.length);
						for (t = 0; t < e.length; t++) a[t] = (o = e[t], r[o.type](o));
						if (a.sort(), a.length > 0) {
							for (t = 1, n = 1; t < a.length; t++) a[t - 1] !== a[t] && (a[n] = a[t], n++);
							a.length = n;
						}
						switch (a.length) {
							case 1: return a[0];
							case 2: return a[0] + " or " + a[1];
							default: return a.slice(0, -1).join(", ") + ", or " + a[a.length - 1];
						}
					}(e) + " but " + function(e) {
						return e ? "\"" + o(e) + "\"" : "end of input";
					}(t) + " found.";
				}, {
					SyntaxError: e,
					parse: function(t, r) {
						r = r === void 0 ? {} : r;
						var n, o, a, i, s = {}, u = { start: me }, l = me, c = fe(" ", !1), f = /^[^ [\],():#!=><~+.]/, p = pe([
							" ",
							"[",
							"]",
							",",
							"(",
							")",
							":",
							"#",
							"!",
							"=",
							">",
							"<",
							"~",
							"+",
							"."
						], !0, !1), h = fe(">", !1), y = fe("~", !1), d = fe("+", !1), m = fe(",", !1), x = function(e, t) {
							return [e].concat(t.map((function(e) {
								return e[3];
							})));
						}, v = fe("!", !1), g = fe("*", !1), A = fe("#", !1), E = fe("[", !1), b = fe("]", !1), S = /^[><!]/, _ = pe([
							">",
							"<",
							"!"
						], !1, !1), C = fe("=", !1), w = function(e) {
							return (e || "") + "=";
						}, P = /^[><]/, k = pe([">", "<"], !1, !1), D = fe(".", !1), I = function(e, t, r) {
							return {
								type: "attribute",
								name: e,
								operator: t,
								value: r
							};
						}, j = fe("\"", !1), T = /^[^\\"]/, F = pe(["\\", "\""], !0, !1), R = fe("\\", !1), O = { type: "any" }, L = function(e, t) {
							return e + t;
						}, M = function(e) {
							return {
								type: "literal",
								value: (t = e.join(""), t.replace(/\\(.)/g, (function(e, t) {
									switch (t) {
										case "b": return "\b";
										case "f": return "\f";
										case "n": return "\n";
										case "r": return "\r";
										case "t": return "	";
										case "v": return "\v";
										default: return t;
									}
								})))
							};
							var t;
						}, B = fe("'", !1), U = /^[^\\']/, K = pe(["\\", "'"], !0, !1), N = /^[0-9]/, W = pe([["0", "9"]], !1, !1), q = fe("type(", !1), V = /^[^ )]/, G = pe([" ", ")"], !0, !1), z = fe(")", !1), H = /^[imsu]/, Y = pe([
							"i",
							"m",
							"s",
							"u"
						], !1, !1), $ = fe("/", !1), J = /^[^\/]/, Q = pe(["/"], !0, !1), X = fe(":not(", !1), Z = fe(":matches(", !1), ee = fe(":has(", !1), te = fe(":first-child", !1), re = fe(":last-child", !1), ne = fe(":nth-child(", !1), oe = fe(":nth-last-child(", !1), ae = fe(":", !1), ie = 0, se = [{
							line: 1,
							column: 1
						}], ue = 0, le = [], ce = {};
						if ("startRule" in r) {
							if (!(r.startRule in u)) throw Error("Can't start parsing from rule \"" + r.startRule + "\".");
							l = u[r.startRule];
						}
						function fe(e, t) {
							return {
								type: "literal",
								text: e,
								ignoreCase: t
							};
						}
						function pe(e, t, r) {
							return {
								type: "class",
								parts: e,
								inverted: t,
								ignoreCase: r
							};
						}
						function he(e) {
							var r, n = se[e];
							if (n) return n;
							for (r = e - 1; !se[r];) r--;
							for (n = {
								line: (n = se[r]).line,
								column: n.column
							}; r < e;) t.charCodeAt(r) === 10 ? (n.line++, n.column = 1) : n.column++, r++;
							return se[e] = n, n;
						}
						function ye(e, t) {
							var r = he(e), n = he(t);
							return {
								start: {
									offset: e,
									line: r.line,
									column: r.column
								},
								end: {
									offset: t,
									line: n.line,
									column: n.column
								}
							};
						}
						function de(e) {
							ie < ue || (ie > ue && (ue = ie, le = []), le.push(e));
						}
						function me() {
							var e, t, r, n, o = 32 * ie + 0, a = ce[o];
							return a ? (ie = a.nextPos, a.result) : (e = ie, (t = xe()) !== s && (r = Ae()) !== s && xe() !== s ? e = t = (n = r).length === 1 ? n[0] : {
								type: "matches",
								selectors: n
							} : (ie = e, e = s), e === s && (e = ie, (t = xe()) !== s && (t = void 0), e = t), ce[o] = {
								nextPos: ie,
								result: e
							}, e);
						}
						function xe() {
							var e, r, n = 32 * ie + 1, o = ce[n];
							if (o) return ie = o.nextPos, o.result;
							for (e = [], t.charCodeAt(ie) === 32 ? (r = " ", ie++) : (r = s, de(c)); r !== s;) e.push(r), t.charCodeAt(ie) === 32 ? (r = " ", ie++) : (r = s, de(c));
							return ce[n] = {
								nextPos: ie,
								result: e
							}, e;
						}
						function ve() {
							var e, r, n, o = 32 * ie + 2, a = ce[o];
							if (a) return ie = a.nextPos, a.result;
							if (r = [], f.test(t.charAt(ie)) ? (n = t.charAt(ie), ie++) : (n = s, de(p)), n !== s) for (; n !== s;) r.push(n), f.test(t.charAt(ie)) ? (n = t.charAt(ie), ie++) : (n = s, de(p));
							else r = s;
							return r !== s && (r = r.join("")), e = r, ce[o] = {
								nextPos: ie,
								result: e
							}, e;
						}
						function ge() {
							var e, r, n, o = 32 * ie + 3, a = ce[o];
							return a ? (ie = a.nextPos, a.result) : (e = ie, (r = xe()) === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 62 ? (n = ">", ie++) : (n = s, de(h)), n !== s && xe() !== s ? e = r = "child" : (ie = e, e = s)), e === s && (e = ie, (r = xe()) === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 126 ? (n = "~", ie++) : (n = s, de(y)), n !== s && xe() !== s ? e = r = "sibling" : (ie = e, e = s)), e === s && (e = ie, (r = xe()) === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 43 ? (n = "+", ie++) : (n = s, de(d)), n !== s && xe() !== s ? e = r = "adjacent" : (ie = e, e = s)), e === s && (e = ie, t.charCodeAt(ie) === 32 ? (r = " ", ie++) : (r = s, de(c)), r !== s && (n = xe()) !== s ? e = r = "descendant" : (ie = e, e = s)))), ce[o] = {
								nextPos: ie,
								result: e
							}, e);
						}
						function Ae() {
							var e, r, n, o, a, i, u, l, c = 32 * ie + 5, f = ce[c];
							if (f) return ie = f.nextPos, f.result;
							if (e = ie, (r = be()) !== s) {
								for (n = [], o = ie, (a = xe()) === s ? (ie = o, o = s) : (t.charCodeAt(ie) === 44 ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = be()) !== s ? o = a = [
									a,
									i,
									u,
									l
								] : (ie = o, o = s)); o !== s;) n.push(o), o = ie, (a = xe()) === s ? (ie = o, o = s) : (t.charCodeAt(ie) === 44 ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = be()) !== s ? o = a = [
									a,
									i,
									u,
									l
								] : (ie = o, o = s));
								n === s ? (ie = e, e = s) : e = r = x(r, n);
							} else ie = e, e = s;
							return ce[c] = {
								nextPos: ie,
								result: e
							}, e;
						}
						function Ee() {
							var e, t, r, n, o, a = 32 * ie + 6, i = ce[a];
							return i ? (ie = i.nextPos, i.result) : (e = ie, (t = ge()) === s && (t = null), t !== s && (r = be()) !== s ? (o = r, e = t = (n = t) ? {
								type: n,
								left: { type: "exactNode" },
								right: o
							} : o) : (ie = e, e = s), ce[a] = {
								nextPos: ie,
								result: e
							}, e);
						}
						function be() {
							var e, t, r, n, o, a, i, u = 32 * ie + 7, l = ce[u];
							if (l) return ie = l.nextPos, l.result;
							if (e = ie, (t = Se()) !== s) {
								for (r = [], n = ie, (o = ge()) !== s && (a = Se()) !== s ? n = o = [o, a] : (ie = n, n = s); n !== s;) r.push(n), n = ie, (o = ge()) !== s && (a = Se()) !== s ? n = o = [o, a] : (ie = n, n = s);
								r === s ? (ie = e, e = s) : (i = t, e = t = r.reduce((function(e, t) {
									return {
										type: t[0],
										left: e,
										right: t[1]
									};
								}), i));
							} else ie = e, e = s;
							return ce[u] = {
								nextPos: ie,
								result: e
							}, e;
						}
						function Se() {
							var e, r, n, o, a, i, u, l = 32 * ie + 8, c = ce[l];
							if (c) return ie = c.nextPos, c.result;
							if (e = ie, t.charCodeAt(ie) === 33 ? (r = "!", ie++) : (r = s, de(v)), r === s && (r = null), r !== s) {
								if (n = [], (o = _e()) !== s) for (; o !== s;) n.push(o), o = _e();
								else n = s;
								n === s ? (ie = e, e = s) : (a = r, u = (i = n).length === 1 ? i[0] : {
									type: "compound",
									selectors: i
								}, a && (u.subject = !0), e = r = u);
							} else ie = e, e = s;
							return ce[l] = {
								nextPos: ie,
								result: e
							}, e;
						}
						function _e() {
							var e, r = 32 * ie + 9, n = ce[r];
							return n ? (ie = n.nextPos, n.result) : ((e = function() {
								var e, r, n = 32 * ie + 10, o = ce[n];
								return o ? (ie = o.nextPos, o.result) : (t.charCodeAt(ie) === 42 ? (r = "*", ie++) : (r = s, de(g)), r !== s && (r = {
									type: "wildcard",
									value: r
								}), e = r, ce[n] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n, o = 32 * ie + 11, a = ce[o];
								return a ? (ie = a.nextPos, a.result) : (e = ie, t.charCodeAt(ie) === 35 ? (r = "#", ie++) : (r = s, de(A)), r === s && (r = null), r !== s && (n = ve()) !== s ? e = r = {
									type: "identifier",
									value: n
								} : (ie = e, e = s), ce[o] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n, o, a = 32 * ie + 12, i = ce[a];
								return i ? (ie = i.nextPos, i.result) : (e = ie, t.charCodeAt(ie) === 91 ? (r = "[", ie++) : (r = s, de(E)), r !== s && xe() !== s && (n = function() {
									var e, r, n, o, a = 32 * ie + 16, i = ce[a];
									return i ? (ie = i.nextPos, i.result) : (e = ie, (r = Ce()) !== s && xe() !== s && (n = function() {
										var e, r, n, o = 32 * ie + 14, a = ce[o];
										return a ? (ie = a.nextPos, a.result) : (e = ie, t.charCodeAt(ie) === 33 ? (r = "!", ie++) : (r = s, de(v)), r === s && (r = null), r === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 61 ? (n = "=", ie++) : (n = s, de(C)), n === s ? (ie = e, e = s) : (r = w(r), e = r)), ce[o] = {
											nextPos: ie,
											result: e
										}, e);
									}()) !== s && xe() !== s ? ((o = function() {
										var e, r, n, o, a, i = 32 * ie + 20, u = ce[i];
										if (u) return ie = u.nextPos, u.result;
										if (e = ie, t.substr(ie, 5) === "type(" ? (r = "type(", ie += 5) : (r = s, de(q)), r !== s) if (xe() !== s) {
											if (n = [], V.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(G)), o !== s) for (; o !== s;) n.push(o), V.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(G));
											else n = s;
											n !== s && (o = xe()) !== s ? (t.charCodeAt(ie) === 41 ? (a = ")", ie++) : (a = s, de(z)), a === s ? (ie = e, e = s) : (r = {
												type: "type",
												value: n.join("")
											}, e = r)) : (ie = e, e = s);
										} else ie = e, e = s;
										else ie = e, e = s;
										return ce[i] = {
											nextPos: ie,
											result: e
										}, e;
									}()) === s && (o = function() {
										var e, r, n, o, a, i, u = 32 * ie + 22, l = ce[u];
										if (l) return ie = l.nextPos, l.result;
										if (e = ie, t.charCodeAt(ie) === 47 ? (r = "/", ie++) : (r = s, de($)), r !== s) {
											if (n = [], J.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(Q)), o !== s) for (; o !== s;) n.push(o), J.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(Q));
											else n = s;
											n === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 47 ? (o = "/", ie++) : (o = s, de($)), o === s ? (ie = e, e = s) : ((a = function() {
												var e, r, n = 32 * ie + 21, o = ce[n];
												if (o) return ie = o.nextPos, o.result;
												if (e = [], H.test(t.charAt(ie)) ? (r = t.charAt(ie), ie++) : (r = s, de(Y)), r !== s) for (; r !== s;) e.push(r), H.test(t.charAt(ie)) ? (r = t.charAt(ie), ie++) : (r = s, de(Y));
												else e = s;
												return ce[n] = {
													nextPos: ie,
													result: e
												}, e;
											}()) === s && (a = null), a === s ? (ie = e, e = s) : (i = a, r = {
												type: "regexp",
												value: new RegExp(n.join(""), i ? i.join("") : "")
											}, e = r)));
										} else ie = e, e = s;
										return ce[u] = {
											nextPos: ie,
											result: e
										}, e;
									}()), o === s ? (ie = e, e = s) : (r = I(r, n, o), e = r)) : (ie = e, e = s), e === s && (e = ie, (r = Ce()) !== s && xe() !== s && (n = function() {
										var e, r, n, o = 32 * ie + 13, a = ce[o];
										return a ? (ie = a.nextPos, a.result) : (e = ie, S.test(t.charAt(ie)) ? (r = t.charAt(ie), ie++) : (r = s, de(_)), r === s && (r = null), r === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 61 ? (n = "=", ie++) : (n = s, de(C)), n === s ? (ie = e, e = s) : (r = w(r), e = r)), e === s && (P.test(t.charAt(ie)) ? (e = t.charAt(ie), ie++) : (e = s, de(k))), ce[o] = {
											nextPos: ie,
											result: e
										}, e);
									}()) !== s && xe() !== s ? ((o = function() {
										var e, r, n, o, a, i, u = 32 * ie + 17, l = ce[u];
										if (l) return ie = l.nextPos, l.result;
										if (e = ie, t.charCodeAt(ie) === 34 ? (r = "\"", ie++) : (r = s, de(j)), r !== s) {
											for (n = [], T.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(F)), o === s && (o = ie, t.charCodeAt(ie) === 92 ? (a = "\\", ie++) : (a = s, de(R)), a === s ? (ie = o, o = s) : (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i === s ? (ie = o, o = s) : (a = L(a, i), o = a))); o !== s;) n.push(o), T.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(F)), o === s && (o = ie, t.charCodeAt(ie) === 92 ? (a = "\\", ie++) : (a = s, de(R)), a === s ? (ie = o, o = s) : (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i === s ? (ie = o, o = s) : (a = L(a, i), o = a)));
											n === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 34 ? (o = "\"", ie++) : (o = s, de(j)), o === s ? (ie = e, e = s) : (r = M(n), e = r));
										} else ie = e, e = s;
										if (e === s) if (e = ie, t.charCodeAt(ie) === 39 ? (r = "'", ie++) : (r = s, de(B)), r !== s) {
											for (n = [], U.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(K)), o === s && (o = ie, t.charCodeAt(ie) === 92 ? (a = "\\", ie++) : (a = s, de(R)), a === s ? (ie = o, o = s) : (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i === s ? (ie = o, o = s) : (a = L(a, i), o = a))); o !== s;) n.push(o), U.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(K)), o === s && (o = ie, t.charCodeAt(ie) === 92 ? (a = "\\", ie++) : (a = s, de(R)), a === s ? (ie = o, o = s) : (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i === s ? (ie = o, o = s) : (a = L(a, i), o = a)));
											n === s ? (ie = e, e = s) : (t.charCodeAt(ie) === 39 ? (o = "'", ie++) : (o = s, de(B)), o === s ? (ie = e, e = s) : (r = M(n), e = r));
										} else ie = e, e = s;
										return ce[u] = {
											nextPos: ie,
											result: e
										}, e;
									}()) === s && (o = function() {
										var e, r, n, o, a, i, u, l = 32 * ie + 18, c = ce[l];
										if (c) return ie = c.nextPos, c.result;
										for (e = ie, r = ie, n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)); o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));
										if (n === s ? (ie = r, r = s) : (t.charCodeAt(ie) === 46 ? (o = ".", ie++) : (o = s, de(D)), o === s ? (ie = r, r = s) : r = n = [n, o]), r === s && (r = null), r !== s) {
											if (n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)), o !== s) for (; o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));
											else n = s;
											n === s ? (ie = e, e = s) : (i = n, u = (a = r) ? [].concat.apply([], a).join("") : "", r = {
												type: "literal",
												value: parseFloat(u + i.join(""))
											}, e = r);
										} else ie = e, e = s;
										return ce[l] = {
											nextPos: ie,
											result: e
										}, e;
									}()) === s && (o = function() {
										var e, t, r = 32 * ie + 19, n = ce[r];
										return n ? (ie = n.nextPos, n.result) : ((t = ve()) !== s && (t = {
											type: "literal",
											value: t
										}), e = t, ce[r] = {
											nextPos: ie,
											result: e
										}, e);
									}()), o === s ? (ie = e, e = s) : (r = I(r, n, o), e = r)) : (ie = e, e = s), e === s && (e = ie, (r = Ce()) !== s && (r = {
										type: "attribute",
										name: r
									}), e = r)), ce[a] = {
										nextPos: ie,
										result: e
									}, e);
								}()) !== s && xe() !== s ? (t.charCodeAt(ie) === 93 ? (o = "]", ie++) : (o = s, de(b)), o === s ? (ie = e, e = s) : e = r = n) : (ie = e, e = s), ce[a] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n, o, a, i, u, l, c = 32 * ie + 23, f = ce[c];
								if (f) return ie = f.nextPos, f.result;
								if (e = ie, t.charCodeAt(ie) === 46 ? (r = ".", ie++) : (r = s, de(D)), r !== s) if ((n = ve()) !== s) {
									for (o = [], a = ie, t.charCodeAt(ie) === 46 ? (i = ".", ie++) : (i = s, de(D)), i !== s && (u = ve()) !== s ? a = i = [i, u] : (ie = a, a = s); a !== s;) o.push(a), a = ie, t.charCodeAt(ie) === 46 ? (i = ".", ie++) : (i = s, de(D)), i !== s && (u = ve()) !== s ? a = i = [i, u] : (ie = a, a = s);
									o === s ? (ie = e, e = s) : (l = n, r = {
										type: "field",
										name: o.reduce((function(e, t) {
											return e + t[0] + t[1];
										}), l)
									}, e = r);
								} else ie = e, e = s;
								else ie = e, e = s;
								return ce[c] = {
									nextPos: ie,
									result: e
								}, e;
							}()) === s && (e = function() {
								var e, r, n, o, a = 32 * ie + 24, i = ce[a];
								return i ? (ie = i.nextPos, i.result) : (e = ie, t.substr(ie, 5) === ":not(" ? (r = ":not(", ie += 5) : (r = s, de(X)), r !== s && xe() !== s && (n = Ae()) !== s && xe() !== s ? (t.charCodeAt(ie) === 41 ? (o = ")", ie++) : (o = s, de(z)), o === s ? (ie = e, e = s) : e = r = {
									type: "not",
									selectors: n
								}) : (ie = e, e = s), ce[a] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n, o, a = 32 * ie + 25, i = ce[a];
								return i ? (ie = i.nextPos, i.result) : (e = ie, t.substr(ie, 9) === ":matches(" ? (r = ":matches(", ie += 9) : (r = s, de(Z)), r !== s && xe() !== s && (n = Ae()) !== s && xe() !== s ? (t.charCodeAt(ie) === 41 ? (o = ")", ie++) : (o = s, de(z)), o === s ? (ie = e, e = s) : e = r = {
									type: "matches",
									selectors: n
								}) : (ie = e, e = s), ce[a] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n, o, a = 32 * ie + 26, i = ce[a];
								return i ? (ie = i.nextPos, i.result) : (e = ie, t.substr(ie, 5) === ":has(" ? (r = ":has(", ie += 5) : (r = s, de(ee)), r !== s && xe() !== s && (n = function() {
									var e, r, n, o, a, i, u, l, c = 32 * ie + 4, f = ce[c];
									if (f) return ie = f.nextPos, f.result;
									if (e = ie, (r = Ee()) !== s) {
										for (n = [], o = ie, (a = xe()) === s ? (ie = o, o = s) : (t.charCodeAt(ie) === 44 ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = Ee()) !== s ? o = a = [
											a,
											i,
											u,
											l
										] : (ie = o, o = s)); o !== s;) n.push(o), o = ie, (a = xe()) === s ? (ie = o, o = s) : (t.charCodeAt(ie) === 44 ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = Ee()) !== s ? o = a = [
											a,
											i,
											u,
											l
										] : (ie = o, o = s));
										n === s ? (ie = e, e = s) : e = r = x(r, n);
									} else ie = e, e = s;
									return ce[c] = {
										nextPos: ie,
										result: e
									}, e;
								}()) !== s && xe() !== s ? (t.charCodeAt(ie) === 41 ? (o = ")", ie++) : (o = s, de(z)), o === s ? (ie = e, e = s) : e = r = {
									type: "has",
									selectors: n
								}) : (ie = e, e = s), ce[a] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n = 32 * ie + 27, o = ce[n];
								return o ? (ie = o.nextPos, o.result) : (t.substr(ie, 12) === ":first-child" ? (r = ":first-child", ie += 12) : (r = s, de(te)), r !== s && (r = we(1)), e = r, ce[n] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n = 32 * ie + 28, o = ce[n];
								return o ? (ie = o.nextPos, o.result) : (t.substr(ie, 11) === ":last-child" ? (r = ":last-child", ie += 11) : (r = s, de(re)), r !== s && (r = Pe(1)), e = r, ce[n] = {
									nextPos: ie,
									result: e
								}, e);
							}()) === s && (e = function() {
								var e, r, n, o, a, i = 32 * ie + 29, u = ce[i];
								if (u) return ie = u.nextPos, u.result;
								if (e = ie, t.substr(ie, 11) === ":nth-child(" ? (r = ":nth-child(", ie += 11) : (r = s, de(ne)), r !== s) if (xe() !== s) {
									if (n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)), o !== s) for (; o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));
									else n = s;
									n !== s && (o = xe()) !== s ? (t.charCodeAt(ie) === 41 ? (a = ")", ie++) : (a = s, de(z)), a === s ? (ie = e, e = s) : (r = we(parseInt(n.join(""), 10)), e = r)) : (ie = e, e = s);
								} else ie = e, e = s;
								else ie = e, e = s;
								return ce[i] = {
									nextPos: ie,
									result: e
								}, e;
							}()) === s && (e = function() {
								var e, r, n, o, a, i = 32 * ie + 30, u = ce[i];
								if (u) return ie = u.nextPos, u.result;
								if (e = ie, t.substr(ie, 16) === ":nth-last-child(" ? (r = ":nth-last-child(", ie += 16) : (r = s, de(oe)), r !== s) if (xe() !== s) {
									if (n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)), o !== s) for (; o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));
									else n = s;
									n !== s && (o = xe()) !== s ? (t.charCodeAt(ie) === 41 ? (a = ")", ie++) : (a = s, de(z)), a === s ? (ie = e, e = s) : (r = Pe(parseInt(n.join(""), 10)), e = r)) : (ie = e, e = s);
								} else ie = e, e = s;
								else ie = e, e = s;
								return ce[i] = {
									nextPos: ie,
									result: e
								}, e;
							}()) === s && (e = function() {
								var e, r, n, o = 32 * ie + 31, a = ce[o];
								return a ? (ie = a.nextPos, a.result) : (e = ie, t.charCodeAt(ie) === 58 ? (r = ":", ie++) : (r = s, de(ae)), r !== s && (n = ve()) !== s ? e = r = {
									type: "class",
									name: n
								} : (ie = e, e = s), ce[o] = {
									nextPos: ie,
									result: e
								}, e);
							}()), ce[r] = {
								nextPos: ie,
								result: e
							}, e);
						}
						function Ce() {
							var e, r, n, o, a, i, u, l, c = 32 * ie + 15, f = ce[c];
							if (f) return ie = f.nextPos, f.result;
							if (e = ie, (r = ve()) !== s) {
								for (n = [], o = ie, t.charCodeAt(ie) === 46 ? (a = ".", ie++) : (a = s, de(D)), a !== s && (i = ve()) !== s ? o = a = [a, i] : (ie = o, o = s); o !== s;) n.push(o), o = ie, t.charCodeAt(ie) === 46 ? (a = ".", ie++) : (a = s, de(D)), a !== s && (i = ve()) !== s ? o = a = [a, i] : (ie = o, o = s);
								n === s ? (ie = e, e = s) : (u = r, l = n, e = r = [].concat.apply([u], l).join(""));
							} else ie = e, e = s;
							return ce[c] = {
								nextPos: ie,
								result: e
							}, e;
						}
						function we(e) {
							return {
								type: "nth-child",
								index: {
									type: "literal",
									value: e
								}
							};
						}
						function Pe(e) {
							return {
								type: "nth-last-child",
								index: {
									type: "literal",
									value: e
								}
							};
						}
						if ((n = l()) !== s && ie === t.length) return n;
						throw n !== s && ie < t.length && de({ type: "end" }), o = le, a = ue < t.length ? t.charAt(ue) : null, i = ue < t.length ? ye(ue, ue + 1) : ye(ue, ue), new e(e.buildMessage(o, a), o, a, i);
					}
				};
			}();
		}));
		function u(e, t) {
			for (var r = 0; r < t.length; ++r) {
				if (e == null) return e;
				e = e[t[r]];
			}
			return e;
		}
		var l = typeof WeakMap == "function" ? /* @__PURE__ */ new WeakMap() : null;
		function c(e) {
			if (e == null) return function() {
				return !0;
			};
			if (l != null) {
				var t = l.get(e);
				return t ?? (t = f(e), l.set(e, t)), t;
			}
			return f(e);
		}
		function f(t) {
			switch (t.type) {
				case "wildcard": return function() {
					return !0;
				};
				case "identifier":
					var r = t.value.toLowerCase();
					return function(e, t, n) {
						return r === e[n && n.nodeTypeKey || "type"].toLowerCase();
					};
				case "exactNode": return function(e, t) {
					return t.length === 0;
				};
				case "field":
					var n = t.name.split(".");
					return function(e, t) {
						return function e(t, r, n, o) {
							for (var a = r, i = o; i < n.length; ++i) {
								if (a == null) return !1;
								var s = a[n[i]];
								if (Array.isArray(s)) {
									for (var u = 0; u < s.length; ++u) if (e(t, s[u], n, i + 1)) return !0;
									return !1;
								}
								a = s;
							}
							return t === a;
						}(e, t[n.length - 1], n, 0);
					};
				case "matches":
					var o = t.selectors.map(c);
					return function(e, t, r) {
						for (var n = 0; n < o.length; ++n) if (o[n](e, t, r)) return !0;
						return !1;
					};
				case "compound":
					var a = t.selectors.map(c);
					return function(e, t, r) {
						for (var n = 0; n < a.length; ++n) if (!a[n](e, t, r)) return !1;
						return !0;
					};
				case "not":
					var s = t.selectors.map(c);
					return function(e, t, r) {
						for (var n = 0; n < s.length; ++n) if (s[n](e, t, r)) return !1;
						return !0;
					};
				case "has":
					var l = t.selectors.map(c);
					return function(e, t, r) {
						var n = !1, o = [];
						return i.traverse(e, {
							enter: function(e, t) {
								t != null && o.unshift(t);
								for (var a = 0; a < l.length; ++a) if (l[a](e, o, r)) return n = !0, void this.break();
							},
							leave: function() {
								o.shift();
							},
							keys: r && r.visitorKeys,
							fallback: r && r.fallback || "iteration"
						}), n;
					};
				case "child":
					var f = c(t.left), p = c(t.right);
					return function(e, t, r) {
						return !!(t.length > 0 && p(e, t, r)) && f(t[0], t.slice(1), r);
					};
				case "descendant":
					var h = c(t.left), x = c(t.right);
					return function(e, t, r) {
						if (x(e, t, r)) {
							for (var n = 0, o = t.length; n < o; ++n) if (h(t[n], t.slice(n + 1), r)) return !0;
						}
						return !1;
					};
				case "attribute":
					var v = t.name.split(".");
					switch (t.operator) {
						case void 0: return function(e) {
							return u(e, v) != null;
						};
						case "=":
							switch (t.value.type) {
								case "regexp": return function(e) {
									var r = u(e, v);
									return typeof r == "string" && t.value.value.test(r);
								};
								case "literal":
									var g = `${t.value.value}`;
									return function(e) {
										return g === `${u(e, v)}`;
									};
								case "type": return function(r) {
									return t.value.value === e(u(r, v));
								};
							}
							throw Error(`Unknown selector value type: ${t.value.type}`);
						case "!=":
							switch (t.value.type) {
								case "regexp": return function(e) {
									return !t.value.value.test(u(e, v));
								};
								case "literal":
									var A = `${t.value.value}`;
									return function(e) {
										return A !== `${u(e, v)}`;
									};
								case "type": return function(r) {
									return t.value.value !== e(u(r, v));
								};
							}
							throw Error(`Unknown selector value type: ${t.value.type}`);
						case "<=": return function(e) {
							return u(e, v) <= t.value.value;
						};
						case "<": return function(e) {
							return u(e, v) < t.value.value;
						};
						case ">": return function(e) {
							return u(e, v) > t.value.value;
						};
						case ">=": return function(e) {
							return u(e, v) >= t.value.value;
						};
					}
					throw Error(`Unknown operator: ${t.operator}`);
				case "sibling":
					var E = c(t.left), b = c(t.right);
					return function(e, r, n) {
						return b(e, r, n) && y(e, E, r, "LEFT_SIDE", n) || t.left.subject && E(e, r, n) && y(e, b, r, "RIGHT_SIDE", n);
					};
				case "adjacent":
					var S = c(t.left), _ = c(t.right);
					return function(e, r, n) {
						return _(e, r, n) && d(e, S, r, "LEFT_SIDE", n) || t.right.subject && S(e, r, n) && d(e, _, r, "RIGHT_SIDE", n);
					};
				case "nth-child":
					var C = t.index.value, w = c(t.right);
					return function(e, t, r) {
						return w(e, t, r) && m(e, t, C, r);
					};
				case "nth-last-child":
					var P = -t.index.value, k = c(t.right);
					return function(e, t, r) {
						return k(e, t, r) && m(e, t, P, r);
					};
				case "class":
					var D = t.name.toLowerCase();
					return function(e, r, n) {
						if (n && n.matchClass) return n.matchClass(t.name, e, r);
						if (n && n.nodeTypeKey) return !1;
						switch (D) {
							case "statement": if (e.type.slice(-9) === "Statement") return !0;
							case "declaration": return e.type.slice(-11) === "Declaration";
							case "pattern": if (e.type.slice(-7) === "Pattern") return !0;
							case "expression": return e.type.slice(-10) === "Expression" || e.type.slice(-7) === "Literal" || e.type === "Identifier" && (r.length === 0 || r[0].type !== "MetaProperty") || e.type === "MetaProperty";
							case "function": return e.type === "FunctionDeclaration" || e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression";
						}
						throw Error(`Unknown class name: ${t.name}`);
					};
			}
			throw Error(`Unknown selector type: ${t.type}`);
		}
		function p(e, t) {
			var r = t && t.nodeTypeKey || "type", n = e[r];
			return t && t.visitorKeys && t.visitorKeys[n] ? t.visitorKeys[n] : i.VisitorKeys[n] ? i.VisitorKeys[n] : t && typeof t.fallback == "function" ? t.fallback(e) : Object.keys(e).filter((function(e) {
				return e !== r;
			}));
		}
		function h(t, r) {
			var n = r && r.nodeTypeKey || "type";
			return t !== null && e(t) === "object" && typeof t[n] == "string";
		}
		function y(e, r, n, o, a) {
			var i = t(n, 1)[0];
			if (!i) return !1;
			for (var s = p(i, a), u = 0; u < s.length; ++u) {
				var l = i[s[u]];
				if (Array.isArray(l)) {
					var c = l.indexOf(e);
					if (c < 0) continue;
					var f = void 0, y = void 0;
					o === "LEFT_SIDE" ? (f = 0, y = c) : (f = c + 1, y = l.length);
					for (var d = f; d < y; ++d) if (h(l[d], a) && r(l[d], n, a)) return !0;
				}
			}
			return !1;
		}
		function d(e, r, n, o, a) {
			var i = t(n, 1)[0];
			if (!i) return !1;
			for (var s = p(i, a), u = 0; u < s.length; ++u) {
				var l = i[s[u]];
				if (Array.isArray(l)) {
					var c = l.indexOf(e);
					if (c < 0) continue;
					if (o === "LEFT_SIDE" && c > 0 && h(l[c - 1], a) && r(l[c - 1], n, a) || o === "RIGHT_SIDE" && c < l.length - 1 && h(l[c + 1], a) && r(l[c + 1], n, a)) return !0;
				}
			}
			return !1;
		}
		function m(e, r, n, o) {
			if (n === 0) return !1;
			var a = t(r, 1)[0];
			if (!a) return !1;
			for (var i = p(a, o), s = 0; s < i.length; ++s) {
				var u = a[i[s]];
				if (Array.isArray(u)) {
					var l = n < 0 ? u.length + n : n - 1;
					if (l >= 0 && l < u.length && u[l] === e) return !0;
				}
			}
			return !1;
		}
		function x(t, n, o, a) {
			if (n) {
				var s = [], u = c(n), l = function t(n, o) {
					if (n == null || e(n) != "object") return [];
					o ??= n;
					for (var a = n.subject ? [o] : [], i = Object.keys(n), s = 0; s < i.length; ++s) {
						var u = i[s], l = n[u];
						a.push.apply(a, r(t(l, u === "left" ? l : o)));
					}
					return a;
				}(n).map(c);
				i.traverse(t, {
					enter: function(e, t) {
						if (t != null && s.unshift(t), u(e, s, a)) if (l.length) for (var r = 0, n = l.length; r < n; ++r) {
							l[r](e, s, a) && o(e, t, s);
							for (var i = 0, c = s.length; i < c; ++i) {
								var f = s.slice(i + 1);
								l[r](s[i], f, a) && o(s[i], t, f);
							}
						}
						else o(e, t, s);
					},
					leave: function() {
						s.shift();
					},
					keys: a && a.visitorKeys,
					fallback: a && a.fallback || "iteration"
				});
			}
		}
		function v(e, t, r) {
			var n = [];
			return x(e, t, (function(e) {
				n.push(e);
			}), r), n;
		}
		function g(e) {
			return s.parse(e);
		}
		function A(e, t, r) {
			return v(e, g(t), r);
		}
		return A.parse = g, A.match = v, A.traverse = x, A.matches = function(e, t, r, n) {
			return !t || !!e && (r ||= [], c(t)(e, r, n));
		}, A.query = A, A;
	}));
})))(), 1)).default, ESQUERY_OPTIONS = {
	nodeTypeKey: "type",
	visitorKeys: keys_default,
	fallback(node) {
		throw Error(`Unknown node type: ${node.type}`);
	},
	matchClass: matchesSelectorClass
};
function matchesSelectorClass(className, node, _ancestors) {
	let { type } = node;
	switch (className.toLowerCase()) {
		case "statement": if (type.endsWith("Statement")) return !0;
		case "declaration": return type.endsWith("Declaration");
		case "pattern": if (type.endsWith("Pattern")) return !0;
		case "expression": return type.endsWith("Expression") || type.endsWith("Literal") || type === "Identifier" && node.parent.type !== "MetaProperty" || type === "MetaProperty";
		case "function": return type === "FunctionDeclaration" || type === "FunctionExpression" || type === "ArrowFunctionExpression";
		default: return !1;
	}
}
const cache = /* @__PURE__ */ new Map([]), EMPTY_TYPE_IDS_ARRAY = [];
function parseSelector(key) {
	let selector = cache.get(key);
	if (selector !== void 0) return selector;
	let esquerySelector = esqueryParse(key);
	return selector = {
		typeIds: null,
		esquerySelector,
		isComplex: !1,
		specificity: 0
	}, selector.typeIds = analyzeSelector(esquerySelector, selector), cache.set(key, selector), selector;
}
function analyzeSelector(esquerySelector, selector) {
	switch (esquerySelector.type) {
		case "identifier": {
			selector.specificity += 1;
			let typeId = NODE_TYPE_IDS_MAP.get(esquerySelector.value);
			return typeId === void 0 || typeId >= 165 ? EMPTY_TYPE_IDS_ARRAY : [typeId];
		}
		case "not":
			for (let i = 0, childSelectors = esquerySelector.selectors, len = childSelectors.length; i < len; i++) analyzeSelector(childSelectors[i], selector);
			return selector.isComplex = !0, null;
		case "matches": {
			let nodeTypes = [];
			for (let i = 0, childSelectors = esquerySelector.selectors, len = childSelectors.length; i < len; i++) {
				let childNodeTypes = analyzeSelector(childSelectors[i], selector);
				childNodeTypes === null ? nodeTypes = null : nodeTypes !== null && nodeTypes.push(...childNodeTypes);
			}
			return nodeTypes === null ? null : [...new Set(nodeTypes)];
		}
		case "compound": {
			let childSelectors = esquerySelector.selectors, len = childSelectors.length;
			if (len === 0) return [];
			let nodeTypes = null;
			for (let i = 0; i < len; i++) {
				let childNodeTypes = analyzeSelector(childSelectors[i], selector);
				childNodeTypes !== null && (nodeTypes = nodeTypes === null ? childNodeTypes : childNodeTypes.filter((nodeType) => nodeTypes.includes(nodeType)));
			}
			return nodeTypes;
		}
		case "attribute":
		case "field":
		case "nth-child":
		case "nth-last-child": return selector.isComplex = !0, selector.specificity += 32768, null;
		case "child":
		case "descendant":
		case "sibling":
		case "adjacent": return selector.isComplex = !0, analyzeSelector(esquerySelector.left, selector), analyzeSelector(esquerySelector.right, selector);
		case "class": switch (esquerySelector.name.toLowerCase()) {
			case "statement": return STATEMENT_NODE_TYPE_IDS;
			case "declaration": return DECLARATION_NODE_TYPE_IDS;
			case "pattern": return selector.isComplex = !0, PATTERN_NODE_TYPE_IDS;
			case "expression": return selector.isComplex = !0, EXPRESSION_NODE_TYPE_IDS;
			case "function": return FUNCTION_NODE_TYPE_IDS;
			default: throw Error(`Invalid class in selector: \`:${esquerySelector.name}\``);
		}
		case "wildcard": return null;
		default: return selector.isComplex = !0, null;
	}
}
function wrapVisitFnWithSelectorMatch(visitFn, esquerySelector) {
	return (node) => {
		esqueryMatches(node, esquerySelector, ancestors, ESQUERY_OPTIONS) && visitFn(node);
	};
}
const compilingLeafVisitor = [], compilingNonLeafVisitor = [], compilingCfgVisitor = [];
for (let i = 27; i !== 0; i--) compilingLeafVisitor.push([]);
for (let i = 138; i !== 0; i--) compilingNonLeafVisitor.push({
	enter: [],
	exit: []
});
for (let i = 7; i !== 0; i--) compilingCfgVisitor.push([]);
const compiledVisitor = [];
for (let i = 172; i !== 0; i--) compiledVisitor.push(null);
const activeLeafVisitorTypeIds = [], activeNonLeafVisitorTypeIds = [], activeCfgVisitorTypeIds = [];
for (let i = 27; i !== 0; i--) activeLeafVisitorTypeIds.push(0);
for (let i = 138; i !== 0; i--) activeNonLeafVisitorTypeIds.push(0);
for (let i = 7; i !== 0; i--) activeCfgVisitorTypeIds.push(0);
activeLeafVisitorTypeIds.length = 0, activeNonLeafVisitorTypeIds.length = 0, activeCfgVisitorTypeIds.length = 0;
let hasActiveVisitors = !1;
const enterExitObjectCache = [];
let enterExitObjectCacheNextIndex = 0;
const visitPropsCache = [];
let visitPropsCacheNextIndex = 0;
function initCompiledVisitor() {
	for (let i = 0; i < 172; i++) compiledVisitor[i] = null;
	for (let i = 0; i < enterExitObjectCacheNextIndex; i++) {
		let enterExit = enterExitObjectCache[i];
		enterExit.enter = null, enterExit.exit = null;
	}
	enterExitObjectCacheNextIndex = 0;
}
function addVisitorToCompiled(visitor) {
	if (typeof visitor != "object" || !visitor) throw TypeError("Visitor returned from `create` method must be an object");
	let keys = ObjectKeys(visitor), keysLen = keys.length;
	if (keysLen !== 0) {
		hasActiveVisitors = !0;
		for (let i = 0; i < keysLen; i++) {
			let name = keys[i], visitFn = visitor[name];
			if (typeof visitFn != "function") throw TypeError(`'${name}' property of visitor object is not a function`);
			let specificity = 0, isExit = name.endsWith(":exit");
			isExit && (name = name.slice(0, -5), specificity = 536870912);
			let visitProp;
			visitPropsCacheNextIndex < visitPropsCache.length ? (visitProp = visitPropsCache[visitPropsCacheNextIndex], visitProp.fn = visitFn, visitProp.specificity = specificity, visitProp.selectorStr = name) : (visitProp = {
				fn: visitFn,
				specificity,
				selectorStr: name
			}, visitPropsCache.push(visitProp)), visitPropsCacheNextIndex++;
			let typeId = NODE_TYPE_IDS_MAP.get(name);
			if (typeId !== void 0) {
				visitProp.specificity |= 1, typeId < 27 ? addLeafVisitFn(typeId, visitProp) : typeId < 165 ? addNonLeafVisitFn(typeId, visitProp, isExit) : addCfgVisitFn(typeId, visitProp, isExit);
				continue;
			}
			if (name !== "*") {
				let selector = parseSelector(name);
				visitProp.specificity |= selector.specificity, selector.isComplex && (visitProp.fn = wrapVisitFnWithSelectorMatch(visitFn, selector.esquerySelector));
				let { typeIds } = selector;
				if (typeIds !== null) {
					for (let i = 0, len = typeIds.length; i < len; i++) {
						let typeId = typeIds[i];
						typeId < 27 ? addLeafVisitFn(typeId, visitProp) : addNonLeafVisitFn(typeId, visitProp, isExit);
					}
					continue;
				}
			}
			for (typeId = 0; typeId < 27; typeId++) addLeafVisitFn(typeId, visitProp);
			for (; typeId < 165; typeId++) addNonLeafVisitFn(typeId, visitProp, isExit);
		}
	}
}
function addLeafVisitFn(typeId, visitProp) {
	let visitProps = compilingLeafVisitor[typeId];
	visitProps.length === 0 && activeLeafVisitorTypeIds.push(typeId), visitProps.push(visitProp);
}
function addNonLeafVisitFn(typeId, visitProp, isExit) {
	let { enter, exit } = compilingNonLeafVisitor[typeId - 27];
	enter.length === 0 && exit.length === 0 && activeNonLeafVisitorTypeIds.push(typeId), isExit ? exit.push(visitProp) : enter.push(visitProp);
}
function addCfgVisitFn(typeId, visitProp, isExit) {
	if (isExit) throw Error(`Invalid visitor key: \`${visitProp.selectorStr}:exit\``);
	let visitProps = compilingCfgVisitor[typeId - 165];
	visitProps.length === 0 && activeCfgVisitorTypeIds.push(typeId), visitProps.push(visitProp);
}
function finalizeCompiledVisitor() {
	if (hasActiveVisitors === !1) return 0;
	for (let i = activeLeafVisitorTypeIds.length - 1; i >= 0; i--) {
		let typeId = activeLeafVisitorTypeIds[i];
		compiledVisitor[typeId] = mergeVisitFns(compilingLeafVisitor[typeId]);
	}
	for (let i = activeNonLeafVisitorTypeIds.length - 1; i >= 0; i--) {
		let typeId = activeNonLeafVisitorTypeIds[i], entry = compilingNonLeafVisitor[typeId - 27], enterExit;
		enterExitObjectCacheNextIndex < enterExitObjectCache.length ? enterExit = enterExitObjectCache[enterExitObjectCacheNextIndex] : (enterExit = {
			enter: null,
			exit: null
		}, enterExitObjectCache.push(enterExit)), enterExitObjectCacheNextIndex++;
		let enterArr = entry.enter;
		enterArr.length !== 0 && (enterExit.enter = mergeVisitFns(enterArr));
		let exitArr = entry.exit;
		exitArr.length !== 0 && (enterExit.exit = mergeVisitFns(exitArr)), compiledVisitor[typeId] = enterExit;
	}
	let visitState = 1;
	if (activeCfgVisitorTypeIds.length > 0) {
		visitState = 2;
		for (let i = activeCfgVisitorTypeIds.length - 1; i >= 0; i--) {
			let typeId = activeCfgVisitorTypeIds[i];
			compiledVisitor[typeId] = mergeVisitFns(compilingCfgVisitor[typeId - 165]);
		}
		activeCfgVisitorTypeIds.length = 0;
	}
	for (let i = visitPropsCacheNextIndex - 1; i >= 0; i--) visitPropsCache[i].fn = null, visitPropsCache[i].selectorStr = null;
	return visitPropsCacheNextIndex = 0, activeLeafVisitorTypeIds.length = 0, activeNonLeafVisitorTypeIds.length = 0, hasActiveVisitors = !1, visitState;
}
const visitFns = [];
function mergeVisitFns(visitProps) {
	let numVisitFns = visitProps.length, mergedFn;
	if (numVisitFns === 1) mergedFn = visitProps[0].fn;
	else {
		visitProps.sort((a, b) => {
			let diff = a.specificity - b.specificity;
			if (diff !== 0) return diff;
			let strA = a.selectorStr, strB = b.selectorStr;
			return strA === strB ? 0 : strA < strB ? -1 : 1;
		});
		let merger;
		if (mergers.length <= numVisitFns) {
			for (; mergers.length < numVisitFns;) mergers.push(null);
			merger = createMerger(numVisitFns), mergers.push(merger);
		} else merger = mergers[numVisitFns], merger === null && (merger = mergers[numVisitFns] = createMerger(numVisitFns));
		for (let i = 0; i < numVisitFns; i++) visitFns.push(visitProps[i].fn);
		mergedFn = merger(...visitFns), visitFns.length = 0;
	}
	return visitProps.length = 0, mergedFn;
}
function createMerger(fnCount) {
	let args = [], body = "return node=>{";
	for (let i = 1; i <= fnCount; i++) args.push(`visit${i}`), body += `visit${i}(node);`;
	return body += "}", args.push(body), Function(...args);
}
const mergers = [
	null,
	null,
	(visit1, visit2) => (node) => {
		visit1(node), visit2(node);
	},
	(visit1, visit2, visit3) => (node) => {
		visit1(node), visit2(node), visit3(node);
	},
	(visit1, visit2, visit3, visit4) => (node) => {
		visit1(node), visit2(node), visit3(node), visit4(node);
	},
	(visit1, visit2, visit3, visit4, visit5) => (node) => {
		visit1(node), visit2(node), visit3(node), visit4(node), visit5(node);
	}
], buffers = [], afterHooks = [], PARSER_SERVICES_DEFAULT = ObjectFreeze({});
function lintFile(filePath, bufferId, buffer, ruleIds, optionsIds, settingsJSON, globalsJSON) {
	try {
		lintFileImpl(filePath, bufferId, buffer, ruleIds, optionsIds, settingsJSON, globalsJSON);
		let ret = null;
		return diagnostics.length !== 0 && (ret = JSONStringify({ Success: diagnostics }), diagnostics.length = 0), resetFile(), ret;
	} catch (err) {
		return resetStateAfterError(), JSONStringify({ Failure: getErrorMessage(err) });
	}
}
function lintFileImpl(filePath, bufferId, buffer, ruleIds, optionsIds, settingsJSON, globalsJSON) {
	if (buffer === null) buffer = buffers[bufferId];
	else {
		let { buffer: arrayBuffer, byteOffset } = buffer;
		buffer.uint32 = new Uint32Array(arrayBuffer, byteOffset), buffer.float64 = new Float64Array(arrayBuffer, byteOffset);
		for (let i = bufferId - buffers.length; i >= 0; i--) buffers.push(null);
		buffers[bufferId] = buffer;
	}
	setupFileContext(filePath);
	let hasBOM = buffer[2147483614] === 1;
	setupSourceForFile(buffer, hasBOM, PARSER_SERVICES_DEFAULT), setSettingsForFile(settingsJSON), setGlobalsForFile(globalsJSON), initCompiledVisitor();
	for (let i = 0, len = ruleIds.length; i < len; i++) {
		let ruleDetails = registeredRules[ruleIds[i]];
		ruleDetails.ruleIndex = i;
		let optionsId = optionsIds[i];
		ruleDetails.options = optionsId === 0 ? ruleDetails.defaultOptions : allOptions[optionsId];
		let { visitor } = ruleDetails;
		if (visitor === null) visitor = ruleDetails.rule.create(ruleDetails.context);
		else {
			let { beforeHook, afterHook } = ruleDetails;
			if (beforeHook !== null && beforeHook() === !1) continue;
			afterHook !== null && afterHooks.push(afterHook);
		}
		addVisitorToCompiled(visitor);
	}
	let visitorState = finalizeCompiledVisitor();
	visitorState !== 0 && (ast === null && initAst(), visitorState === 2 ? walkProgramWithCfg(ast, compiledVisitor) : walkProgram(ast, compiledVisitor));
	let afterHooksLen = afterHooks.length;
	if (afterHooksLen !== 0) {
		for (let i = 0; i < afterHooksLen; i++) (0, afterHooks[i])();
		afterHooks.length = 0;
	}
}
function resetFile() {
	resetFileContext(), resetSourceAndAst(), resetSettings(), resetGlobals();
}
function resetStateAfterError() {
	diagnostics.length = 0, ancestors.length = 0, resetFile(), resetCfgWalk();
}
export { ObjectHasOwn as A, ObjectAssign as C, ObjectEntries as D, ObjectDefineProperty as E, ObjectSetPrototypeOf as M, ObjectValues as N, ObjectFreeze as O, JSONStringify as S, ObjectDefineProperties as T, BUFFER_ALIGN as _, loadPlugin as a, ArrayFrom as b, getErrorMessage as c, setOptions as d, PLACEHOLDER_REGEX as f, getNodeByRangeIndex as g, getLineColumnFromOffset as h, resetStateAfterError as i, ObjectKeys as j, ObjectGetPrototypeOf as k, DEFAULT_OPTIONS_ID as l, replacePlaceholders as m, lintFile as n, registerPlugin as o, diagnostics as p, lintFileImpl as r, registeredRules as s, buffers as t, allOptions as u, BUFFER_SIZE as v, ObjectCreate as w, ArrayIsArray as x, DATA_POINTER_POS_32 as y };
